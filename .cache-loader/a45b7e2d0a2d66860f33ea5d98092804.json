{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\index.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\index.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nvar _ = require(\"../lodash\"), initOrder = require(\"./init-order\"), crossCount = require(\"./cross-count\"), sortSubgraph = require(\"./sort-subgraph\"), buildLayerGraph = require(\"./build-layer-graph\"), addSubgraphConstraints = require(\"./add-subgraph-constraints\"), Graph = require(\"../graphlib\").Graph, util = require(\"../util\");\r\nmodule.exports = order;\r\nfunction order(g) {\r\n    var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"), upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\r\n    var layering = initOrder(g);\r\n    assignOrder(g, layering);\r\n    var bestCC = Number.POSITIVE_INFINITY, best;\r\n    for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\r\n        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\r\n        layering = util.buildLayerMatrix(g);\r\n        var cc = crossCount(g, layering);\r\n        if (cc < bestCC) {\r\n            lastBest = 0;\r\n            best = _.cloneDeep(layering);\r\n            bestCC = cc;\r\n        }\r\n    }\r\n    assignOrder(g, best);\r\n}\r\nfunction buildLayerGraphs(g, ranks, relationship) {\r\n    return _.map(ranks, function (rank) {\r\n        return buildLayerGraph(g, rank, relationship);\r\n    });\r\n}\r\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\r\n    var cg = new Graph();\r\n    _.forEach(layerGraphs, function (lg) {\r\n        var root = lg.graph().root;\r\n        var sorted = sortSubgraph(lg, root, cg, biasRight);\r\n        _.forEach(sorted.vs, function (v, i) {\r\n            lg.node(v).order = i;\r\n        });\r\n        addSubgraphConstraints(lg, cg, sorted.vs);\r\n    });\r\n}\r\nfunction assignOrder(g, layering) {\r\n    _.forEach(layering, function (layer) {\r\n        _.forEach(layer, function (v, i) {\r\n            g.node(v).order = i;\r\n        });\r\n    });\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\index.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\index.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\"),\n    initOrder = require(\"./init-order\"),\n    crossCount = require(\"./cross-count\"),\n    sortSubgraph = require(\"./sort-subgraph\"),\n    buildLayerGraph = require(\"./build-layer-graph\"),\n    addSubgraphConstraints = require(\"./add-subgraph-constraints\"),\n    Graph = require(\"../graphlib\").Graph,\n    util = require(\"../util\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n      downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n      upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n      best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n"]}]}