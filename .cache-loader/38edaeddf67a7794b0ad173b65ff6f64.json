{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/dendrogram.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/dendrogram.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var util = require('../util');\nfunction WrappedTree(height, children) {\n    if (height === void 0) {\n        height = 0;\n    }\n    if (children === void 0) {\n        children = [];\n    }\n    var me = this;\n    me.x = me.y = 0;\n    me.leftChild = me.rightChild = null;\n    me.height = 0;\n    me.children = children;\n}\nvar DEFAULT_OPTIONS = {\n    isHorizontal: true,\n    nodeSep: 20,\n    nodeSize: 20,\n    rankSep: 200,\n    subTreeSep: 10\n};\nfunction convertBack(converted, root, isHorizontal) {\n    if (isHorizontal) {\n        root.x = converted.x;\n        root.y = converted.y;\n    }\n    else {\n        root.x = converted.y;\n        root.y = converted.x;\n    }\n    converted.children.forEach(function (child, i) {\n        convertBack(child, root.children[i], isHorizontal);\n    });\n}\nmodule.exports = function (root, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    options = util.assign({}, DEFAULT_OPTIONS, options);\n    var maxDepth = 0;\n    function wrappedTreeFromNode(n) {\n        if (!n)\n            return null;\n        n.width = 0;\n        if (n.depth && n.depth > maxDepth) {\n            maxDepth = n.depth;\n        }\n        var children = n.children;\n        var childrenCount = children.length;\n        var t = new WrappedTree(n.height, []);\n        children.forEach(function (child, i) {\n            var childWT = wrappedTreeFromNode(child);\n            t.children.push(childWT);\n            if (i === 0) {\n                t.leftChild = childWT;\n            }\n            if (i === childrenCount - 1) {\n                t.rightChild = childWT;\n            }\n        });\n        t.originNode = n;\n        t.isLeaf = n.isLeaf();\n        return t;\n    }\n    function getDrawingDepth(t) {\n        if (t.isLeaf || t.children.length === 0) {\n            t.drawingDepth = maxDepth;\n        }\n        else {\n            var depths = t.children.map(function (child) {\n                return getDrawingDepth(child);\n            });\n            var minChildDepth = Math.min.apply(null, depths);\n            t.drawingDepth = minChildDepth - 1;\n        }\n        return t.drawingDepth;\n    }\n    var prevLeaf;\n    function position(t) {\n        t.x = t.drawingDepth * options.rankSep;\n        if (t.isLeaf) {\n            t.y = 0;\n            if (prevLeaf) {\n                t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n                if (t.originNode.parent !== prevLeaf.originNode.parent) {\n                    t.y += options.subTreeSep;\n                }\n            }\n            prevLeaf = t;\n        }\n        else {\n            t.children.forEach(function (child) {\n                position(child);\n            });\n            t.y = (t.leftChild.y + t.rightChild.y) / 2;\n        }\n    }\n    var wt = wrappedTreeFromNode(root);\n    getDrawingDepth(wt);\n    position(wt);\n    convertBack(wt, root, options.isHorizontal);\n    return root;\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/dendrogram.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/dendrogram.js"],"names":[],"mappings":"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","sourcesContent":["// wrap tree node\n// TODO considering size\nvar util = require('../util');\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};"]}]}