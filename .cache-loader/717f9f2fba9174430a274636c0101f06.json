{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/gauge/geometry/shape/gauge-shape.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/gauge/geometry/shape/gauge-shape.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __assign } from \"tslib\";\nimport { clone, deepMix } from '@antv/util';\nimport { registerShape } from '@antv/g2';\nimport { getGlobalTheme } from '../../../../theme';\nimport { sortedLastIndex } from '../../../../util/common';\nvar GaugeShape = (function () {\n    function GaugeShape(uid) {\n        this.uid = uid;\n    }\n    GaugeShape.prototype.setOption = function (type, options) {\n        this.type = type;\n        this.options = options;\n        this.axis = options.axis;\n        this.pivot = options.pivot;\n    };\n    GaugeShape.prototype.render = function () {\n        var Gauge = this;\n        registerShape('point', 'gauge', {\n            draw: function (cfg, group) {\n                var _a, _b, _c;\n                this.gauge = {};\n                this.gauge.options = Gauge.options;\n                this.gauge.axis = Gauge.axis;\n                this.gauge.pivot = Gauge.pivot;\n                this.gauge.type = Gauge.type;\n                var gauge = this.gauge;\n                var type = this.gauge.type;\n                var point = cfg.points[0];\n                var center = this.parsePoint({\n                    x: 0,\n                    y: 0,\n                });\n                var target = this.parsePoint({\n                    x: point.x || 0,\n                    y: 1,\n                });\n                gauge.center = center;\n                gauge.group = group;\n                var r = { x: center.x - target.x, y: center.y - target.y };\n                this.gauge.ringRadius = Math.sqrt(r.x * r.x + r.y * r.y);\n                var _d = this.getAngleRange(), starAngle = _d.starAngle, endAngle = _d.endAngle;\n                var currentAngle = point.x * (endAngle - starAngle) + starAngle;\n                switch (type) {\n                    case 'meterGauge':\n                        this.drawBarGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_a = this.gauge.axis.tickLine) === null || _a === void 0 ? void 0 : _a.visible)) {\n                            this.drawInSideAxis();\n                        }\n                        break;\n                    case 'fanGauge':\n                        this.drawGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_b = this.gauge.axis.tickLine) === null || _b === void 0 ? void 0 : _b.visible)) {\n                            this.drawOutSideAxis();\n                        }\n                        break;\n                    case 'standardGauge':\n                    default:\n                        this.drawGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_c = this.gauge.axis.tickLine) === null || _c === void 0 ? void 0 : _c.visible)) {\n                            this.drawAxis();\n                        }\n                        break;\n                }\n                if (this.gauge.pivot.visible) {\n                    this.drawPivot(cfg, group);\n                }\n            },\n            drawGauge: function (currentAngle) {\n                var range = this.gauge.options.range;\n                this.drawBottomRing();\n                if (range && range.length) {\n                    this.drawRangeColor();\n                }\n                else {\n                    this.drawCurrentRing(currentAngle);\n                }\n            },\n            drawRangeColor: function () {\n                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, color = _a.color, rangeStyle = _a.rangeStyle;\n                var colors = color || getGlobalTheme().colors;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                for (var i = 0; i < range.length; i++) {\n                    var start = this.valueToAngle(range[i], config);\n                    var end = this.valueToAngle(range[i + 1], config);\n                    if (end >= start) {\n                        var path2 = this.getPath(start, end);\n                        var style = deepMix({ fill: colors[i] }, rangeStyle);\n                        this.drawRing(path2, style);\n                    }\n                }\n            },\n            drawBottomRing: function () {\n                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;\n                var backgroundStyle = this.gauge.options.rangeBackgroundStyle;\n                var path = this.getPath(starAngle, endAngle);\n                this.drawRing(path, backgroundStyle);\n            },\n            drawCurrentRing: function (current) {\n                var starAngle = this.getAngleRange().starAngle;\n                var rangeStyle = this.gauge.rangeStyle;\n                var path3 = this.getPath(starAngle, current);\n                this.drawRing(path3, rangeStyle);\n            },\n            drawInSideAxis: function () {\n                var _a = this.gauge.options, min = _a.min, max = _a.max, axis = _a.axis;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / axis.tickCount;\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue + interval / 2, config);\n                    this.drawRect(angle, {\n                        length: axis.tickLine.length,\n                        style: axis.tickLine.style,\n                    });\n                }\n            },\n            drawAxis: function () {\n                var axis = this.gauge.axis;\n                var _a = this.gauge.options, min = _a.min, max = _a.max;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / (axis.tickCount - 1);\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue, config);\n                    var tickLineStyle = clone(axis.tickLine.style);\n                    if (i % 5 !== 0) {\n                        tickLineStyle.lineWidth = tickLineStyle.lineWidth / 2;\n                    }\n                    this.drawRect(angle, {\n                        length: i % 5 === 0 ? axis.tickLine.length : axis.tickLine.length / 2,\n                        style: tickLineStyle,\n                    });\n                }\n            },\n            drawOutSideAxis: function () {\n                var axis = this.gauge.axis;\n                var _a = this.gauge.options, min = _a.min, max = _a.max;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / (axis.tickCount - 1);\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue, config);\n                    this.drawRect(angle, {\n                        length: axis.tickLine.length,\n                        style: axis.tickLine.style,\n                    });\n                }\n            },\n            drawBarGauge: function (current) {\n                var _this = this;\n                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, color = _a.color, rangeStyle = _a.rangeStyle, rangeBackgroundStyle = _a.rangeBackgroundStyle;\n                var colors = color || getGlobalTheme().colors;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (endAngle - starAngle) / (50 - 1);\n                var offset = interval / 3;\n                for (var i = 0; i < 50; i++) {\n                    var start = starAngle + i * interval;\n                    var path2 = this.getPath(start - offset / 2, start + offset - offset / 2);\n                    var style = rangeBackgroundStyle;\n                    if (range && range.length) {\n                        var result1 = range.map(function (item) {\n                            return _this.valueToAngle(item, config);\n                        });\n                        var index = sortedLastIndex(result1, start);\n                        var colorIndex = Math.min(index, range.length - 1);\n                        style = deepMix({}, { fill: colors[colorIndex - 1] }, rangeStyle) || rangeBackgroundStyle;\n                    }\n                    else {\n                        style = current >= start ? deepMix({}, { fill: color }, rangeStyle) : rangeBackgroundStyle;\n                    }\n                    this.drawRing(path2, style);\n                }\n            },\n            getAngleRange: function () {\n                var angle = this.gauge.options.angle;\n                var angleValue = 90 - (360 - angle) * 0.5;\n                var starAngle = ((270 - 90 - angleValue) * Math.PI) / 180;\n                var endAngle = ((270 + 90 + angleValue) * Math.PI) / 180;\n                return { starAngle: starAngle, endAngle: endAngle };\n            },\n            valueToAngle: function (value, config) {\n                var min = config.min, max = config.max, starAngle = config.starAngle, endAngle = config.endAngle;\n                if (value === max) {\n                    return endAngle;\n                }\n                if (value === min) {\n                    return starAngle;\n                }\n                var ratio = (value - min) / (max - min);\n                if (max === min) {\n                    ratio = 1;\n                }\n                var angle = ratio * (endAngle - starAngle) + starAngle;\n                angle = Math.max(angle, starAngle);\n                angle = Math.min(angle, endAngle);\n                return angle;\n            },\n            drawRing: function (path, style) {\n                this.gauge.group.addShape('path', {\n                    attrs: deepMix({}, {\n                        path: path,\n                    }, style),\n                });\n            },\n            drawRect: function (angle, param) {\n                var axis = this.gauge.axis;\n                var config = __assign(__assign({}, axis), param);\n                var offset = config.offset, length = config.length;\n                var center = this.gauge.center;\n                var radius;\n                if (offset < 0) {\n                    radius = this.gauge.ringRadius - this.gauge.options.rangeSize + offset;\n                }\n                else {\n                    radius = this.gauge.ringRadius + offset;\n                }\n                var xA1 = radius * Math.cos(angle) + center.x;\n                var yA1 = radius * Math.sin(angle) + center.y;\n                var xB1 = (radius + length) * Math.cos(angle) + center.x;\n                var yB1 = (radius + length) * Math.sin(angle) + center.y;\n                var line = this.gauge.group.addShape('line', {\n                    attrs: deepMix({}, {\n                        x1: xA1,\n                        y1: yA1,\n                        x2: xB1,\n                        y2: yB1,\n                    }, param.style),\n                });\n                line.set('name', 'axis-tickLine');\n            },\n            getPath: function (starAngle, endAngle) {\n                var center = this.gauge.center;\n                var length = this.gauge.ringRadius;\n                var thick = this.gauge.options.rangeSize;\n                var xA1 = length * Math.cos(starAngle) + center.x;\n                var yA1 = length * Math.sin(starAngle) + center.y;\n                var xA2 = (length - thick) * Math.cos(starAngle) + center.x;\n                var yA2 = (length - thick) * Math.sin(starAngle) + center.y;\n                var xB1 = length * Math.cos(endAngle) + center.x;\n                var yB1 = length * Math.sin(endAngle) + center.y;\n                var xB2 = (length - thick) * Math.cos(endAngle) + center.x;\n                var yB2 = (length - thick) * Math.sin(endAngle) + center.y;\n                var largeArcFlag = Math.abs(starAngle - endAngle) > Math.PI ? 1 : 0;\n                return [\n                    ['M', xA1, yA1],\n                    ['A', length, length, 0, largeArcFlag, 1, xB1, yB1],\n                    ['L', xB2, yB2],\n                    ['A', length - thick, length - thick, 0, largeArcFlag, 0, xA2, yA2],\n                    ['Z'],\n                ];\n            },\n            drawPivot: function (cfg) {\n                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;\n                var _b = this.gauge.options, radius = _b.radius, rangeSize = _b.rangeSize;\n                var pivotConfig = this.gauge.pivot;\n                var bigCircle = pivotConfig.thickness;\n                var smCircle = pivotConfig.thickness / 2.5;\n                var group = this.gauge.group;\n                var point = cfg.points[0];\n                var center = this.parsePoint({\n                    x: 0,\n                    y: 0,\n                });\n                var current = point.x * (endAngle - starAngle) + starAngle;\n                var x = (this.gauge.ringRadius - rangeSize) * radius * Math.cos(current) + this.gauge.center.x;\n                var y = (this.gauge.ringRadius - rangeSize) * radius * Math.sin(current) + this.gauge.center.y;\n                var target = {\n                    x: x,\n                    y: y,\n                };\n                if (pivotConfig.base.visible) {\n                    group.addShape('circle', {\n                        attrs: deepMix({}, {\n                            x: center.x,\n                            y: center.y,\n                            r: pivotConfig.base.size ? pivotConfig.base.size / 2 : bigCircle * 2.2,\n                        }, pivotConfig.base.style),\n                    });\n                }\n                if (pivotConfig.pointer.visible) {\n                    var dirVec = { x: center.x - target.x, y: center.y - target.y };\n                    var length_1 = Math.sqrt(dirVec.x * dirVec.x + dirVec.y * dirVec.y);\n                    dirVec.x *= 1 / length_1;\n                    dirVec.y *= 1 / length_1;\n                    var angle1 = -Math.PI / 2;\n                    var x1 = Math.cos(angle1) * dirVec.x - Math.sin(angle1) * dirVec.y;\n                    var y1 = Math.sin(angle1) * dirVec.x + Math.cos(angle1) * dirVec.y;\n                    var angle2 = Math.PI / 2;\n                    var x2 = Math.cos(angle2) * dirVec.x - Math.sin(angle2) * dirVec.y;\n                    var y2 = Math.sin(angle2) * dirVec.x + Math.cos(angle2) * dirVec.y;\n                    var path = [\n                        ['M', target.x + x1 * smCircle, target.y + y1 * smCircle],\n                        ['L', center.x + x1 * bigCircle, center.y + y1 * bigCircle],\n                        ['L', center.x + x2 * bigCircle, center.y + y2 * bigCircle],\n                        ['L', target.x + x2 * smCircle, target.y + y2 * smCircle],\n                        ['Z'],\n                    ];\n                    group.addShape('path', {\n                        attrs: deepMix({}, {\n                            path: path,\n                        }, pivotConfig.pointer.style),\n                    });\n                    group.addShape('circle', {\n                        attrs: {\n                            x: target.x,\n                            y: target.y,\n                            r: smCircle,\n                            fill: pivotConfig.pointer.style.fill,\n                        },\n                    });\n                    group.addShape('circle', {\n                        attrs: {\n                            x: center.x,\n                            y: center.y,\n                            r: bigCircle,\n                            fill: pivotConfig.pointer.style.fill,\n                        },\n                    });\n                }\n                if (pivotConfig.pin.visible) {\n                    group.addShape('circle', {\n                        attrs: deepMix({}, {\n                            x: center.x,\n                            y: center.y,\n                            r: smCircle / 1.2,\n                        }, pivotConfig.pin.style),\n                    });\n                }\n            },\n        });\n    };\n    return GaugeShape;\n}());\nexport { GaugeShape };\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/gauge/geometry/shape/gauge-shape.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/gauge/geometry/shape/gauge-shape.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\n/**\n * @author linhuiw\n * @description 仪表盘形状\n */\nimport { clone, deepMix } from '@antv/util';\nimport { registerShape } from '@antv/g2';\nimport { getGlobalTheme } from '../../../../theme';\nimport { sortedLastIndex } from '../../../../util/common';\n/**\n * 仪表盘指针图形\n * 指针主体由梯形和一大一小圆形组成，\n * 中心处由灰色圆底和小白圆加以装饰\n */\nvar GaugeShape = /** @class */ (function () {\n    function GaugeShape(uid) {\n        this.uid = uid;\n    }\n    GaugeShape.prototype.setOption = function (type, options) {\n        this.type = type;\n        this.options = options;\n        this.axis = options.axis;\n        this.pivot = options.pivot;\n    };\n    GaugeShape.prototype.render = function () {\n        var Gauge = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        registerShape('point', 'gauge', {\n            draw: function (cfg, group) {\n                var _a, _b, _c;\n                this.gauge = {};\n                this.gauge.options = Gauge.options;\n                this.gauge.axis = Gauge.axis;\n                this.gauge.pivot = Gauge.pivot;\n                this.gauge.type = Gauge.type;\n                var gauge = this.gauge;\n                var type = this.gauge.type;\n                var point = cfg.points[0];\n                var center = this.parsePoint({\n                    x: 0,\n                    y: 0,\n                });\n                var target = this.parsePoint({\n                    x: point.x || 0,\n                    y: 1,\n                });\n                gauge.center = center;\n                gauge.group = group;\n                var r = { x: center.x - target.x, y: center.y - target.y };\n                this.gauge.ringRadius = Math.sqrt(r.x * r.x + r.y * r.y);\n                var _d = this.getAngleRange(), starAngle = _d.starAngle, endAngle = _d.endAngle;\n                var currentAngle = point.x * (endAngle - starAngle) + starAngle;\n                switch (type) {\n                    case 'meterGauge':\n                        this.drawBarGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_a = this.gauge.axis.tickLine) === null || _a === void 0 ? void 0 : _a.visible)) {\n                            this.drawInSideAxis();\n                        }\n                        break;\n                    case 'fanGauge':\n                        this.drawGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_b = this.gauge.axis.tickLine) === null || _b === void 0 ? void 0 : _b.visible)) {\n                            this.drawOutSideAxis();\n                        }\n                        break;\n                    case 'standardGauge':\n                    default:\n                        this.drawGauge(currentAngle);\n                        if (this.gauge.axis.visible && ((_c = this.gauge.axis.tickLine) === null || _c === void 0 ? void 0 : _c.visible)) {\n                            this.drawAxis();\n                        }\n                        break;\n                }\n                // 绘制指针\n                if (this.gauge.pivot.visible) {\n                    this.drawPivot(cfg, group);\n                }\n            },\n            drawGauge: function (currentAngle) {\n                var range = this.gauge.options.range;\n                this.drawBottomRing(); // 绘制灰底色\n                if (range && range.length) {\n                    this.drawRangeColor();\n                }\n                else {\n                    this.drawCurrentRing(currentAngle);\n                }\n            },\n            drawRangeColor: function () {\n                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, color = _a.color, rangeStyle = _a.rangeStyle;\n                var colors = color || getGlobalTheme().colors;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                for (var i = 0; i < range.length; i++) {\n                    var start = this.valueToAngle(range[i], config);\n                    var end = this.valueToAngle(range[i + 1], config);\n                    if (end >= start) {\n                        var path2 = this.getPath(start, end);\n                        var style = deepMix({ fill: colors[i] }, rangeStyle);\n                        this.drawRing(path2, style);\n                    }\n                }\n            },\n            drawBottomRing: function () {\n                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;\n                var backgroundStyle = this.gauge.options.rangeBackgroundStyle;\n                var path = this.getPath(starAngle, endAngle);\n                this.drawRing(path, backgroundStyle);\n            },\n            drawCurrentRing: function (current) {\n                var starAngle = this.getAngleRange().starAngle;\n                var rangeStyle = this.gauge.rangeStyle;\n                var path3 = this.getPath(starAngle, current);\n                this.drawRing(path3, rangeStyle);\n            },\n            drawInSideAxis: function () {\n                var _a = this.gauge.options, min = _a.min, max = _a.max, axis = _a.axis;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / axis.tickCount;\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue + interval / 2, config);\n                    this.drawRect(angle, {\n                        length: axis.tickLine.length,\n                        style: axis.tickLine.style,\n                    });\n                }\n            },\n            drawAxis: function () {\n                var axis = this.gauge.axis;\n                var _a = this.gauge.options, min = _a.min, max = _a.max;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / (axis.tickCount - 1);\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue, config);\n                    var tickLineStyle = clone(axis.tickLine.style);\n                    if (i % 5 !== 0) {\n                        tickLineStyle.lineWidth = tickLineStyle.lineWidth / 2;\n                    }\n                    this.drawRect(angle, {\n                        length: i % 5 === 0 ? axis.tickLine.length : axis.tickLine.length / 2,\n                        style: tickLineStyle,\n                    });\n                }\n            },\n            drawOutSideAxis: function () {\n                var axis = this.gauge.axis;\n                var _a = this.gauge.options, min = _a.min, max = _a.max;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (max - min) / (axis.tickCount - 1);\n                for (var i = 0; i < axis.tickCount; i++) {\n                    var startValue = min + i * interval;\n                    var angle = this.valueToAngle(startValue, config);\n                    this.drawRect(angle, {\n                        length: axis.tickLine.length,\n                        style: axis.tickLine.style,\n                    });\n                }\n            },\n            drawBarGauge: function (current) {\n                var _this = this;\n                var _a = this.gauge.options, min = _a.min, max = _a.max, range = _a.range, color = _a.color, rangeStyle = _a.rangeStyle, rangeBackgroundStyle = _a.rangeBackgroundStyle;\n                var colors = color || getGlobalTheme().colors;\n                var _b = this.getAngleRange(), starAngle = _b.starAngle, endAngle = _b.endAngle;\n                var config = {\n                    min: min,\n                    max: max,\n                    starAngle: starAngle,\n                    endAngle: endAngle,\n                };\n                var interval = (endAngle - starAngle) / (50 - 1);\n                var offset = interval / 3;\n                // 由50个柱子组成\n                for (var i = 0; i < 50; i++) {\n                    var start = starAngle + i * interval;\n                    var path2 = this.getPath(start - offset / 2, start + offset - offset / 2);\n                    var style = rangeBackgroundStyle;\n                    if (range && range.length) {\n                        var result1 = range.map(function (item) {\n                            return _this.valueToAngle(item, config);\n                        });\n                        var index = sortedLastIndex(result1, start);\n                        /** 最后一个值也在最后一个区间内 */\n                        var colorIndex = Math.min(index, range.length - 1);\n                        style = deepMix({}, { fill: colors[colorIndex - 1] }, rangeStyle) || rangeBackgroundStyle;\n                    }\n                    else {\n                        style = current >= start ? deepMix({}, { fill: color }, rangeStyle) : rangeBackgroundStyle;\n                    }\n                    this.drawRing(path2, style);\n                }\n            },\n            getAngleRange: function () {\n                var angle = this.gauge.options.angle;\n                var angleValue = 90 - (360 - angle) * 0.5;\n                var starAngle = ((270 - 90 - angleValue) * Math.PI) / 180;\n                var endAngle = ((270 + 90 + angleValue) * Math.PI) / 180;\n                return { starAngle: starAngle, endAngle: endAngle };\n            },\n            valueToAngle: function (value, config) {\n                var min = config.min, max = config.max, starAngle = config.starAngle, endAngle = config.endAngle;\n                if (value === max) {\n                    return endAngle;\n                }\n                if (value === min) {\n                    return starAngle;\n                }\n                var ratio = (value - min) / (max - min);\n                if (max === min) {\n                    ratio = 1;\n                }\n                var angle = ratio * (endAngle - starAngle) + starAngle;\n                angle = Math.max(angle, starAngle);\n                angle = Math.min(angle, endAngle);\n                return angle;\n            },\n            drawRing: function (path, style) {\n                this.gauge.group.addShape('path', {\n                    attrs: deepMix({}, {\n                        path: path,\n                    }, style),\n                });\n            },\n            drawRect: function (angle, param) {\n                var axis = this.gauge.axis;\n                var config = __assign(__assign({}, axis), param);\n                var offset = config.offset, length = config.length;\n                var center = this.gauge.center;\n                var radius;\n                if (offset < 0) {\n                    radius = this.gauge.ringRadius - this.gauge.options.rangeSize + offset;\n                }\n                else {\n                    radius = this.gauge.ringRadius + offset;\n                }\n                var xA1 = radius * Math.cos(angle) + center.x;\n                var yA1 = radius * Math.sin(angle) + center.y;\n                var xB1 = (radius + length) * Math.cos(angle) + center.x;\n                var yB1 = (radius + length) * Math.sin(angle) + center.y;\n                var line = this.gauge.group.addShape('line', {\n                    attrs: deepMix({}, {\n                        x1: xA1,\n                        y1: yA1,\n                        x2: xB1,\n                        y2: yB1,\n                    }, param.style),\n                });\n                line.set('name', 'axis-tickLine');\n            },\n            getPath: function (starAngle, endAngle) {\n                /* const type = this.gauge.type;\n                const height = get(gauge, 'options.height');\n                const width = get(gauge, 'options.width');*/\n                var center = this.gauge.center;\n                var length = this.gauge.ringRadius;\n                /*let thick;\n                 const { minThickness, minThickCanvsSize } = this.gauge.ringStyle;\n                const size = Math.min(width, height);\n                if (type === 'fan' && size < minThickCanvsSize) {\n                  thick = length - minThickness;\n                } else {*/\n                var thick = this.gauge.options.rangeSize;\n                //}\n                var xA1 = length * Math.cos(starAngle) + center.x;\n                var yA1 = length * Math.sin(starAngle) + center.y;\n                var xA2 = (length - thick) * Math.cos(starAngle) + center.x;\n                var yA2 = (length - thick) * Math.sin(starAngle) + center.y;\n                var xB1 = length * Math.cos(endAngle) + center.x;\n                var yB1 = length * Math.sin(endAngle) + center.y;\n                var xB2 = (length - thick) * Math.cos(endAngle) + center.x;\n                var yB2 = (length - thick) * Math.sin(endAngle) + center.y;\n                var largeArcFlag = Math.abs(starAngle - endAngle) > Math.PI ? 1 : 0;\n                return [\n                    ['M', xA1, yA1],\n                    ['A', length, length, 0, largeArcFlag, 1, xB1, yB1],\n                    ['L', xB2, yB2],\n                    ['A', length - thick, length - thick, 0, largeArcFlag, 0, xA2, yA2],\n                    ['Z'],\n                ];\n            },\n            drawPivot: function (cfg) {\n                var _a = this.getAngleRange(), starAngle = _a.starAngle, endAngle = _a.endAngle;\n                var _b = this.gauge.options, radius = _b.radius, rangeSize = _b.rangeSize;\n                var pivotConfig = this.gauge.pivot;\n                var bigCircle = pivotConfig.thickness;\n                var smCircle = pivotConfig.thickness / 2.5;\n                var group = this.gauge.group;\n                var point = cfg.points[0];\n                var center = this.parsePoint({\n                    x: 0,\n                    y: 0,\n                });\n                // radius\n                var current = point.x * (endAngle - starAngle) + starAngle;\n                var x = (this.gauge.ringRadius - rangeSize) * radius * Math.cos(current) + this.gauge.center.x;\n                var y = (this.gauge.ringRadius - rangeSize) * radius * Math.sin(current) + this.gauge.center.y;\n                var target = {\n                    x: x,\n                    y: y,\n                };\n                // 外底色灰圆\n                if (pivotConfig.base.visible) {\n                    group.addShape('circle', {\n                        attrs: deepMix({}, {\n                            x: center.x,\n                            y: center.y,\n                            r: pivotConfig.base.size ? pivotConfig.base.size / 2 : bigCircle * 2.2,\n                        }, pivotConfig.base.style),\n                    });\n                }\n                // 指针\n                if (pivotConfig.pointer.visible) {\n                    var dirVec = { x: center.x - target.x, y: center.y - target.y };\n                    var length_1 = Math.sqrt(dirVec.x * dirVec.x + dirVec.y * dirVec.y);\n                    dirVec.x *= 1 / length_1;\n                    dirVec.y *= 1 / length_1;\n                    var angle1 = -Math.PI / 2;\n                    var x1 = Math.cos(angle1) * dirVec.x - Math.sin(angle1) * dirVec.y;\n                    var y1 = Math.sin(angle1) * dirVec.x + Math.cos(angle1) * dirVec.y;\n                    var angle2 = Math.PI / 2;\n                    var x2 = Math.cos(angle2) * dirVec.x - Math.sin(angle2) * dirVec.y;\n                    var y2 = Math.sin(angle2) * dirVec.x + Math.cos(angle2) * dirVec.y;\n                    var path = [\n                        ['M', target.x + x1 * smCircle, target.y + y1 * smCircle],\n                        ['L', center.x + x1 * bigCircle, center.y + y1 * bigCircle],\n                        ['L', center.x + x2 * bigCircle, center.y + y2 * bigCircle],\n                        ['L', target.x + x2 * smCircle, target.y + y2 * smCircle],\n                        ['Z'],\n                    ];\n                    group.addShape('path', {\n                        attrs: deepMix({}, {\n                            path: path,\n                        }, pivotConfig.pointer.style),\n                    });\n                    group.addShape('circle', {\n                        attrs: {\n                            x: target.x,\n                            y: target.y,\n                            r: smCircle,\n                            fill: pivotConfig.pointer.style.fill,\n                        },\n                    });\n                    group.addShape('circle', {\n                        attrs: {\n                            x: center.x,\n                            y: center.y,\n                            r: bigCircle,\n                            fill: pivotConfig.pointer.style.fill,\n                        },\n                    });\n                }\n                if (pivotConfig.pin.visible) {\n                    // 内部白色小圆\n                    group.addShape('circle', {\n                        attrs: deepMix({}, {\n                            x: center.x,\n                            y: center.y,\n                            r: smCircle / 1.2,\n                        }, pivotConfig.pin.style),\n                    });\n                }\n            },\n        });\n    };\n    return GaugeShape;\n}());\nexport { GaugeShape };\n//# sourceMappingURL=gauge-shape.js.map"]}]}