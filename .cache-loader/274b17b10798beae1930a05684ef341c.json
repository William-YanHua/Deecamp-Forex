{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/component/esm/axis/line.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/component/esm/axis/line.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Line = (function (_super) {\n    __extends(Line, _super);\n    function Line() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Line.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'line', locationType: 'region',\n            start: null,\n            end: null });\n    };\n    Line.prototype.getLinePath = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var path = [];\n        path.push(['M', start.x, start.y]);\n        path.push(['L', end.x, end.y]);\n        return path;\n    };\n    Line.prototype.getInnerLayoutBBox = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n        var minX = Math.min(start.x, end.x, bbox.x);\n        var minY = Math.min(start.y, end.y, bbox.y);\n        var maxX = Math.max(start.x, end.x, bbox.maxX);\n        var maxY = Math.max(start.y, end.y, bbox.maxY);\n        return {\n            x: minX,\n            y: minY,\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    };\n    Line.prototype.isVertical = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.x, end.x);\n    };\n    Line.prototype.isHorizontal = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.y, end.y);\n    };\n    Line.prototype.getTickPoint = function (tickValue) {\n        var self = this;\n        var start = self.get('start');\n        var end = self.get('end');\n        var regionX = end.x - start.x;\n        var regionY = end.y - start.y;\n        return {\n            x: start.x + regionX * tickValue,\n            y: start.y + regionY * tickValue,\n        };\n    };\n    Line.prototype.getSideVector = function (offset) {\n        var axisVector = this.getAxisVector();\n        var normal = vec2.normalize([0, 0], axisVector);\n        var factor = this.get('verticalFactor');\n        var verticalVector = [normal[1], normal[0] * -1];\n        return vec2.scale([0, 0], verticalVector, offset * factor);\n    };\n    Line.prototype.getAxisVector = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return [end.x - start.x, end.y - start.y];\n    };\n    Line.prototype.processOverlap = function (labelGroup) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var isHorizontal = this.isHorizontal();\n        if (!isVertical && !isHorizontal) {\n            return;\n        }\n        var labelCfg = this.get('label');\n        var titleCfg = this.get('title');\n        var verticalLimitLength = this.get('verticalLimitLength');\n        var labelOffset = labelCfg.offset;\n        var limitLength = verticalLimitLength;\n        var titleHeight = 0;\n        var titleSpacing = 0;\n        if (titleCfg) {\n            titleHeight = titleCfg.style.fontSize;\n            titleSpacing = titleCfg.spacing;\n        }\n        if (limitLength) {\n            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n        }\n        var overlapOrder = this.get('overlapOrder');\n        each(overlapOrder, function (name) {\n            if (labelCfg[name]) {\n                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n            }\n        });\n        if (titleCfg) {\n            var bbox = labelGroup.getBBox();\n            var length_1 = isVertical ? bbox.width : bbox.height;\n            if (isNil(titleCfg.offset)) {\n                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n            }\n        }\n    };\n    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var hasAdjusted = false;\n        var util = OverlapUtil[name];\n        if (value === true) {\n            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n        }\n        else if (isFunction(value)) {\n            hasAdjusted = value(isVertical, labelGroup, limitLength);\n        }\n        else if (util[value]) {\n            hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n        }\n        if (name === 'autoRotate') {\n            if (hasAdjusted) {\n                var labels = labelGroup.getChildren();\n                var verticalFactor_1 = this.get('verticalFactor');\n                each(labels, function (label) {\n                    var textAlign = label.attr('textAlign');\n                    if (textAlign === 'center') {\n                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n                        label.attr('textAlign', newAlign);\n                    }\n                });\n            }\n        }\n        else if (name === 'autoHide') {\n            var children = labelGroup.getChildren().slice(0);\n            each(children, function (label) {\n                if (!label.get('visible')) {\n                    if (_this.get('isRegister')) {\n                        _this.unregisterElement(label);\n                    }\n                    label.remove();\n                }\n            });\n        }\n    };\n    return Line;\n}(AxisBase));\nexport default Line;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/component/esm/axis/line.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/component/esm/axis/line.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Line = /** @class */ (function (_super) {\n    __extends(Line, _super);\n    function Line() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Line.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'line', locationType: 'region', \n            /**\n             * 起始点, x, y\n             * @type {object}\n             */\n            start: null, \n            /**\n             * 结束点, x, y\n             * @type {object}\n             */\n            end: null });\n    };\n    // 获取坐标轴线的 path\n    Line.prototype.getLinePath = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var path = [];\n        path.push(['M', start.x, start.y]);\n        path.push(['L', end.x, end.y]);\n        return path;\n    };\n    // 重新计算 layout bbox，考虑到 line 不显示\n    Line.prototype.getInnerLayoutBBox = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n        var minX = Math.min(start.x, end.x, bbox.x);\n        var minY = Math.min(start.y, end.y, bbox.y);\n        var maxX = Math.max(start.x, end.x, bbox.maxX);\n        var maxY = Math.max(start.y, end.y, bbox.maxY);\n        return {\n            x: minX,\n            y: minY,\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    };\n    Line.prototype.isVertical = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.x, end.x);\n    };\n    Line.prototype.isHorizontal = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.y, end.y);\n    };\n    Line.prototype.getTickPoint = function (tickValue) {\n        var self = this;\n        var start = self.get('start');\n        var end = self.get('end');\n        var regionX = end.x - start.x;\n        var regionY = end.y - start.y;\n        return {\n            x: start.x + regionX * tickValue,\n            y: start.y + regionY * tickValue,\n        };\n    };\n    // 直线坐标轴下任一点的向量方向都相同\n    Line.prototype.getSideVector = function (offset) {\n        var axisVector = this.getAxisVector();\n        var normal = vec2.normalize([0, 0], axisVector);\n        var factor = this.get('verticalFactor');\n        var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n        return vec2.scale([0, 0], verticalVector, offset * factor);\n    };\n    // 获取坐标轴的向量\n    Line.prototype.getAxisVector = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return [end.x - start.x, end.y - start.y];\n    };\n    Line.prototype.processOverlap = function (labelGroup) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var isHorizontal = this.isHorizontal();\n        // 非垂直，或者非水平时不处理遮挡问题\n        if (!isVertical && !isHorizontal) {\n            return;\n        }\n        var labelCfg = this.get('label');\n        var titleCfg = this.get('title');\n        var verticalLimitLength = this.get('verticalLimitLength');\n        var labelOffset = labelCfg.offset;\n        var limitLength = verticalLimitLength;\n        var titleHeight = 0;\n        var titleSpacing = 0;\n        if (titleCfg) {\n            titleHeight = titleCfg.style.fontSize;\n            titleSpacing = titleCfg.spacing;\n        }\n        if (limitLength) {\n            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n        }\n        var overlapOrder = this.get('overlapOrder');\n        each(overlapOrder, function (name) {\n            if (labelCfg[name]) {\n                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n            }\n        });\n        if (titleCfg) {\n            // 调整 title 的 offset\n            var bbox = labelGroup.getBBox();\n            var length_1 = isVertical ? bbox.width : bbox.height;\n            if (isNil(titleCfg.offset)) {\n                // 如果用户没有设置 offset，则自动计算\n                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n            }\n        }\n    };\n    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var hasAdjusted = false;\n        var util = OverlapUtil[name];\n        if (value === true) {\n            // 默认使用固定角度的旋转方案\n            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n        }\n        else if (isFunction(value)) {\n            // 用户可以传入回调函数\n            hasAdjusted = value(isVertical, labelGroup, limitLength);\n        }\n        else if (util[value]) {\n            // 按照名称执行旋转函数\n            hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n        }\n        if (name === 'autoRotate') {\n            // 文本旋转后，文本的对齐方式可能就不合适了\n            if (hasAdjusted) {\n                var labels = labelGroup.getChildren();\n                var verticalFactor_1 = this.get('verticalFactor');\n                each(labels, function (label) {\n                    var textAlign = label.attr('textAlign');\n                    if (textAlign === 'center') {\n                        // 居中的文本需要调整旋转度\n                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n                        label.attr('textAlign', newAlign);\n                    }\n                });\n            }\n        }\n        else if (name === 'autoHide') {\n            var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n            each(children, function (label) {\n                if (!label.get('visible')) {\n                    if (_this.get('isRegister')) {\n                        // 已经注册过了，则删除\n                        _this.unregisterElement(label);\n                    }\n                    label.remove(); // 防止 label 数量太多，所以统一删除\n                }\n            });\n        }\n    };\n    return Line;\n}(AxisBase));\nexport default Line;\n//# sourceMappingURL=line.js.map"]}]}