{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\scale\\lib\\auto\\util.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\scale\\lib\\auto\\util.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var DECIMAL_LENGTH = 12;\r\nfunction getFactor(v) {\r\n    var factor = 1;\r\n    if (v === Infinity || v === -Infinity) {\r\n        throw new Error('Not support Infinity!');\r\n    }\r\n    if (v < 1) {\r\n        var count = 0;\r\n        while (v < 1) {\r\n            factor = factor / 10;\r\n            v = v * 10;\r\n            count++;\r\n        }\r\n        if (factor.toString().length > DECIMAL_LENGTH) {\r\n            factor = parseFloat(factor.toFixed(count));\r\n        }\r\n    }\r\n    else {\r\n        while (v > 10) {\r\n            factor = factor * 10;\r\n            v = v / 10;\r\n        }\r\n    }\r\n    return factor;\r\n}\r\nfunction arrayFloor(values, value) {\r\n    var length = values.length;\r\n    if (length === 0) {\r\n        return NaN;\r\n    }\r\n    var pre = values[0];\r\n    if (value < values[0]) {\r\n        return NaN;\r\n    }\r\n    if (value >= values[length - 1]) {\r\n        return values[length - 1];\r\n    }\r\n    for (var i = 1; i < values.length; i++) {\r\n        if (value < values[i]) {\r\n            break;\r\n        }\r\n        pre = values[i];\r\n    }\r\n    return pre;\r\n}\r\nfunction arrayCeiling(values, value) {\r\n    var length = values.length;\r\n    if (length === 0) {\r\n        return NaN;\r\n    }\r\n    var rst;\r\n    if (value > values[length - 1]) {\r\n        return NaN;\r\n    }\r\n    if (value < values[0]) {\r\n        return values[0];\r\n    }\r\n    for (var i = 1; i < values.length; i++) {\r\n        if (value <= values[i]) {\r\n            rst = values[i];\r\n            break;\r\n        }\r\n    }\r\n    return rst;\r\n}\r\nvar Util = {\r\n    snapFactorTo: function snapFactorTo(v, arr, snapType) {\r\n        if (isNaN(v)) {\r\n            return NaN;\r\n        }\r\n        var factor = 1;\r\n        if (v !== 0) {\r\n            if (v < 0) {\r\n                factor = -1;\r\n            }\r\n            v = v * factor;\r\n            var tmpFactor = getFactor(v);\r\n            factor = factor * tmpFactor;\r\n            v = v / tmpFactor;\r\n        }\r\n        if (snapType === 'floor') {\r\n            v = Util.snapFloor(arr, v);\r\n        }\r\n        else if (snapType === 'ceil') {\r\n            v = Util.snapCeiling(arr, v);\r\n        }\r\n        else {\r\n            v = Util.snapTo(arr, v);\r\n        }\r\n        var rst = v * factor;\r\n        if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\r\n            var decimalVal = parseInt(1 / factor);\r\n            var symbol = factor > 0 ? 1 : -1;\r\n            rst = v / decimalVal * symbol;\r\n        }\r\n        return rst;\r\n    },\r\n    snapMultiple: function snapMultiple(v, base, snapType) {\r\n        var div;\r\n        if (snapType === 'ceil') {\r\n            div = Math.ceil(v / base);\r\n        }\r\n        else if (snapType === 'floor') {\r\n            div = Math.floor(v / base);\r\n        }\r\n        else {\r\n            div = Math.round(v / base);\r\n        }\r\n        return div * base;\r\n    },\r\n    snapTo: function snapTo(values, value) {\r\n        var floorVal = arrayFloor(values, value);\r\n        var ceilingVal = arrayCeiling(values, value);\r\n        if (isNaN(floorVal) || isNaN(ceilingVal)) {\r\n            if (values[0] >= value) {\r\n                return values[0];\r\n            }\r\n            var last = values[values.length - 1];\r\n            if (last <= value) {\r\n                return last;\r\n            }\r\n        }\r\n        if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\r\n            return floorVal;\r\n        }\r\n        return ceilingVal;\r\n    },\r\n    snapFloor: function snapFloor(values, value) {\r\n        return arrayFloor(values, value);\r\n    },\r\n    snapCeiling: function snapCeiling(values, value) {\r\n        return arrayCeiling(values, value);\r\n    },\r\n    fixedBase: function fixedBase(v, base) {\r\n        var str = base.toString();\r\n        var index = str.indexOf('.');\r\n        if (index === -1) {\r\n            return Math.round(v);\r\n        }\r\n        var length = str.substr(index + 1).length;\r\n        if (length > 20) {\r\n            length = 20;\r\n        }\r\n        return parseFloat(v.toFixed(length));\r\n    }\r\n};\r\nmodule.exports = Util;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\scale\\lib\\auto\\util.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\scale\\lib\\auto\\util.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = v * factor; // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n\n    if (index === -1) {\n      return Math.round(v);\n    }\n\n    var length = str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;"]}]}