{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\impute.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\impute.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var assign = require('@antv/util/lib/mix');\r\nvar forIn = require('@antv/util/lib/each');\r\nvar has = require('@antv/util/lib/object/has');\r\nvar isFunction = require('@antv/util/lib/type/is-function');\r\nvar isUndefined = require('@antv/util/lib/type/is-undefined');\r\nvar isString = require('@antv/util/lib/type/is-string');\r\nvar simpleStatistics = require('simple-statistics');\r\nvar partition = require('../util/partition');\r\nvar registerTransform = require('../data-set').registerTransform;\r\nvar getField = require('../util/option-parser').getField;\r\nvar DEFAULT_OPTIONS = {\r\n    groupBy: []\r\n};\r\nfunction notUndefinedValues(values) {\r\n    return values.filter(function (value) { return !isUndefined(value); });\r\n}\r\nvar STATISTICS_METHODS = [\r\n    'mean',\r\n    'median',\r\n    'max',\r\n    'min'\r\n];\r\nvar imputations = {};\r\nSTATISTICS_METHODS.forEach(function (method) {\r\n    imputations[method] = function (row, values) { return simpleStatistics[method](values); };\r\n});\r\nimputations.value = function (row, values, value) { return value; };\r\nfunction transform(dataView, options) {\r\n    if (options === void 0) { options = {}; }\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var field = getField(options);\r\n    var method = options.method;\r\n    if (!method) {\r\n        throw new TypeError('Invalid method!');\r\n    }\r\n    if ((method === 'value' && !has(options, 'value'))) {\r\n        throw new TypeError('Invalid value: it is nil.');\r\n    }\r\n    var column = notUndefinedValues(dataView.getColumn(field));\r\n    var groups = partition(dataView.rows, options.groupBy);\r\n    forIn(groups, function (group) {\r\n        var fieldValues = notUndefinedValues(group.map(function (row) { return row[field]; }));\r\n        if (fieldValues.length === 0) {\r\n            fieldValues = column;\r\n        }\r\n        group.forEach(function (row) {\r\n            if (isUndefined(row[field])) {\r\n                if (isFunction(method)) {\r\n                    row[field] = method(row, fieldValues, options.value, group);\r\n                }\r\n                else if (isString(method)) {\r\n                    row[field] = imputations[method](row, fieldValues, options.value);\r\n                }\r\n                else {\r\n                    throw new TypeError(\"Invalid method: must be a function or one of \" + STATISTICS_METHODS.join(', '));\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\nregisterTransform('impute', transform);\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\impute.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\impute.js"],"names":[],"mappings":"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","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst has = require('@antv/util/lib/object/has');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isUndefined = require('@antv/util/lib/type/is-undefined');\nconst isString = require('@antv/util/lib/type/is-string');\nconst simpleStatistics = require('simple-statistics');\nconst partition = require('../util/partition');\nconst {\n  registerTransform\n} = require('../data-set');\nconst {\n  getField\n} = require('../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  // field: '', // required\n  // method: 'value', // required\n  // value: 10, // required if (method === 'value')\n  groupBy: []\n};\n\nfunction notUndefinedValues(values) {\n  return values.filter(value => !isUndefined(value));\n}\n\nconst STATISTICS_METHODS = [\n  'mean',\n  'median',\n  'max',\n  'min'\n];\nconst imputations = {};\nSTATISTICS_METHODS.forEach(method => {\n  imputations[method] = (row, values) => simpleStatistics[method](values);\n});\nimputations.value = (row, values, value) => value;\n\nfunction transform(dataView, options = {}) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const field = getField(options);\n  const method = options.method;\n  if (!method) {\n    throw new TypeError('Invalid method!');\n  }\n  if ((method === 'value' && !has(options, 'value'))) {\n    throw new TypeError('Invalid value: it is nil.');\n  }\n  const column = notUndefinedValues(dataView.getColumn(field));\n  const groups = partition(dataView.rows, options.groupBy);\n  forIn(groups, group => {\n    let fieldValues = notUndefinedValues(group.map(row => row[field]));\n    if (fieldValues.length === 0) {\n      fieldValues = column;\n    }\n    group.forEach(row => {\n      if (isUndefined(row[field])) {\n        if (isFunction(method)) {\n          row[field] = method(row, fieldValues, options.value, group);\n        } else if (isString(method)) {\n          row[field] = imputations[method](row, fieldValues, options.value);\n        } else {\n          throw new TypeError(`Invalid method: must be a function or one of ${STATISTICS_METHODS.join(', ')}`);\n        }\n      }\n    });\n  });\n}\n\nregisterTransform('impute', transform);\n"]}]}