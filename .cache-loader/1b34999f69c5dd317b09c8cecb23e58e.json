{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\util.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\util.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nvar _ = require(\"./lodash\"), Graph = require(\"./graphlib\").Graph;\r\nmodule.exports = {\r\n    addDummyNode: addDummyNode,\r\n    simplify: simplify,\r\n    asNonCompoundGraph: asNonCompoundGraph,\r\n    successorWeights: successorWeights,\r\n    predecessorWeights: predecessorWeights,\r\n    intersectRect: intersectRect,\r\n    buildLayerMatrix: buildLayerMatrix,\r\n    normalizeRanks: normalizeRanks,\r\n    removeEmptyRanks: removeEmptyRanks,\r\n    addBorderNode: addBorderNode,\r\n    maxRank: maxRank,\r\n    partition: partition,\r\n    time: time,\r\n    notime: notime\r\n};\r\nfunction addDummyNode(g, type, attrs, name) {\r\n    var v;\r\n    do {\r\n        v = _.uniqueId(name);\r\n    } while (g.hasNode(v));\r\n    attrs.dummy = type;\r\n    g.setNode(v, attrs);\r\n    return v;\r\n}\r\nfunction simplify(g) {\r\n    var simplified = new Graph().setGraph(g.graph());\r\n    _.forEach(g.nodes(), function (v) { simplified.setNode(v, g.node(v)); });\r\n    _.forEach(g.edges(), function (e) {\r\n        var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 }, label = g.edge(e);\r\n        simplified.setEdge(e.v, e.w, {\r\n            weight: simpleLabel.weight + label.weight,\r\n            minlen: Math.max(simpleLabel.minlen, label.minlen)\r\n        });\r\n    });\r\n    return simplified;\r\n}\r\nfunction asNonCompoundGraph(g) {\r\n    var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\r\n    _.forEach(g.nodes(), function (v) {\r\n        if (!g.children(v).length) {\r\n            simplified.setNode(v, g.node(v));\r\n        }\r\n    });\r\n    _.forEach(g.edges(), function (e) {\r\n        simplified.setEdge(e, g.edge(e));\r\n    });\r\n    return simplified;\r\n}\r\nfunction successorWeights(g) {\r\n    var weightMap = _.map(g.nodes(), function (v) {\r\n        var sucs = {};\r\n        _.forEach(g.outEdges(v), function (e) {\r\n            sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\r\n        });\r\n        return sucs;\r\n    });\r\n    return _.zipObject(g.nodes(), weightMap);\r\n}\r\nfunction predecessorWeights(g) {\r\n    var weightMap = _.map(g.nodes(), function (v) {\r\n        var preds = {};\r\n        _.forEach(g.inEdges(v), function (e) {\r\n            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\r\n        });\r\n        return preds;\r\n    });\r\n    return _.zipObject(g.nodes(), weightMap);\r\n}\r\nfunction intersectRect(rect, point) {\r\n    var x = rect.x;\r\n    var y = rect.y;\r\n    var dx = point.x - x;\r\n    var dy = point.y - y;\r\n    var w = rect.width / 2;\r\n    var h = rect.height / 2;\r\n    if (!dx && !dy) {\r\n        throw new Error(\"Not possible to find intersection inside of the rectangle\");\r\n    }\r\n    var sx, sy;\r\n    if (Math.abs(dy) * w > Math.abs(dx) * h) {\r\n        if (dy < 0) {\r\n            h = -h;\r\n        }\r\n        sx = h * dx / dy;\r\n        sy = h;\r\n    }\r\n    else {\r\n        if (dx < 0) {\r\n            w = -w;\r\n        }\r\n        sx = w;\r\n        sy = w * dy / dx;\r\n    }\r\n    return { x: x + sx, y: y + sy };\r\n}\r\nfunction buildLayerMatrix(g) {\r\n    var layering = _.map(_.range(maxRank(g) + 1), function () { return []; });\r\n    _.forEach(g.nodes(), function (v) {\r\n        var node = g.node(v), rank = node.rank;\r\n        if (!_.isUndefined(rank)) {\r\n            layering[rank][node.order] = v;\r\n        }\r\n    });\r\n    return layering;\r\n}\r\nfunction normalizeRanks(g) {\r\n    var min = _.minBy(_.map(g.nodes(), function (v) { return g.node(v).rank; }));\r\n    _.forEach(g.nodes(), function (v) {\r\n        var node = g.node(v);\r\n        if (_.has(node, \"rank\")) {\r\n            node.rank -= min;\r\n        }\r\n    });\r\n}\r\nfunction removeEmptyRanks(g) {\r\n    var offset = _.minBy(_.map(g.nodes(), function (v) { return g.node(v).rank; }));\r\n    var layers = [];\r\n    _.forEach(g.nodes(), function (v) {\r\n        var rank = g.node(v).rank - offset;\r\n        if (!layers[rank]) {\r\n            layers[rank] = [];\r\n        }\r\n        layers[rank].push(v);\r\n    });\r\n    var delta = 0, nodeRankFactor = g.graph().nodeRankFactor;\r\n    _.forEach(layers, function (vs, i) {\r\n        if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\r\n            --delta;\r\n        }\r\n        else if (delta) {\r\n            _.forEach(vs, function (v) { g.node(v).rank += delta; });\r\n        }\r\n    });\r\n}\r\nfunction addBorderNode(g, prefix, rank, order) {\r\n    var node = {\r\n        width: 0,\r\n        height: 0\r\n    };\r\n    if (arguments.length >= 4) {\r\n        node.rank = rank;\r\n        node.order = order;\r\n    }\r\n    return addDummyNode(g, \"border\", node, prefix);\r\n}\r\nfunction maxRank(g) {\r\n    return _.max(_.map(g.nodes(), function (v) {\r\n        var rank = g.node(v).rank;\r\n        if (!_.isUndefined(rank)) {\r\n            return rank;\r\n        }\r\n    }));\r\n}\r\nfunction partition(collection, fn) {\r\n    var result = { lhs: [], rhs: [] };\r\n    _.forEach(collection, function (value) {\r\n        if (fn(value)) {\r\n            result.lhs.push(value);\r\n        }\r\n        else {\r\n            result.rhs.push(value);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nfunction time(name, fn) {\r\n    var start = _.now();\r\n    try {\r\n        return fn();\r\n    }\r\n    finally {\r\n        console.log(name + \" time: \" + (_.now() - start) + \"ms\");\r\n    }\r\n}\r\nfunction notime(name, fn) {\r\n    return fn();\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\util.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\util.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAEb,IAAI,CAAC,GAAG,OAAO,CAAC,UAAU,CAAC,EACvB,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC;AAExC,MAAM,CAAC,OAAO,GAAG;IACf,YAAY,EAAE,YAAY;IAC1B,QAAQ,EAAE,QAAQ;IAClB,kBAAkB,EAAE,kBAAkB;IACtC,gBAAgB,EAAE,gBAAgB;IAClC,kBAAkB,EAAE,kBAAkB;IACtC,aAAa,EAAE,aAAa;IAC5B,gBAAgB,EAAE,gBAAgB;IAClC,cAAc,EAAE,cAAc;IAC9B,gBAAgB,EAAE,gBAAgB;IAClC,aAAa,EAAE,aAAa;IAC5B,OAAO,EAAE,OAAO;IAChB,SAAS,EAAE,SAAS;IACpB,IAAI,EAAE,IAAI;IACV,MAAM,EAAE,MAAM;CACf,CAAC;AAKF,SAAS,YAAY,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI;IACxC,IAAI,CAAC,CAAC;IACN,GAAG;QACD,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KACtB,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;IAEvB,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC;IACnB,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACpB,OAAO,CAAC,CAAC;AACX,CAAC;AAMD,SAAS,QAAQ,CAAC,CAAC;IACjB,IAAI,UAAU,GAAG,IAAI,KAAK,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;IACjD,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EACnE,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACtB,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;YAC3B,MAAM,EAAE,WAAW,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;YACzC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC;SACnD,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,SAAS,kBAAkB,CAAC,CAAC;IAC3B,IAAI,UAAU,GAAG,IAAI,KAAK,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;IACjF,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;YACzB,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;SAClC;IACH,CAAC,CAAC,CAAC;IACH,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IACH,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,SAAS,gBAAgB,CAAC,CAAC;IACzB,IAAI,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QACzC,IAAI,IAAI,GAAG,EAAE,CAAC;QACd,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,UAAS,CAAC;YACjC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAClD,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,SAAS,CAAC,CAAC;AAC3C,CAAC;AAED,SAAS,kBAAkB,CAAC,CAAC;IAC3B,IAAI,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QACzC,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,UAAS,CAAC;YAChC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QACpD,CAAC,CAAC,CAAC;QACH,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IACH,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,SAAS,CAAC,CAAC;AAC3C,CAAC;AAMD,SAAS,aAAa,CAAC,IAAI,EAAE,KAAK;IAChC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACf,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IAIf,IAAI,EAAE,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;IACrB,IAAI,EAAE,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;IACrB,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IACvB,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;IAExB,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;KAC9E;IAED,IAAI,EAAE,EAAE,EAAE,CAAC;IACX,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE;QAEvC,IAAI,EAAE,GAAG,CAAC,EAAE;YACV,CAAC,GAAG,CAAC,CAAC,CAAC;SACR;QACD,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;QACjB,EAAE,GAAG,CAAC,CAAC;KACR;SAAM;QAEL,IAAI,EAAE,GAAG,CAAC,EAAE;YACV,CAAC,GAAG,CAAC,CAAC,CAAC;SACR;QACD,EAAE,GAAG,CAAC,CAAC;QACP,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;KAClB;IAED,OAAO,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC;AAClC,CAAC;AAMD,SAAS,gBAAgB,CAAC,CAAC;IACzB,IAAI,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,cAAa,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACzE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAChB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACrB,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;YACxB,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SAChC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,QAAQ,CAAC;AAClB,CAAC;AAMD,SAAS,cAAc,CAAC,CAAC;IACvB,IAAI,GAAG,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC,IAAI,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACrB,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE;YACvB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;SAClB;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,gBAAgB,CAAC,CAAC;IAEzB,IAAI,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC,IAAI,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAE/E,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,MAAM,CAAC;QACnC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;YACjB,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;SACnB;QACD,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACvB,CAAC,CAAC,CAAC;IAEH,IAAI,KAAK,GAAG,CAAC,EACT,cAAc,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,cAAc,CAAC;IAC9C,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,UAAS,EAAE,EAAE,CAAC;QAC9B,IAAI,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,cAAc,KAAK,CAAC,EAAE;YACjD,EAAE,KAAK,CAAC;SACT;aAAM,IAAI,KAAK,EAAE;YAChB,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,UAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SACzD;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,aAAa,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK;IAC3C,IAAI,IAAI,GAAG;QACT,KAAK,EAAE,CAAC;QACR,MAAM,EAAE,CAAC;KACV,CAAC;IACF,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,EAAE;QACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACpB;IACD,OAAO,YAAY,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACjD,CAAC;AAED,SAAS,OAAO,CAAC,CAAC;IAChB,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QACtC,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC;SACb;IACH,CAAC,CAAC,CAAC,CAAC;AACN,CAAC;AAOD,SAAS,SAAS,CAAC,UAAU,EAAE,EAAE;IAC/B,IAAI,MAAM,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;IAClC,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,UAAS,KAAK;QAClC,IAAI,EAAE,CAAC,KAAK,CAAC,EAAE;YACb,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB;aAAM;YACL,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB;IACH,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AAChB,CAAC;AAMD,SAAS,IAAI,CAAC,IAAI,EAAE,EAAE;IACpB,IAAI,KAAK,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;IACpB,IAAI;QACF,OAAO,EAAE,EAAE,CAAC;KACb;YAAS;QACR,OAAO,CAAC,GAAG,CAAC,IAAI,GAAG,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;KAC1D;AACH,CAAC;AAED,SAAS,MAAM,CAAC,IAAI,EAAE,EAAE;IACtB,OAAO,EAAE,EAAE,CAAC;AACd,CAAC","sourcesContent":["\"use strict\";\n\nvar _ = require(\"./lodash\"),\n    Graph = require(\"./graphlib\").Graph;\n\nmodule.exports = {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 },\n        label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function(e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function(e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function(e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v),\n        rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.minBy(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (_.has(node, \"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.minBy(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n\n  var layers = [];\n  _.forEach(g.nodes(), function(v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0,\n      nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function(vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function(v) { g.node(v).rank += delta; });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(_.map(g.nodes(), function(v) {\n    var rank = g.node(v).rank;\n    if (!_.isUndefined(rank)) {\n      return rank;\n    }\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function(value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (_.now() - start) + \"ms\");\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n"]}]}