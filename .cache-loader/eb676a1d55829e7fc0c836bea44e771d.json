{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\shape\\interval.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\shape\\interval.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var Util = require('../../util');\r\nvar Shape = require('./shape');\r\nvar PathUtil = require('../util/path');\r\nvar GPathUtil = Util.PathUtil;\r\nvar Global = require('../../global');\r\nvar G = require('../../renderer');\r\nfunction getRectPoints(cfg, isPyramid) {\r\n    var x = cfg.x;\r\n    var y = cfg.y;\r\n    var y0 = cfg.y0;\r\n    var width = cfg.size;\r\n    var ymin = y0;\r\n    var ymax = y;\r\n    if (Util.isArray(y)) {\r\n        ymax = y[1];\r\n        ymin = y[0];\r\n    }\r\n    var xmin;\r\n    var xmax;\r\n    if (Util.isArray(x)) {\r\n        xmin = x[0];\r\n        xmax = x[1];\r\n    }\r\n    else {\r\n        xmin = x - width / 2;\r\n        xmax = x + width / 2;\r\n    }\r\n    var points = [];\r\n    points.push({\r\n        x: xmin,\r\n        y: ymin\r\n    }, {\r\n        x: xmin,\r\n        y: ymax\r\n    });\r\n    if (isPyramid) {\r\n        points.push({\r\n            x: xmax,\r\n            y: (ymax + ymin) / 2\r\n        });\r\n    }\r\n    else {\r\n        points.push({\r\n            x: xmax,\r\n            y: ymax\r\n        }, {\r\n            x: xmax,\r\n            y: ymin\r\n        });\r\n    }\r\n    return points;\r\n}\r\nfunction getRectPath(points) {\r\n    var path = [];\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        if (point) {\r\n            var action = i === 0 ? 'M' : 'L';\r\n            path.push([action, point.x, point.y]);\r\n        }\r\n    }\r\n    var first = points[0];\r\n    path.push(['L', first.x, first.y]);\r\n    path.push(['z']);\r\n    return path;\r\n}\r\nfunction getLinePoints(cfg) {\r\n    var x = cfg.x;\r\n    var y = cfg.y;\r\n    var y0 = cfg.y0;\r\n    var points = [];\r\n    if (Util.isArray(y)) {\r\n        Util.each(y, function (yItem, idx) {\r\n            points.push({\r\n                x: Util.isArray(x) ? x[idx] : x,\r\n                y: yItem\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        points.push({\r\n            x: x,\r\n            y: y\r\n        }, {\r\n            x: x,\r\n            y: y0\r\n        });\r\n    }\r\n    return points;\r\n}\r\nfunction getTickPoints(cfg) {\r\n    var x = cfg.x;\r\n    var y = Util.isArray(cfg.y) ? cfg.y[1] : cfg.y;\r\n    var y0 = Util.isArray(cfg.y) ? cfg.y[0] : cfg.y0;\r\n    var barWidth = cfg.size;\r\n    var points = [];\r\n    points.push({\r\n        x: x - barWidth / 2,\r\n        y: y\r\n    }, {\r\n        x: x + barWidth / 2,\r\n        y: y\r\n    }, {\r\n        x: x,\r\n        y: y\r\n    }, {\r\n        x: x,\r\n        y: y0\r\n    }, {\r\n        x: x - barWidth / 2,\r\n        y: y0\r\n    }, {\r\n        x: x + barWidth / 2,\r\n        y: y0\r\n    });\r\n    return points;\r\n}\r\nfunction getTickPath(points) {\r\n    var path = [];\r\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]);\r\n    return path;\r\n}\r\nfunction getFillAttrs(cfg) {\r\n    var defaultAttrs = Global.shape.interval;\r\n    var attrs = Util.mix({}, defaultAttrs, {\r\n        fill: cfg.color,\r\n        stroke: cfg.color,\r\n        fillOpacity: cfg.opacity\r\n    }, cfg.style);\r\n    return attrs;\r\n}\r\nfunction getLineAttrs(cfg) {\r\n    var defaultAttrs = Global.shape.hollowInterval;\r\n    var attrs = Util.mix({}, defaultAttrs, {\r\n        stroke: cfg.color,\r\n        strokeOpacity: cfg.opacity\r\n    }, cfg.style);\r\n    return attrs;\r\n}\r\nfunction getFunnelPath(cfg, isFunnel) {\r\n    var path = [];\r\n    var points = cfg.points;\r\n    var nextPoints = cfg.nextPoints;\r\n    if (!Util.isNil(nextPoints)) {\r\n        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);\r\n    }\r\n    else if (isFunnel) {\r\n        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);\r\n    }\r\n    else {\r\n        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);\r\n    }\r\n    return path;\r\n}\r\nfunction getThetaCfg(point, coord) {\r\n    var r = coord.getRadius();\r\n    var inner = coord.innerRadius;\r\n    var startAngle;\r\n    var endAngle;\r\n    var ir = r * inner;\r\n    var startPoint;\r\n    var endPoint;\r\n    if (!Util.isArray(point.x) && Util.isArray(point.y)) {\r\n        point.x = [point.x, point.x];\r\n    }\r\n    if (Util.isArray(point.x)) {\r\n        startPoint = {\r\n            x: point.x[0],\r\n            y: point.y[0]\r\n        };\r\n        endPoint = {\r\n            x: point.x[1],\r\n            y: point.y[1]\r\n        };\r\n        startAngle = PathUtil.getPointAngle(coord, startPoint);\r\n        endAngle = PathUtil.getPointAngle(coord, endPoint);\r\n        if (endAngle <= startAngle) {\r\n            endAngle = endAngle + Math.PI * 2;\r\n        }\r\n    }\r\n    else {\r\n        endPoint = point;\r\n        startAngle = coord.startAngle;\r\n        endAngle = PathUtil.getPointAngle(coord, endPoint);\r\n    }\r\n    return {\r\n        r: r,\r\n        ir: ir,\r\n        startAngle: startAngle,\r\n        endAngle: endAngle\r\n    };\r\n}\r\nfunction _getSelectedCfg(type, cfg) {\r\n    var geom = cfg.geom;\r\n    var coord = geom.get('coord');\r\n    var point = cfg.point;\r\n    var r = 7.5;\r\n    var selectedCfg;\r\n    if (coord && coord.type === 'theta') {\r\n        var thetaCfg = getThetaCfg(point, coord);\r\n        var middleAngle = (thetaCfg.endAngle - thetaCfg.startAngle) / 2 + thetaCfg.startAngle;\r\n        var x = r * Math.cos(middleAngle);\r\n        var y = r * Math.sin(middleAngle);\r\n        selectedCfg = {\r\n            transform: [['t', x, y]]\r\n        };\r\n    }\r\n    return Util.mix({}, selectedCfg);\r\n}\r\nvar Interval = Shape.registerFactory('interval', {\r\n    defaultShapeType: 'rect',\r\n    getActiveCfg: function getActiveCfg(type, cfg) {\r\n        if (!type || Util.inArray(['rect', 'funnel', 'pyramid'], type)) {\r\n            var fillOpacity = cfg.fillOpacity || cfg.opacity || 1;\r\n            return {\r\n                fillOpacity: fillOpacity - 0.15\r\n            };\r\n        }\r\n        var lineWidth = cfg.lineWidth || 0;\r\n        return {\r\n            lineWidth: lineWidth + 1\r\n        };\r\n    },\r\n    getDefaultPoints: function getDefaultPoints(pointInfo) {\r\n        return getRectPoints(pointInfo);\r\n    },\r\n    getSelectedCfg: function getSelectedCfg(type, cfg) {\r\n        return _getSelectedCfg(type, cfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'rect', {\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getFillAttrs(cfg);\r\n        var path = getRectPath(cfg.points);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var rectCfg = getFillAttrs(cfg);\r\n        var isInCircle = cfg.isInCircle;\r\n        return Util.mix({\r\n            symbol: isInCircle ? 'circle' : 'square',\r\n            radius: isInCircle ? 4.5 : 4\r\n        }, rectCfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'hollowRect', {\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getLineAttrs(cfg);\r\n        var path = getRectPath(cfg.points);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var rectCfg = getLineAttrs(cfg);\r\n        var isInCircle = cfg.isInCircle;\r\n        return Util.mix({\r\n            symbol: isInCircle ? 'circle' : 'square',\r\n            radius: isInCircle ? 4.5 : 4\r\n        }, rectCfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'line', {\r\n    getPoints: function getPoints(pointInfo) {\r\n        return getLinePoints(pointInfo);\r\n    },\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getLineAttrs(cfg);\r\n        attrs.lineWidth = cfg.size || 1;\r\n        var path = getRectPath(cfg.points);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var lineCfg = getLineAttrs(cfg);\r\n        return Util.mix({\r\n            symbol: 'line',\r\n            radius: 5\r\n        }, lineCfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'tick', {\r\n    getPoints: function getPoints(pointInfo) {\r\n        return getTickPoints(pointInfo);\r\n    },\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getLineAttrs(cfg);\r\n        var path = getTickPath(cfg.points);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var lineCfg = getLineAttrs(cfg);\r\n        return Util.mix({\r\n            symbol: 'tick',\r\n            radius: 5\r\n        }, lineCfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'funnel', {\r\n    getPoints: function getPoints(pointInfo) {\r\n        pointInfo.size = pointInfo.size * 2;\r\n        return getRectPoints(pointInfo);\r\n    },\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getFillAttrs(cfg);\r\n        var path = getFunnelPath(cfg, true);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var funnelCfg = getFillAttrs(cfg);\r\n        return Util.mix({\r\n            symbol: 'square',\r\n            radius: 4\r\n        }, funnelCfg);\r\n    }\r\n});\r\nShape.registerShape('interval', 'pyramid', {\r\n    getPoints: function getPoints(pointInfo) {\r\n        pointInfo.size = pointInfo.size * 2;\r\n        return getRectPoints(pointInfo, true);\r\n    },\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getFillAttrs(cfg);\r\n        var path = getFunnelPath(cfg, false);\r\n        path = this.parsePath(path);\r\n        return container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                path: path\r\n            })\r\n        });\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var funnelCfg = getFillAttrs(cfg);\r\n        return Util.mix({\r\n            symbol: 'square',\r\n            radius: 4\r\n        }, funnelCfg);\r\n    }\r\n});\r\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\r\n    if (stage === 0) {\r\n        return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\r\n    }\r\n    else if (stage === 1) {\r\n        return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\r\n    }\r\n    else if (stage === 2) {\r\n        return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\r\n    }\r\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\r\n}\r\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\r\n    var curves = Math.ceil(2 * radius / waveLength * 4) * 2;\r\n    var path = [];\r\n    while (phase < -Math.PI * 2) {\r\n        phase += Math.PI * 2;\r\n    }\r\n    while (phase > 0) {\r\n        phase -= Math.PI * 2;\r\n    }\r\n    phase = phase / Math.PI / 2 * waveLength;\r\n    var left = cx - radius + phase - radius * 2;\r\n    path.push(['M', left, waterLevel]);\r\n    var waveRight = 0;\r\n    for (var c = 0; c < curves; ++c) {\r\n        var stage = c % 4;\r\n        var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);\r\n        path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);\r\n        if (c === curves - 1) {\r\n            waveRight = pos[2][0];\r\n        }\r\n    }\r\n    path.push(['L', waveRight + left, cy + radius]);\r\n    path.push(['L', left, cy + radius]);\r\n    path.push(['L', left, waterLevel]);\r\n    return path;\r\n}\r\nfunction addWaterWave(x, y, level, waveCount, colors, group, clip, radius) {\r\n    var bbox = clip.getBBox();\r\n    var width = bbox.maxX - bbox.minX;\r\n    var height = bbox.maxY - bbox.minY;\r\n    var duration = 5000;\r\n    var delayDiff = 300;\r\n    for (var i = 0; i < waveCount; i++) {\r\n        var wave = group.addShape('path', {\r\n            attrs: {\r\n                path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / 64, x, y),\r\n                fill: colors[i],\r\n                clip: clip\r\n            }\r\n        });\r\n        if (Global.renderer === 'canvas') {\r\n            wave.animate({\r\n                transform: [['t', width / 2, 0]],\r\n                repeat: true\r\n            }, duration - i * delayDiff);\r\n        }\r\n    }\r\n}\r\nShape.registerShape('interval', 'liquid-fill-gauge', {\r\n    draw: function draw(cfg, container) {\r\n        var self = this;\r\n        var cy = 0.5;\r\n        var sumX = 0;\r\n        var minX = Infinity;\r\n        Util.each(cfg.points, function (p) {\r\n            if (p.x < minX) {\r\n                minX = p.x;\r\n            }\r\n            sumX += p.x;\r\n        });\r\n        var cx = sumX / cfg.points.length;\r\n        var cp = self.parsePoint({\r\n            x: cx,\r\n            y: cy\r\n        });\r\n        var minP = self.parsePoint({\r\n            x: minX,\r\n            y: 0.5\r\n        });\r\n        var xWidth = cp.x - minP.x;\r\n        var radius = Math.min(xWidth, minP.y);\r\n        var attrs = getFillAttrs(cfg);\r\n        var clipCircle = new G.Circle({\r\n            attrs: {\r\n                x: cp.x,\r\n                y: cp.y,\r\n                r: radius\r\n            }\r\n        });\r\n        addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, clipCircle, radius * 4);\r\n        return container.addShape('circle', {\r\n            attrs: Util.mix(getLineAttrs(cfg), {\r\n                x: cp.x,\r\n                y: cp.y,\r\n                r: radius + radius / 8\r\n            })\r\n        });\r\n    }\r\n});\r\nvar pathMetaCache = {};\r\nShape.registerShape('interval', 'liquid-fill-path', {\r\n    draw: function draw(cfg, container) {\r\n        var self = this;\r\n        var attrs = Util.mix({}, getFillAttrs(cfg));\r\n        var path = cfg.shape[1];\r\n        var cy = 0.5;\r\n        var sumX = 0;\r\n        var minX = Infinity;\r\n        Util.each(cfg.points, function (p) {\r\n            if (p.x < minX) {\r\n                minX = p.x;\r\n            }\r\n            sumX += p.x;\r\n        });\r\n        var cx = sumX / cfg.points.length;\r\n        var cp = self.parsePoint({\r\n            x: cx,\r\n            y: cy\r\n        });\r\n        var minP = self.parsePoint({\r\n            x: minX,\r\n            y: 0.5\r\n        });\r\n        var xWidth = cp.x - minP.x;\r\n        var radius = Math.min(xWidth, minP.y);\r\n        var pathMeta;\r\n        if (pathMetaCache[path]) {\r\n            pathMeta = pathMetaCache[path];\r\n        }\r\n        else {\r\n            var segments = GPathUtil.parsePathString(path);\r\n            pathMetaCache[path] = pathMeta = {\r\n                segments: segments\r\n            };\r\n        }\r\n        var transform = [];\r\n        if (attrs.rotate) {\r\n            transform.push(['r', attrs.rotate / 180 * Math.PI]);\r\n            delete attrs.rotate;\r\n        }\r\n        var shape = container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                fillOpacity: 0,\r\n                path: pathMeta.segments\r\n            })\r\n        });\r\n        var bbox = Util.cloneDeep(shape.getBBox());\r\n        var rangeX = bbox.maxX - bbox.minX;\r\n        var rangeY = bbox.maxY - bbox.minY;\r\n        var range = Math.max(rangeX, rangeY);\r\n        var scale = radius * 2 / range;\r\n        shape.transform(transform.concat([['s', scale, scale]]));\r\n        var dw = scale * rangeX / 2;\r\n        var dh = scale * rangeY / 2;\r\n        shape.transform([['t', cp.x - dw, cp.y - dh]]);\r\n        addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, shape, minP.y * 4);\r\n        var keyShape = container.addShape('path', {\r\n            attrs: Util.mix(getLineAttrs(cfg), {\r\n                path: pathMeta.segments\r\n            })\r\n        });\r\n        keyShape.transform(transform.concat([['s', scale, scale], ['t', cp.x - dw, cp.y - dh]]));\r\n        return keyShape;\r\n    }\r\n});\r\nShape.registerShape('interval', 'top-line', {\r\n    draw: function draw(cfg, container) {\r\n        var attrs = getFillAttrs(cfg);\r\n        var style = cfg.style || {};\r\n        var linePath = [['M', cfg.points[1].x, cfg.points[1].y], ['L', cfg.points[2].x, cfg.points[2].y]];\r\n        var lineAttrs = {\r\n            stroke: style.stroke || 'white',\r\n            lineWidth: style.lineWidth || 1,\r\n            path: this.parsePath(linePath)\r\n        };\r\n        var path = getRectPath(cfg.points);\r\n        path = this.parsePath(path);\r\n        delete attrs.stroke;\r\n        var rectShape = container.addShape('path', {\r\n            attrs: Util.mix(attrs, {\r\n                zIndex: 0,\r\n                path: path\r\n            })\r\n        });\r\n        container.addShape('path', {\r\n            zIndex: 1,\r\n            attrs: lineAttrs\r\n        });\r\n        return rectShape;\r\n    },\r\n    getMarkerCfg: function getMarkerCfg(cfg) {\r\n        var rectCfg = getFillAttrs(cfg);\r\n        var isInCircle = cfg.isInCircle;\r\n        return Util.mix({\r\n            symbol: isInCircle ? 'circle' : 'square',\r\n            radius: isInCircle ? 4.5 : 4\r\n        }, rectCfg);\r\n    }\r\n});\r\nmodule.exports = Interval;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\shape\\interval.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\shape\\interval.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview interval shapes\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n * @author huangtonger@aliyun.com\n */\nvar Util = require('../../util');\n\nvar Shape = require('./shape');\n\nvar PathUtil = require('../util/path');\n\nvar GPathUtil = Util.PathUtil;\n\nvar Global = require('../../global');\n\nvar G = require('../../renderer'); // 获取柱状图的几个点\n\n\nfunction getRectPoints(cfg, isPyramid) {\n  var x = cfg.x;\n  var y = cfg.y;\n  var y0 = cfg.y0; // 0 点的位置\n\n  var width = cfg.size; // 有3种情况，\n  // 1. y，x都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n\n  var ymin = y0;\n  var ymax = y;\n\n  if (Util.isArray(y)) {\n    ymax = y[1];\n    ymin = y[0];\n  }\n\n  var xmin;\n  var xmax;\n\n  if (Util.isArray(x)) {\n    xmin = x[0];\n    xmax = x[1];\n  } else {\n    xmin = x - width / 2;\n    xmax = x + width / 2;\n  }\n\n  var points = [];\n  points.push({\n    x: xmin,\n    y: ymin\n  }, {\n    x: xmin,\n    y: ymax\n  });\n\n  if (isPyramid) {\n    points.push({\n      x: xmax,\n      y: (ymax + ymin) / 2\n    });\n  } else {\n    points.push({\n      x: xmax,\n      y: ymax\n    }, {\n      x: xmax,\n      y: ymin\n    });\n  }\n\n  return points;\n}\n\nfunction getRectPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (point) {\n      var action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  var first = points[0];\n  path.push(['L', first.x, first.y]);\n  path.push(['z']);\n  return path;\n}\n\nfunction getLinePoints(cfg) {\n  var x = cfg.x;\n  var y = cfg.y;\n  var y0 = cfg.y0; // 0 点的位置\n\n  var points = [];\n\n  if (Util.isArray(y)) {\n    Util.each(y, function (yItem, idx) {\n      points.push({\n        x: Util.isArray(x) ? x[idx] : x,\n        y: yItem\n      });\n    });\n  } else {\n    points.push({\n      x: x,\n      y: y\n    }, {\n      x: x,\n      y: y0\n    });\n  }\n\n  return points;\n}\n\nfunction getTickPoints(cfg) {\n  var x = cfg.x;\n  var y = Util.isArray(cfg.y) ? cfg.y[1] : cfg.y;\n  var y0 = Util.isArray(cfg.y) ? cfg.y[0] : cfg.y0;\n  var barWidth = cfg.size;\n  var points = [];\n  points.push({\n    x: x - barWidth / 2,\n    y: y\n  }, {\n    x: x + barWidth / 2,\n    y: y\n  }, {\n    x: x,\n    y: y\n  }, {\n    x: x,\n    y: y0\n  }, {\n    x: x - barWidth / 2,\n    y: y0\n  }, {\n    x: x + barWidth / 2,\n    y: y0\n  });\n  return points;\n}\n\nfunction getTickPath(points) {\n  var path = [];\n  path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]);\n  return path;\n}\n\nfunction getFillAttrs(cfg) {\n  var defaultAttrs = Global.shape.interval;\n  var attrs = Util.mix({}, defaultAttrs, {\n    fill: cfg.color,\n    stroke: cfg.color,\n    fillOpacity: cfg.opacity\n  }, cfg.style);\n  return attrs;\n}\n\nfunction getLineAttrs(cfg) {\n  var defaultAttrs = Global.shape.hollowInterval;\n  var attrs = Util.mix({}, defaultAttrs, {\n    stroke: cfg.color,\n    strokeOpacity: cfg.opacity\n  }, cfg.style);\n  return attrs;\n}\n\nfunction getFunnelPath(cfg, isFunnel) {\n  var path = [];\n  var points = cfg.points;\n  var nextPoints = cfg.nextPoints;\n\n  if (!Util.isNil(nextPoints)) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);\n  } else if (isFunnel) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);\n  } else {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);\n  }\n\n  return path;\n}\n\nfunction getThetaCfg(point, coord) {\n  var r = coord.getRadius();\n  var inner = coord.innerRadius;\n  var startAngle;\n  var endAngle;\n  var ir = r * inner;\n  var startPoint;\n  var endPoint;\n\n  if (!Util.isArray(point.x) && Util.isArray(point.y)) {\n    point.x = [point.x, point.x]; // 如果x是一个值，y是数组，将x转成数组\n  }\n\n  if (Util.isArray(point.x)) {\n    startPoint = {\n      x: point.x[0],\n      y: point.y[0]\n    };\n    endPoint = {\n      x: point.x[1],\n      y: point.y[1]\n    };\n    startAngle = PathUtil.getPointAngle(coord, startPoint);\n    endAngle = PathUtil.getPointAngle(coord, endPoint);\n\n    if (endAngle <= startAngle) {\n      // 考虑占比百分百的情形\n      endAngle = endAngle + Math.PI * 2;\n    }\n  } else {\n    endPoint = point;\n    startAngle = coord.startAngle;\n    endAngle = PathUtil.getPointAngle(coord, endPoint);\n  }\n\n  return {\n    r: r,\n    ir: ir,\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n} // 获取选中时的样式，当前仅支持饼图\n\n\nfunction _getSelectedCfg(type, cfg) {\n  var geom = cfg.geom;\n  var coord = geom.get('coord');\n  var point = cfg.point;\n  var r = 7.5;\n  var selectedCfg;\n\n  if (coord && coord.type === 'theta') {\n    var thetaCfg = getThetaCfg(point, coord);\n    var middleAngle = (thetaCfg.endAngle - thetaCfg.startAngle) / 2 + thetaCfg.startAngle;\n    var x = r * Math.cos(middleAngle);\n    var y = r * Math.sin(middleAngle);\n    selectedCfg = {\n      transform: [['t', x, y]]\n    };\n  }\n\n  return Util.mix({}, selectedCfg);\n}\n\nvar Interval = Shape.registerFactory('interval', {\n  defaultShapeType: 'rect',\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    if (!type || Util.inArray(['rect', 'funnel', 'pyramid'], type)) {\n      // 透明度降低 0.15\n      var fillOpacity = cfg.fillOpacity || cfg.opacity || 1;\n      return {\n        fillOpacity: fillOpacity - 0.15\n      };\n    }\n\n    var lineWidth = cfg.lineWidth || 0;\n    return {\n      lineWidth: lineWidth + 1\n    };\n  },\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return getRectPoints(pointInfo);\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    return _getSelectedCfg(type, cfg);\n  }\n}); // 默认柱状图\n\nShape.registerShape('interval', 'rect', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getFillAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n}); // 空心柱状图\n\nShape.registerShape('interval', 'hollowRect', {\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getLineAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n}); // 线形柱状图\n\nShape.registerShape('interval', 'line', {\n  getPoints: function getPoints(pointInfo) {\n    return getLinePoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    attrs.lineWidth = cfg.size || 1; // size 就是线的宽度\n\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var lineCfg = getLineAttrs(cfg);\n    return Util.mix({\n      symbol: 'line',\n      radius: 5\n    }, lineCfg);\n  }\n}); // 钉子形的柱状图\n\nShape.registerShape('interval', 'tick', {\n  getPoints: function getPoints(pointInfo) {\n    return getTickPoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    var path = getTickPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var lineCfg = getLineAttrs(cfg);\n    return Util.mix({\n      symbol: 'tick',\n      radius: 5\n    }, lineCfg);\n  }\n}); // 漏斗图\n\nShape.registerShape('interval', 'funnel', {\n  getPoints: function getPoints(pointInfo) {\n    pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍\n\n    return getRectPoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getFunnelPath(cfg, true);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var funnelCfg = getFillAttrs(cfg);\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, funnelCfg);\n  }\n}); // 金字塔图\n\nShape.registerShape('interval', 'pyramid', {\n  getPoints: function getPoints(pointInfo) {\n    pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍\n\n    return getRectPoints(pointInfo, true);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getFunnelPath(cfg, false);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var funnelCfg = getFillAttrs(cfg);\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, funnelCfg);\n  }\n}); // 水波图\n\n/**\n * 用贝塞尔曲线模拟正弦波\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n * @return {Array} 正弦片段曲线\n */\n\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  } else if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  } else if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  }\n\n  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n}\n/**\n * 获取水波路径\n * @param  {number} radius          半径\n * @param  {number} waterLevel      水位\n * @param  {number} waveLength      波长\n * @param  {number} phase           相位\n * @param  {number} amplitude       震幅\n * @param  {number} cx              圆心x\n * @param  {number} cy              圆心y\n * @return {Array}  path            路径\n * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135\n */\n\n\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\n  var curves = Math.ceil(2 * radius / waveLength * 4) * 2;\n  var path = []; // map phase to [-Math.PI * 2, 0]\n\n  while (phase < -Math.PI * 2) {\n    phase += Math.PI * 2;\n  }\n\n  while (phase > 0) {\n    phase -= Math.PI * 2;\n  }\n\n  phase = phase / Math.PI / 2 * waveLength;\n  var left = cx - radius + phase - radius * 2;\n  /**\n   * top-left corner as start point\n   *\n   * draws this point\n   *  |\n   * \\|/\n   *  ~~~~~~~~\n   *  |      |\n   *  +------+\n   */\n\n  path.push(['M', left, waterLevel]);\n  /**\n   * top wave\n   *\n   * ~~~~~~~~ <- draws this sine wave\n   * |      |\n   * +------+\n   */\n\n  var waveRight = 0;\n\n  for (var c = 0; c < curves; ++c) {\n    var stage = c % 4;\n    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);\n    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);\n\n    if (c === curves - 1) {\n      waveRight = pos[2][0];\n    }\n  }\n  /**\n   * top-right corner\n   *\n   *                       ~~~~~~~~\n   * 3. draws this line -> |      | <- 1. draws this line\n   *                       +------+\n   *                          ^\n   *                          |\n   *                  2. draws this line\n   */\n\n\n  path.push(['L', waveRight + left, cy + radius]);\n  path.push(['L', left, cy + radius]);\n  path.push(['L', left, waterLevel]);\n  return path;\n}\n/**\n * 添加水波\n * @param {number} x           中心x\n * @param {number} y           中心y\n * @param {number} level       水位等级 0～1\n * @param {number} waveCount   水波数\n * @param {number} colors      色值\n * @param {number} group       图组\n * @param {number} clip        用于剪切的图形\n * @param {number} radius      绘制图形的高度\n */\n\n\nfunction addWaterWave(x, y, level, waveCount, colors, group, clip, radius) {\n  var bbox = clip.getBBox();\n  var width = bbox.maxX - bbox.minX;\n  var height = bbox.maxY - bbox.minY;\n  var duration = 5000;\n  var delayDiff = 300;\n\n  for (var i = 0; i < waveCount; i++) {\n    var wave = group.addShape('path', {\n      attrs: {\n        path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / 64, x, y),\n        fill: colors[i],\n        clip: clip\n      }\n    }); // FIXME wave animation error in svg\n\n    if (Global.renderer === 'canvas') {\n      wave.animate({\n        transform: [['t', width / 2, 0]],\n        repeat: true\n      }, duration - i * delayDiff);\n    }\n  }\n}\n\nShape.registerShape('interval', 'liquid-fill-gauge', {\n  draw: function draw(cfg, container) {\n    var self = this;\n    var cy = 0.5;\n    var sumX = 0;\n    var minX = Infinity;\n    Util.each(cfg.points, function (p) {\n      if (p.x < minX) {\n        minX = p.x;\n      }\n\n      sumX += p.x;\n    });\n    var cx = sumX / cfg.points.length;\n    var cp = self.parsePoint({\n      x: cx,\n      y: cy\n    });\n    var minP = self.parsePoint({\n      x: minX,\n      y: 0.5\n    });\n    var xWidth = cp.x - minP.x;\n    var radius = Math.min(xWidth, minP.y);\n    var attrs = getFillAttrs(cfg);\n    var clipCircle = new G.Circle({\n      attrs: {\n        x: cp.x,\n        y: cp.y,\n        r: radius\n      }\n    });\n    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, clipCircle, radius * 4);\n    return container.addShape('circle', {\n      attrs: Util.mix(getLineAttrs(cfg), {\n        x: cp.x,\n        y: cp.y,\n        r: radius + radius / 8\n      })\n    });\n  }\n});\nvar pathMetaCache = {};\nShape.registerShape('interval', 'liquid-fill-path', {\n  draw: function draw(cfg, container) {\n    var self = this;\n    var attrs = Util.mix({}, getFillAttrs(cfg));\n    var path = cfg.shape[1];\n    var cy = 0.5;\n    var sumX = 0;\n    var minX = Infinity;\n    Util.each(cfg.points, function (p) {\n      if (p.x < minX) {\n        minX = p.x;\n      }\n\n      sumX += p.x;\n    });\n    var cx = sumX / cfg.points.length;\n    var cp = self.parsePoint({\n      x: cx,\n      y: cy\n    });\n    var minP = self.parsePoint({\n      x: minX,\n      y: 0.5\n    });\n    var xWidth = cp.x - minP.x;\n    var radius = Math.min(xWidth, minP.y);\n    var pathMeta;\n\n    if (pathMetaCache[path]) {\n      pathMeta = pathMetaCache[path];\n    } else {\n      var segments = GPathUtil.parsePathString(path);\n      pathMetaCache[path] = pathMeta = {\n        segments: segments\n      };\n    }\n\n    var transform = [];\n\n    if (attrs.rotate) {\n      transform.push(['r', attrs.rotate / 180 * Math.PI]);\n      delete attrs.rotate;\n    }\n\n    var shape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        fillOpacity: 0,\n        path: pathMeta.segments\n      })\n    });\n    var bbox = Util.cloneDeep(shape.getBBox());\n    var rangeX = bbox.maxX - bbox.minX;\n    var rangeY = bbox.maxY - bbox.minY;\n    var range = Math.max(rangeX, rangeY);\n    var scale = radius * 2 / range;\n    shape.transform(transform.concat([['s', scale, scale]]));\n    var dw = scale * rangeX / 2; // (bbox.maxX - bbox.minX) / 2;\n\n    var dh = scale * rangeY / 2; // (bbox.maxY - bbox.minY) / 2;\n\n    shape.transform([['t', cp.x - dw, cp.y - dh]]);\n    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, shape, minP.y * 4);\n    var keyShape = container.addShape('path', {\n      attrs: Util.mix(getLineAttrs(cfg), {\n        path: pathMeta.segments\n      })\n    });\n    keyShape.transform(transform.concat([['s', scale, scale], ['t', cp.x - dw, cp.y - dh]]));\n    return keyShape;\n  }\n});\nShape.registerShape('interval', 'top-line', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var style = cfg.style || {};\n    var linePath = [['M', cfg.points[1].x, cfg.points[1].y], ['L', cfg.points[2].x, cfg.points[2].y]];\n    var lineAttrs = {\n      stroke: style.stroke || 'white',\n      lineWidth: style.lineWidth || 1,\n      path: this.parsePath(linePath)\n    };\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    delete attrs.stroke; // 不在柱子上绘制线\n\n    var rectShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        zIndex: 0,\n        path: path\n      })\n    });\n    container.addShape('path', {\n      zIndex: 1,\n      attrs: lineAttrs\n    });\n    return rectShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getFillAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n});\nmodule.exports = Interval;"]}]}