{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/diagram/arc.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/diagram/arc.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var assign = require('@antv/util/lib/mix');\nvar forIn = require('@antv/util/lib/each');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar values = require('@antv/util/lib/object/values');\nvar isFunction = require('@antv/util/lib/type/is-function');\nvar registerTransform = require('../../data-set').registerTransform;\nvar DEFAULT_OPTIONS = {\n    y: 0,\n    thickness: 0.05,\n    weight: false,\n    marginRatio: 0.1,\n    id: function (node) { return node.id; },\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n    sourceWeight: function (edge) { return edge.value || 1; },\n    targetWeight: function (edge) { return edge.value || 1; },\n    sortBy: null\n};\nfunction _nodesFromEdges(edges, options, map) {\n    if (map === void 0) { map = {}; }\n    edges.forEach(function (edge) {\n        var sId = options.edgeSource(edge);\n        var tId = options.edgeTarget(edge);\n        if (!map[sId]) {\n            map[sId] = {\n                id: sId\n            };\n        }\n        if (!map[tId]) {\n            map[tId] = {\n                id: tId\n            };\n        }\n    });\n    return values(map);\n}\nfunction _processGraph(nodeById, edges, options) {\n    forIn(nodeById, function (node, id) {\n        node.inEdges = edges.filter(function (edge) { return \"\" + options.target(edge) === \"\" + id; });\n        node.outEdges = edges.filter(function (edge) { return \"\" + options.source(edge) === \"\" + id; });\n        node.edges = node.outEdges.concat(node.inEdges);\n        node.frequency = node.edges.length;\n        node.value = 0;\n        node.inEdges.forEach(function (edge) {\n            node.value += options.targetWeight(edge);\n        });\n        node.outEdges.forEach(function (edge) {\n            node.value += options.sourceWeight(edge);\n        });\n    });\n}\nfunction _sortNodes(nodes, options) {\n    var sortMethods = {\n        weight: function (a, b) { return b.value - a.value; },\n        frequency: function (a, b) { return b.frequency - a.frequency; },\n        id: function (a, b) { return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b)); }\n    };\n    var method = sortMethods[options.sortBy];\n    if (!method && isFunction(options.sortBy)) {\n        method = options.sortBy;\n    }\n    if (method) {\n        nodes.sort(method);\n    }\n}\nfunction _layoutNodes(nodes, options) {\n    var len = nodes.length;\n    if (!len) {\n        throw new TypeError('Invalid nodes: it\\'s empty!');\n    }\n    if (options.weight) {\n        var marginRatio_1 = options.marginRatio;\n        if (marginRatio_1 < 0 || marginRatio_1 >= 1) {\n            throw new TypeError('Invalid marginRatio: it must be in range [0, 1)!');\n        }\n        var margin_1 = marginRatio_1 / (2 * len);\n        var thickness_1 = options.thickness;\n        if (thickness_1 <= 0 || thickness_1 >= 1) {\n            throw new TypeError('Invalid thickness: it must be in range (0, 1)!');\n        }\n        var totalValue_1 = 0;\n        nodes.forEach(function (node) {\n            totalValue_1 += node.value;\n        });\n        nodes.forEach(function (node) {\n            node.weight = node.value / totalValue_1;\n            node.width = node.weight * (1 - marginRatio_1);\n            node.height = thickness_1;\n        });\n        nodes.forEach(function (node, index) {\n            var deltaX = 0;\n            for (var i = index - 1; i >= 0; i--) {\n                deltaX += nodes[i].width + 2 * margin_1;\n            }\n            var minX = node.minX = margin_1 + deltaX;\n            var maxX = node.maxX = node.minX + node.width;\n            var minY = node.minY = options.y - thickness_1 / 2;\n            var maxY = node.maxY = minY + thickness_1;\n            node.x = [minX, maxX, maxX, minX];\n            node.y = [minY, minY, maxY, maxY];\n        });\n    }\n    else {\n        var deltaX_1 = 1 / len;\n        nodes.forEach(function (node, index) {\n            node.x = (index + 0.5) * deltaX_1;\n            node.y = options.y;\n        });\n    }\n}\nfunction _locatingEdges(nodeById, edges, options) {\n    if (options.weight) {\n        var valueById_1 = {};\n        forIn(nodeById, function (node, id) {\n            valueById_1[id] = node.value;\n        });\n        edges.forEach(function (edge) {\n            var sId = options.source(edge);\n            var tId = options.target(edge);\n            var sNode = nodeById[sId];\n            var tNode = nodeById[tId];\n            if (sNode && tNode) {\n                var sValue = valueById_1[sId];\n                var currentSValue = options.sourceWeight(edge);\n                var sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n                var sEnd = sStart + currentSValue / sNode.value * sNode.width;\n                valueById_1[sId] -= currentSValue;\n                var tValue = valueById_1[tId];\n                var currentTValue = options.targetWeight(edge);\n                var tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n                var tEnd = tStart + currentTValue / tNode.value * tNode.width;\n                valueById_1[tId] -= currentTValue;\n                var y = options.y;\n                edge.x = [sStart, sEnd, tStart, tEnd];\n                edge.y = [y, y, y, y];\n            }\n        });\n    }\n    else {\n        edges.forEach(function (edge) {\n            var sNode = nodeById[options.source(edge)];\n            var tNode = nodeById[options.target(edge)];\n            if (sNode && tNode) {\n                edge.x = [sNode.x, tNode.x];\n                edge.y = [sNode.y, tNode.y];\n            }\n        });\n    }\n}\nfunction transform(dv, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var nodeById = {};\n    var nodes = dv.nodes;\n    var edges = dv.edges;\n    if (!isArray(nodes) || nodes.length === 0) {\n        nodes = _nodesFromEdges(edges, options, nodeById);\n    }\n    nodes.forEach(function (node) {\n        var id = options.id(node);\n        nodeById[id] = node;\n    });\n    _processGraph(nodeById, edges, options);\n    _sortNodes(nodes, options);\n    _layoutNodes(nodes, options);\n    _locatingEdges(nodeById, edges, options);\n    dv.nodes = nodes;\n    dv.edges = edges;\n}\nregisterTransform('diagram.arc', transform);\nregisterTransform('arc', transform);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/diagram/arc.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/diagram/arc.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nconst assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst values = require('@antv/util/lib/object/values');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst {\n  registerTransform\n} = require('../../data-set');\n\nconst DEFAULT_OPTIONS = {\n  y: 0,\n  thickness: 0.05, // thickness of the node, (0, 1)\n  weight: false,\n  marginRatio: 0.1, // margin ratio, [0, 1)\n  id: node => node.id,\n  source: edge => edge.source,\n  target: edge => edge.target,\n  sourceWeight: edge => edge.value || 1,\n  targetWeight: edge => edge.value || 1,\n  sortBy: null // optional, id | weight | frequency | {function}\n};\n\nfunction _nodesFromEdges(edges, options, map = {}) {\n  edges.forEach(edge => {\n    const sId = options.edgeSource(edge);\n    const tId = options.edgeTarget(edge);\n    if (!map[sId]) {\n      map[sId] = {\n        id: sId\n      };\n    }\n    if (!map[tId]) {\n      map[tId] = {\n        id: tId\n      };\n    }\n  });\n  return values(map);\n}\n\nfunction _processGraph(nodeById, edges, options) {\n  forIn(nodeById, (node, id) => {\n    // in edges, out edges\n    node.inEdges = edges.filter(edge => `${options.target(edge)}` === `${id}`);\n    node.outEdges = edges.filter(edge => `${options.source(edge)}` === `${id}`);\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach(edge => {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach(edge => {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n\nfunction _sortNodes(nodes, options) {\n  const sortMethods = {\n    weight: (a, b) => b.value - a.value,\n    frequency: (a, b) => b.frequency - a.frequency,\n    id: (a, b) => (`${options.id(a)}`).localeCompare(`${options.id(b)}`)\n  };\n  let method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction _layoutNodes(nodes, options) {\n  const len = nodes.length;\n  if (!len) {\n    throw new TypeError('Invalid nodes: it\\'s empty!');\n  }\n  if (options.weight) {\n    const marginRatio = options.marginRatio;\n    if (marginRatio < 0 || marginRatio >= 1) {\n      throw new TypeError('Invalid marginRatio: it must be in range [0, 1)!');\n    }\n    const margin = marginRatio / (2 * len);\n    const thickness = options.thickness;\n    if (thickness <= 0 || thickness >= 1) {\n      throw new TypeError('Invalid thickness: it must be in range (0, 1)!');\n    }\n    let totalValue = 0;\n    nodes.forEach(node => {\n      totalValue += node.value;\n    });\n    nodes.forEach(node => {\n      node.weight = node.value / totalValue;\n      node.width = node.weight * (1 - marginRatio);\n      node.height = thickness;\n    });\n    nodes.forEach((node, index) => {\n      // x\n      let deltaX = 0;\n      for (let i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin;\n      }\n      const minX = node.minX = margin + deltaX;\n      const maxX = node.maxX = node.minX + node.width;\n      const minY = node.minY = options.y - thickness / 2;\n      const maxY = node.maxY = minY + thickness;\n      node.x = [ minX, maxX, maxX, minX ];\n      node.y = [ minY, minY, maxY, maxY ];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    const deltaX = 1 / len;\n    nodes.forEach((node, index) => {\n      node.x = (index + 0.5) * deltaX;\n      node.y = options.y;\n    });\n  }\n}\n\nfunction _locatingEdges(nodeById, edges, options) {\n  if (options.weight) {\n    const valueById = {};\n    forIn(nodeById, (node, id) => {\n      valueById[id] = node.value;\n    });\n    edges.forEach(edge => {\n      const sId = options.source(edge);\n      const tId = options.target(edge);\n      const sNode = nodeById[sId];\n      const tNode = nodeById[tId];\n      if (sNode && tNode) {\n        const sValue = valueById[sId];\n        const currentSValue = options.sourceWeight(edge);\n        const sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n        const sEnd = sStart + currentSValue / sNode.value * sNode.width;\n        valueById[sId] -= currentSValue;\n\n        const tValue = valueById[tId];\n        const currentTValue = options.targetWeight(edge);\n        const tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n        const tEnd = tStart + currentTValue / tNode.value * tNode.width;\n        valueById[tId] -= currentTValue;\n\n        const y = options.y;\n        edge.x = [ sStart, sEnd, tStart, tEnd ];\n        edge.y = [ y, y, y, y ];\n      }\n    });\n  } else {\n    edges.forEach(edge => {\n      const sNode = nodeById[options.source(edge)];\n      const tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [ sNode.x, tNode.x ];\n        edge.y = [ sNode.y, tNode.y ];\n      }\n    });\n  }\n}\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const nodeById = {};\n  let nodes = dv.nodes;\n  const edges = dv.edges;\n  if (!isArray(nodes) || nodes.length === 0) {\n    nodes = _nodesFromEdges(edges, options, nodeById);\n  }\n  nodes.forEach(node => {\n    const id = options.id(node);\n    nodeById[id] = node;\n  });\n  _processGraph(nodeById, edges, options);\n  _sortNodes(nodes, options);\n  _layoutNodes(nodes, options);\n  _locatingEdges(nodeById, edges, options);\n  dv.nodes = nodes;\n  dv.edges = edges;\n}\n\nregisterTransform('diagram.arc', transform);\nregisterTransform('arc', transform);\n"]}]}