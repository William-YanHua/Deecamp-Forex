{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-transition\\src\\transition\\schedule.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-transition\\src\\transition\\schedule.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { dispatch } from \"d3-dispatch\";\r\nimport { timer, timeout } from \"d3-timer\";\r\nvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\r\nvar emptyTween = [];\r\nexport var CREATED = 0;\r\nexport var SCHEDULED = 1;\r\nexport var STARTING = 2;\r\nexport var STARTED = 3;\r\nexport var RUNNING = 4;\r\nexport var ENDING = 5;\r\nexport var ENDED = 6;\r\nexport default function (node, name, id, index, group, timing) {\r\n    var schedules = node.__transition;\r\n    if (!schedules)\r\n        node.__transition = {};\r\n    else if (id in schedules)\r\n        return;\r\n    create(node, id, {\r\n        name: name,\r\n        index: index,\r\n        group: group,\r\n        on: emptyOn,\r\n        tween: emptyTween,\r\n        time: timing.time,\r\n        delay: timing.delay,\r\n        duration: timing.duration,\r\n        ease: timing.ease,\r\n        timer: null,\r\n        state: CREATED\r\n    });\r\n}\r\nexport function init(node, id) {\r\n    var schedule = get(node, id);\r\n    if (schedule.state > CREATED)\r\n        throw new Error(\"too late; already scheduled\");\r\n    return schedule;\r\n}\r\nexport function set(node, id) {\r\n    var schedule = get(node, id);\r\n    if (schedule.state > STARTING)\r\n        throw new Error(\"too late; already started\");\r\n    return schedule;\r\n}\r\nexport function get(node, id) {\r\n    var schedule = node.__transition;\r\n    if (!schedule || !(schedule = schedule[id]))\r\n        throw new Error(\"transition not found\");\r\n    return schedule;\r\n}\r\nfunction create(node, id, self) {\r\n    var schedules = node.__transition, tween;\r\n    schedules[id] = self;\r\n    self.timer = timer(schedule, 0, self.time);\r\n    function schedule(elapsed) {\r\n        self.state = SCHEDULED;\r\n        self.timer.restart(start, self.delay, self.time);\r\n        if (self.delay <= elapsed)\r\n            start(elapsed - self.delay);\r\n    }\r\n    function start(elapsed) {\r\n        var i, j, n, o;\r\n        if (self.state !== SCHEDULED)\r\n            return stop();\r\n        for (i in schedules) {\r\n            o = schedules[i];\r\n            if (o.name !== self.name)\r\n                continue;\r\n            if (o.state === STARTED)\r\n                return timeout(start);\r\n            if (o.state === RUNNING) {\r\n                o.state = ENDED;\r\n                o.timer.stop();\r\n                o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\r\n                delete schedules[i];\r\n            }\r\n            else if (+i < id) {\r\n                o.state = ENDED;\r\n                o.timer.stop();\r\n                delete schedules[i];\r\n            }\r\n        }\r\n        timeout(function () {\r\n            if (self.state === STARTED) {\r\n                self.state = RUNNING;\r\n                self.timer.restart(tick, self.delay, self.time);\r\n                tick(elapsed);\r\n            }\r\n        });\r\n        self.state = STARTING;\r\n        self.on.call(\"start\", node, node.__data__, self.index, self.group);\r\n        if (self.state !== STARTING)\r\n            return;\r\n        self.state = STARTED;\r\n        tween = new Array(n = self.tween.length);\r\n        for (i = 0, j = -1; i < n; ++i) {\r\n            if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\r\n                tween[++j] = o;\r\n            }\r\n        }\r\n        tween.length = j + 1;\r\n    }\r\n    function tick(elapsed) {\r\n        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;\r\n        while (++i < n) {\r\n            tween[i].call(null, t);\r\n        }\r\n        if (self.state === ENDING) {\r\n            self.on.call(\"end\", node, node.__data__, self.index, self.group);\r\n            stop();\r\n        }\r\n    }\r\n    function stop() {\r\n        self.state = ENDED;\r\n        self.timer.stop();\r\n        delete schedules[id];\r\n        for (var i in schedules)\r\n            return;\r\n        delete node.__transition;\r\n    }\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-transition\\src\\transition\\schedule.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-transition\\src\\transition\\schedule.js"],"names":[],"mappings":"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","sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer, timeout} from \"d3-timer\";\n\nvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\n\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\n\nexport default function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\n\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\n\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTING) throw new Error(\"too late; already started\");\n  return schedule;\n}\n\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout(start);\n\n      // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n"]}]}