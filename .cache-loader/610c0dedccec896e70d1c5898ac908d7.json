{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-voronoi\\src\\Cell.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-voronoi\\src\\Cell.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { createBorderEdge } from \"./Edge\";\r\nimport { cells, edges, epsilon } from \"./Diagram\";\r\nexport function createCell(site) {\r\n    return cells[site.index] = {\r\n        site: site,\r\n        halfedges: []\r\n    };\r\n}\r\nfunction cellHalfedgeAngle(cell, edge) {\r\n    var site = cell.site, va = edge.left, vb = edge.right;\r\n    if (site === vb)\r\n        vb = va, va = site;\r\n    if (vb)\r\n        return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\r\n    if (site === va)\r\n        va = edge[1], vb = edge[0];\r\n    else\r\n        va = edge[0], vb = edge[1];\r\n    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\r\n}\r\nexport function cellHalfedgeStart(cell, edge) {\r\n    return edge[+(edge.left !== cell.site)];\r\n}\r\nexport function cellHalfedgeEnd(cell, edge) {\r\n    return edge[+(edge.left === cell.site)];\r\n}\r\nexport function sortCellHalfedges() {\r\n    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\r\n        if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\r\n            var index = new Array(m), array = new Array(m);\r\n            for (j = 0; j < m; ++j)\r\n                index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\r\n            index.sort(function (i, j) { return array[j] - array[i]; });\r\n            for (j = 0; j < m; ++j)\r\n                array[j] = halfedges[index[j]];\r\n            for (j = 0; j < m; ++j)\r\n                halfedges[j] = array[j];\r\n        }\r\n    }\r\n}\r\nexport function clipCells(x0, y0, x1, y1) {\r\n    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;\r\n    for (iCell = 0; iCell < nCells; ++iCell) {\r\n        if (cell = cells[iCell]) {\r\n            site = cell.site;\r\n            halfedges = cell.halfedges;\r\n            iHalfedge = halfedges.length;\r\n            while (iHalfedge--) {\r\n                if (!edges[halfedges[iHalfedge]]) {\r\n                    halfedges.splice(iHalfedge, 1);\r\n                }\r\n            }\r\n            iHalfedge = 0, nHalfedges = halfedges.length;\r\n            while (iHalfedge < nHalfedges) {\r\n                end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\r\n                start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\r\n                if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\r\n                    halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\r\n                        : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\r\n                            : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\r\n                                : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\r\n                                    : null)) - 1);\r\n                    ++nHalfedges;\r\n                }\r\n            }\r\n            if (nHalfedges)\r\n                cover = false;\r\n        }\r\n    }\r\n    if (cover) {\r\n        var dx, dy, d2, dc = Infinity;\r\n        for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\r\n            if (cell = cells[iCell]) {\r\n                site = cell.site;\r\n                dx = site[0] - x0;\r\n                dy = site[1] - y0;\r\n                d2 = dx * dx + dy * dy;\r\n                if (d2 < dc)\r\n                    dc = d2, cover = cell;\r\n            }\r\n        }\r\n        if (cover) {\r\n            var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\r\n            cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);\r\n        }\r\n    }\r\n    for (iCell = 0; iCell < nCells; ++iCell) {\r\n        if (cell = cells[iCell]) {\r\n            if (!cell.halfedges.length) {\r\n                delete cells[iCell];\r\n            }\r\n        }\r\n    }\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-voronoi\\src\\Cell.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-voronoi\\src\\Cell.js"],"names":[],"mappings":"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","sourcesContent":["import {createBorderEdge} from \"./Edge\";\nimport {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n"]}]}