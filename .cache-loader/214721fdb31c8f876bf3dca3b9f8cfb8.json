{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/animate/timeline.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/animate/timeline.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport * as d3Ease from 'd3-ease';\nimport { interpolate, interpolateArray } from 'd3-interpolate';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nfunction _update(shape, animation, ratio) {\n    var cProps = {};\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\n    if (shape.destroyed) {\n        return;\n    }\n    var interf;\n    for (var k in toAttrs) {\n        if (!isEqual(fromAttrs[k], toAttrs[k])) {\n            if (k === 'path') {\n                var toPath = toAttrs[k];\n                var fromPath = fromAttrs[k];\n                if (toPath.length > fromPath.length) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                }\n                else if (!animation.pathFormatted) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                    animation.pathFormatted = true;\n                }\n                cProps[k] = [];\n                for (var i = 0; i < toPath.length; i++) {\n                    var toPathPoint = toPath[i];\n                    var fromPathPoint = fromPath[i];\n                    var cPathPoint = [];\n                    for (var j = 0; j < toPathPoint.length; j++) {\n                        if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n                            cPathPoint.push(interf(ratio));\n                        }\n                        else {\n                            cPathPoint.push(toPathPoint[j]);\n                        }\n                    }\n                    cProps[k].push(cPathPoint);\n                }\n            }\n            else if (k === 'matrix') {\n                var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n                var currentMatrix = matrixFn(ratio);\n                cProps[k] = currentMatrix;\n            }\n            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n                cProps[k] = toAttrs[k];\n            }\n            else if (!isFunction(toAttrs[k])) {\n                interf = interpolate(fromAttrs[k], toAttrs[k]);\n                cProps[k] = interf(ratio);\n            }\n        }\n    }\n    shape.attr(cProps);\n}\nfunction update(shape, animation, elapsed) {\n    var startTime = animation.startTime, delay = animation.delay;\n    if (elapsed < startTime + delay || animation._paused) {\n        return false;\n    }\n    var ratio;\n    var duration = animation.duration;\n    var easing = animation.easing;\n    elapsed = elapsed - startTime - animation.delay;\n    if (animation.repeat) {\n        ratio = (elapsed % duration) / duration;\n        ratio = d3Ease[easing](ratio);\n    }\n    else {\n        ratio = elapsed / duration;\n        if (ratio < 1) {\n            ratio = d3Ease[easing](ratio);\n        }\n        else {\n            if (animation.onFrame) {\n                shape.attr(animation.onFrame(1));\n            }\n            else {\n                shape.attr(animation.toAttrs);\n            }\n            return true;\n        }\n    }\n    if (animation.onFrame) {\n        var attrs = animation.onFrame(ratio);\n        shape.attr(attrs);\n    }\n    else {\n        _update(shape, animation, ratio);\n    }\n    return false;\n}\nvar Timeline = (function () {\n    function Timeline(canvas) {\n        this.animators = [];\n        this.current = 0;\n        this.timer = null;\n        this.canvas = canvas;\n    }\n    Timeline.prototype.initTimer = function () {\n        var _this = this;\n        var isFinished = false;\n        var shape;\n        var animations;\n        var animation;\n        this.timer = d3Timer.timer(function (elapsed) {\n            _this.current = elapsed;\n            if (_this.animators.length > 0) {\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\n                    shape = _this.animators[i];\n                    if (shape.destroyed) {\n                        _this.removeAnimator(i);\n                        continue;\n                    }\n                    if (!shape.isAnimatePaused()) {\n                        animations = shape.get('animations');\n                        for (var j = animations.length - 1; j >= 0; j--) {\n                            animation = animations[j];\n                            isFinished = update(shape, animation, elapsed);\n                            if (isFinished) {\n                                animations.splice(j, 1);\n                                isFinished = false;\n                                if (animation.callback) {\n                                    animation.callback();\n                                }\n                            }\n                        }\n                    }\n                    if (animations.length === 0) {\n                        _this.removeAnimator(i);\n                    }\n                }\n                var autoDraw = _this.canvas.get('autoDraw');\n                if (!autoDraw) {\n                    _this.canvas.draw();\n                }\n            }\n        });\n    };\n    Timeline.prototype.addAnimator = function (shape) {\n        this.animators.push(shape);\n    };\n    Timeline.prototype.removeAnimator = function (index) {\n        this.animators.splice(index, 1);\n    };\n    Timeline.prototype.isAnimating = function () {\n        return !!this.animators.length;\n    };\n    Timeline.prototype.stop = function () {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    };\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\n        if (toEnd === void 0) {\n            toEnd = true;\n        }\n        this.animators.forEach(function (animator) {\n            animator.stopAnimate(toEnd);\n        });\n        this.animators = [];\n        this.canvas.draw();\n    };\n    Timeline.prototype.getTime = function () {\n        return this.current;\n    };\n    return Timeline;\n}());\nexport default Timeline;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/animate/timeline.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/animate/timeline.js"],"names":[],"mappings":"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","sourcesContent":["import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport * as d3Ease from 'd3-ease';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n    var cProps = {}; // 此刻属性\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\n    if (shape.destroyed) {\n        return;\n    }\n    var interf; //  差值函数\n    for (var k in toAttrs) {\n        if (!isEqual(fromAttrs[k], toAttrs[k])) {\n            if (k === 'path') {\n                var toPath = toAttrs[k];\n                var fromPath = fromAttrs[k];\n                if (toPath.length > fromPath.length) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                }\n                else if (!animation.pathFormatted) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                    animation.pathFormatted = true;\n                }\n                cProps[k] = [];\n                for (var i = 0; i < toPath.length; i++) {\n                    var toPathPoint = toPath[i];\n                    var fromPathPoint = fromPath[i];\n                    var cPathPoint = [];\n                    for (var j = 0; j < toPathPoint.length; j++) {\n                        if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n                            cPathPoint.push(interf(ratio));\n                        }\n                        else {\n                            cPathPoint.push(toPathPoint[j]);\n                        }\n                    }\n                    cProps[k].push(cPathPoint);\n                }\n            }\n            else if (k === 'matrix') {\n                /*\n                 对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n                 TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n                 */\n                var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n                var currentMatrix = matrixFn(ratio);\n                cProps[k] = currentMatrix;\n            }\n            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n                cProps[k] = toAttrs[k];\n            }\n            else if (!isFunction(toAttrs[k])) {\n                // 非函数类型的值才能做插值\n                interf = interpolate(fromAttrs[k], toAttrs[k]);\n                cProps[k] = interf(ratio);\n            }\n        }\n    }\n    shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n    var startTime = animation.startTime, delay = animation.delay;\n    // 如果还没有开始执行或暂停，先不更新\n    if (elapsed < startTime + delay || animation._paused) {\n        return false;\n    }\n    var ratio;\n    var duration = animation.duration;\n    var easing = animation.easing;\n    // 已执行时间\n    elapsed = elapsed - startTime - animation.delay;\n    if (animation.repeat) {\n        // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n        ratio = (elapsed % duration) / duration;\n        ratio = d3Ease[easing](ratio);\n    }\n    else {\n        ratio = elapsed / duration;\n        if (ratio < 1) {\n            // 动画未执行完\n            ratio = d3Ease[easing](ratio);\n        }\n        else {\n            // 动画已执行完\n            if (animation.onFrame) {\n                shape.attr(animation.onFrame(1));\n            }\n            else {\n                shape.attr(animation.toAttrs);\n            }\n            return true;\n        }\n    }\n    if (animation.onFrame) {\n        var attrs = animation.onFrame(ratio);\n        shape.attr(attrs);\n    }\n    else {\n        _update(shape, animation, ratio);\n    }\n    return false;\n}\nvar Timeline = /** @class */ (function () {\n    /**\n     * 时间轴构造函数，依赖于画布\n     * @param {}\n     */\n    function Timeline(canvas) {\n        /**\n         * 执行动画的元素列表\n         * @type {IElement[]}\n         */\n        this.animators = [];\n        /**\n         * 当前时间\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * 定时器\n         * @type {d3Timer.Timer}\n         */\n        this.timer = null;\n        this.canvas = canvas;\n    }\n    /**\n     * 初始化定时器\n     */\n    Timeline.prototype.initTimer = function () {\n        var _this = this;\n        var isFinished = false;\n        var shape;\n        var animations;\n        var animation;\n        this.timer = d3Timer.timer(function (elapsed) {\n            _this.current = elapsed;\n            if (_this.animators.length > 0) {\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\n                    shape = _this.animators[i];\n                    if (shape.destroyed) {\n                        // 如果已经被销毁，直接移出队列\n                        _this.removeAnimator(i);\n                        continue;\n                    }\n                    if (!shape.isAnimatePaused()) {\n                        animations = shape.get('animations');\n                        for (var j = animations.length - 1; j >= 0; j--) {\n                            animation = animations[j];\n                            isFinished = update(shape, animation, elapsed);\n                            if (isFinished) {\n                                animations.splice(j, 1);\n                                isFinished = false;\n                                if (animation.callback) {\n                                    animation.callback();\n                                }\n                            }\n                        }\n                    }\n                    if (animations.length === 0) {\n                        _this.removeAnimator(i);\n                    }\n                }\n                var autoDraw = _this.canvas.get('autoDraw');\n                // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n                if (!autoDraw) {\n                    _this.canvas.draw();\n                }\n            }\n        });\n    };\n    /**\n     * 增加动画元素\n     */\n    Timeline.prototype.addAnimator = function (shape) {\n        this.animators.push(shape);\n    };\n    /**\n     * 移除动画元素\n     */\n    Timeline.prototype.removeAnimator = function (index) {\n        this.animators.splice(index, 1);\n    };\n    /**\n     * 是否有动画在执行\n     */\n    Timeline.prototype.isAnimating = function () {\n        return !!this.animators.length;\n    };\n    /**\n     * 停止定时器\n     */\n    Timeline.prototype.stop = function () {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    };\n    /**\n     * 停止时间轴上所有元素的动画，并置空动画元素列表\n     * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n     */\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\n        if (toEnd === void 0) { toEnd = true; }\n        this.animators.forEach(function (animator) {\n            animator.stopAnimate(toEnd);\n        });\n        this.animators = [];\n        this.canvas.draw();\n    };\n    /**\n     * 获取当前时间\n     */\n    Timeline.prototype.getTime = function () {\n        return this.current;\n    };\n    return Timeline;\n}());\nexport default Timeline;\n//# sourceMappingURL=timeline.js.map"]}]}