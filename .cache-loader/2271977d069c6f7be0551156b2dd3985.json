{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\esm\\geometry\\label\\polar.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\esm\\geometry\\label\\polar.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { __assign, __extends } from \"tslib\";\r\nimport { each, isArray } from '@antv/util';\r\nimport { getDistanceToCenter } from '../../util/coordinate';\r\nimport { getAngleByPoint } from '../../util/coordinate';\r\nimport GeometryLabel from './base';\r\nvar HALF_PI = Math.PI / 2;\r\nvar PolarLabel = (function (_super) {\r\n    __extends(PolarLabel, _super);\r\n    function PolarLabel() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PolarLabel.prototype.getLabelAlign = function (point) {\r\n        var coordinate = this.getCoordinate();\r\n        var align;\r\n        if (point.labelEmit) {\r\n            align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\r\n        }\r\n        else if (!coordinate.isTransposed) {\r\n            align = 'center';\r\n        }\r\n        else {\r\n            var center = coordinate.getCenter();\r\n            var offset = this.getDefaultOffset(point.offset);\r\n            if (Math.abs(point.x - center.x) < 1) {\r\n                align = 'center';\r\n            }\r\n            else if (point.angle > Math.PI || point.angle <= 0) {\r\n                align = offset > 0 ? 'left' : 'right';\r\n            }\r\n            else {\r\n                align = offset > 0 ? 'right' : 'left';\r\n            }\r\n        }\r\n        return align;\r\n    };\r\n    PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\r\n        var factor = 1;\r\n        var arcPoint;\r\n        var content = labelCfg.content[index];\r\n        if (this.isToMiddle(mappingData)) {\r\n            arcPoint = this.getMiddlePoint(mappingData.points);\r\n        }\r\n        else {\r\n            if (labelCfg.content.length === 1 && index === 0) {\r\n                index = 1;\r\n            }\r\n            else if (index === 0) {\r\n                factor = -1;\r\n            }\r\n            arcPoint = this.getArcPoint(mappingData, index);\r\n        }\r\n        var offset = this.getDefaultOffset(labelCfg.offset) * factor;\r\n        var middleAngle = this.getPointAngle(arcPoint);\r\n        var isLabelEmit = labelCfg.labelEmit;\r\n        var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\r\n        if (labelPositionCfg.r === 0) {\r\n            labelPositionCfg.content = '';\r\n        }\r\n        else {\r\n            labelPositionCfg.content = content;\r\n            labelPositionCfg.angle = middleAngle;\r\n            labelPositionCfg.color = mappingData.color;\r\n        }\r\n        labelPositionCfg.rotate = labelCfg.autoRotate\r\n            ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\r\n            : labelCfg.rotate;\r\n        labelPositionCfg.start = {\r\n            x: arcPoint.x,\r\n            y: arcPoint.y,\r\n        };\r\n        return labelPositionCfg;\r\n    };\r\n    PolarLabel.prototype.getArcPoint = function (mappingData, index) {\r\n        if (index === void 0) {\r\n            index = 0;\r\n        }\r\n        if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\r\n            return {\r\n                x: mappingData.x,\r\n                y: mappingData.y,\r\n            };\r\n        }\r\n        return {\r\n            x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\r\n            y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\r\n        };\r\n    };\r\n    PolarLabel.prototype.getPointAngle = function (point) {\r\n        return getAngleByPoint(this.getCoordinate(), point);\r\n    };\r\n    PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\r\n        var coordinate = this.getCoordinate();\r\n        var center = coordinate.getCenter();\r\n        var r = getDistanceToCenter(coordinate, point);\r\n        if (r === 0) {\r\n            return __assign(__assign({}, center), { r: r });\r\n        }\r\n        var labelAngle = angle;\r\n        if (coordinate.isTransposed && r > offset && !isLabelEmit) {\r\n            var appendAngle = Math.asin(offset / (2 * r));\r\n            labelAngle = angle + appendAngle * 2;\r\n        }\r\n        else {\r\n            r = r + offset;\r\n        }\r\n        return {\r\n            x: center.x + r * Math.cos(labelAngle),\r\n            y: center.y + r * Math.sin(labelAngle),\r\n            r: r,\r\n        };\r\n    };\r\n    PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\r\n        var rotate = angle + HALF_PI;\r\n        if (isLabelEmit) {\r\n            rotate -= HALF_PI;\r\n        }\r\n        if (rotate) {\r\n            if (rotate > HALF_PI) {\r\n                rotate = rotate - Math.PI;\r\n            }\r\n            else if (rotate < -HALF_PI) {\r\n                rotate = rotate + Math.PI;\r\n            }\r\n        }\r\n        return rotate;\r\n    };\r\n    PolarLabel.prototype.getMiddlePoint = function (points) {\r\n        var coordinate = this.getCoordinate();\r\n        var count = points.length;\r\n        var middlePoint = {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        each(points, function (point) {\r\n            middlePoint.x += point.x;\r\n            middlePoint.y += point.y;\r\n        });\r\n        middlePoint.x /= count;\r\n        middlePoint.y /= count;\r\n        middlePoint = coordinate.convert(middlePoint);\r\n        return middlePoint;\r\n    };\r\n    PolarLabel.prototype.isToMiddle = function (mappingData) {\r\n        return mappingData.x.length > 2;\r\n    };\r\n    return PolarLabel;\r\n}(GeometryLabel));\r\nexport default PolarLabel;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\esm\\geometry\\label\\polar.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\esm\\geometry\\label\\polar.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { each, isArray } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\nvar PolarLabel = /** @class */ (function (_super) {\n    __extends(PolarLabel, _super);\n    function PolarLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @override\n     * 获取文本的对齐方式\n     * @param point\n     */\n    PolarLabel.prototype.getLabelAlign = function (point) {\n        var coordinate = this.getCoordinate();\n        var align;\n        if (point.labelEmit) {\n            align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n        }\n        else if (!coordinate.isTransposed) {\n            align = 'center';\n        }\n        else {\n            var center = coordinate.getCenter();\n            var offset = this.getDefaultOffset(point.offset);\n            if (Math.abs(point.x - center.x) < 1) {\n                align = 'center';\n            }\n            else if (point.angle > Math.PI || point.angle <= 0) {\n                align = offset > 0 ? 'left' : 'right';\n            }\n            else {\n                align = offset > 0 ? 'right' : 'left';\n            }\n        }\n        return align;\n    };\n    /**\n     * @override\n     * 获取 label 的位置\n     * @param labelCfg\n     * @param mappingData\n     * @param index\n     */\n    PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n        var factor = 1;\n        var arcPoint;\n        var content = labelCfg.content[index];\n        if (this.isToMiddle(mappingData)) {\n            arcPoint = this.getMiddlePoint(mappingData.points);\n        }\n        else {\n            if (labelCfg.content.length === 1 && index === 0) {\n                index = 1;\n            }\n            else if (index === 0) {\n                factor = -1;\n            }\n            arcPoint = this.getArcPoint(mappingData, index);\n        }\n        var offset = this.getDefaultOffset(labelCfg.offset) * factor;\n        var middleAngle = this.getPointAngle(arcPoint);\n        var isLabelEmit = labelCfg.labelEmit;\n        var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n        if (labelPositionCfg.r === 0) {\n            // 如果文本位置位于圆心，则不展示\n            labelPositionCfg.content = '';\n        }\n        else {\n            labelPositionCfg.content = content;\n            labelPositionCfg.angle = middleAngle;\n            labelPositionCfg.color = mappingData.color;\n        }\n        labelPositionCfg.rotate = labelCfg.autoRotate\n            ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n            : labelCfg.rotate;\n        labelPositionCfg.start = {\n            x: arcPoint.x,\n            y: arcPoint.y,\n        };\n        return labelPositionCfg;\n    };\n    /**\n     * 获取圆弧的位置\n     */\n    PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n        if (index === void 0) { index = 0; }\n        if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n            return {\n                x: mappingData.x,\n                y: mappingData.y,\n            };\n        }\n        return {\n            x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n            y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n        };\n    };\n    /**\n     * 计算坐标线点在极坐标系下角度\n     * @param point\n     */\n    PolarLabel.prototype.getPointAngle = function (point) {\n        return getAngleByPoint(this.getCoordinate(), point);\n    };\n    /**\n     * 获取坐标点与圆心形成的圆的位置信息\n     * @param angle\n     * @param offset\n     * @param point\n     * @param isLabelEmit\n     */\n    PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n        var coordinate = this.getCoordinate();\n        var center = coordinate.getCenter();\n        var r = getDistanceToCenter(coordinate, point);\n        if (r === 0) {\n            return __assign(__assign({}, center), { r: r });\n        }\n        var labelAngle = angle;\n        if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n            var appendAngle = Math.asin(offset / (2 * r));\n            labelAngle = angle + appendAngle * 2;\n        }\n        else {\n            r = r + offset;\n        }\n        return {\n            x: center.x + r * Math.cos(labelAngle),\n            y: center.y + r * Math.sin(labelAngle),\n            r: r,\n        };\n    };\n    /**\n     * 获取 label 的旋转角度\n     * @param angle\n     * @param offset\n     * @param isLabelEmit\n     */\n    PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n        var rotate = angle + HALF_PI;\n        if (isLabelEmit) {\n            rotate -= HALF_PI;\n        }\n        if (rotate) {\n            if (rotate > HALF_PI) {\n                rotate = rotate - Math.PI;\n            }\n            else if (rotate < -HALF_PI) {\n                rotate = rotate + Math.PI;\n            }\n        }\n        return rotate;\n    };\n    // 获取中心的位置\n    PolarLabel.prototype.getMiddlePoint = function (points) {\n        var coordinate = this.getCoordinate();\n        var count = points.length;\n        var middlePoint = {\n            x: 0,\n            y: 0,\n        };\n        each(points, function (point) {\n            middlePoint.x += point.x;\n            middlePoint.y += point.y;\n        });\n        middlePoint.x /= count;\n        middlePoint.y /= count;\n        middlePoint = coordinate.convert(middlePoint);\n        return middlePoint;\n    };\n    // 是否居中\n    PolarLabel.prototype.isToMiddle = function (mappingData) {\n        return mappingData.x.length > 2;\n    };\n    return PolarLabel;\n}(GeometryLabel));\nexport default PolarLabel;\n//# sourceMappingURL=polar.js.map"]}]}