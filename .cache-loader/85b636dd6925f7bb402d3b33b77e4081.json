{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/order/index.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/order/index.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nvar _ = require(\"../lodash\");\nvar initOrder = require(\"./init-order\");\nvar crossCount = require(\"./cross-count\");\nvar sortSubgraph = require(\"./sort-subgraph\");\nvar buildLayerGraph = require(\"./build-layer-graph\");\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\nmodule.exports = order;\nfunction order(g) {\n    var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"), upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n    var layering = initOrder(g);\n    assignOrder(g, layering);\n    var bestCC = Number.POSITIVE_INFINITY, best;\n    for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n        layering = util.buildLayerMatrix(g);\n        var cc = crossCount(g, layering);\n        if (cc < bestCC) {\n            lastBest = 0;\n            best = _.cloneDeep(layering);\n            bestCC = cc;\n        }\n    }\n    assignOrder(g, best);\n}\nfunction buildLayerGraphs(g, ranks, relationship) {\n    return _.map(ranks, function (rank) {\n        return buildLayerGraph(g, rank, relationship);\n    });\n}\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n    var cg = new Graph();\n    _.forEach(layerGraphs, function (lg) {\n        var root = lg.graph().root;\n        var sorted = sortSubgraph(lg, root, cg, biasRight);\n        _.forEach(sorted.vs, function (v, i) {\n            lg.node(v).order = i;\n        });\n        addSubgraphConstraints(lg, cg, sorted.vs);\n    });\n}\nfunction assignOrder(g, layering) {\n    _.forEach(layering, function (layer) {\n        _.forEach(layer, function (v, i) {\n            g.node(v).order = i;\n        });\n    });\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/order/index.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/order/index.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar initOrder = require(\"./init-order\");\nvar crossCount = require(\"./cross-count\");\nvar sortSubgraph = require(\"./sort-subgraph\");\nvar buildLayerGraph = require(\"./build-layer-graph\");\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n"]}]}