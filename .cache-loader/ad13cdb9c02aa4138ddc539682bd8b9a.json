{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\lib\\chart\\controller\\gesture.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\lib\\chart\\controller\\gesture.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar PRESS_DELAY = 250;\r\nvar calcDirection = function (start, end) {\r\n    var xDistance = end.x - start.x;\r\n    var yDistance = end.y - start.y;\r\n    if (Math.abs(xDistance) > Math.abs(yDistance)) {\r\n        return xDistance > 0 ? 'right' : 'left';\r\n    }\r\n    return yDistance > 0 ? 'down' : 'up';\r\n};\r\nvar calcDistance = function (point1, point2) {\r\n    var xDistance = Math.abs(point2.x - point1.x);\r\n    var yDistance = Math.abs(point2.y - point1.y);\r\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\r\n};\r\nvar getCenter = function (point1, point2) {\r\n    var x = (point1.x + point2.x) / 2;\r\n    var y = (point1.y + point2.y) / 2;\r\n    return { x: x, y: y };\r\n};\r\nvar convertPoints = function (touches, canvas) {\r\n    if (!touches) {\r\n        return;\r\n    }\r\n    var points = [];\r\n    var len = touches.length;\r\n    for (var i = 0; i < len; i++) {\r\n        var touch = touches[i];\r\n        var clientX = touch.clientX, clientY = touch.clientY;\r\n        var point = canvas.getPointByClient(clientX, clientY);\r\n        points.push(point);\r\n    }\r\n    return points;\r\n};\r\nvar GestureController = (function (_super) {\r\n    tslib_1.__extends(GestureController, _super);\r\n    function GestureController(view) {\r\n        var _this = _super.call(this, view) || this;\r\n        _this.processEvent = {};\r\n        _this.touchStart = function (ev) {\r\n            var points = convertPoints(ev.originalEvent.touches, _this.canvas);\r\n            if (!points) {\r\n                return;\r\n            }\r\n            ev.points = points;\r\n            _this.reset();\r\n            _this.startTime = Date.now();\r\n            _this.startPoints = points;\r\n            if (points.length > 1) {\r\n                _this.startDistance = calcDistance(points[0], points[1]);\r\n                _this.center = getCenter(points[0], points[1]);\r\n            }\r\n            else {\r\n                _this.pressTimeout = setTimeout(function () {\r\n                    var eventType = 'press';\r\n                    ev.direction = 'none';\r\n                    _this.emitStart(eventType, ev);\r\n                    _this.emitEvent(eventType, ev);\r\n                    _this.eventType = eventType;\r\n                }, PRESS_DELAY);\r\n            }\r\n        };\r\n        _this.touchMove = function (ev) {\r\n            var points = convertPoints(ev.originalEvent.touches, _this.canvas);\r\n            if (!points) {\r\n                return;\r\n            }\r\n            _this.clearPressTimeout();\r\n            ev.points = points;\r\n            var startPoints = _this.startPoints;\r\n            if (!startPoints) {\r\n                return;\r\n            }\r\n            if (points.length > 1) {\r\n                var startDistance = _this.startDistance;\r\n                var currentDistance = calcDistance(points[0], points[1]);\r\n                ev.zoom = currentDistance / startDistance;\r\n                ev.center = _this.center;\r\n                _this.emitStart('pinch', ev);\r\n                _this.emitEvent('pinch', ev);\r\n            }\r\n            else {\r\n                var deltaX = points[0].x - startPoints[0].x;\r\n                var deltaY = points[0].y - startPoints[0].y;\r\n                var direction = _this.direction || calcDirection(startPoints[0], points[0]);\r\n                _this.direction = direction;\r\n                var eventType = _this.getEventType(points);\r\n                ev.direction = direction;\r\n                ev.deltaX = deltaX;\r\n                ev.deltaY = deltaY;\r\n                _this.emitStart(eventType, ev);\r\n                _this.emitEvent(eventType, ev);\r\n                var prevMoveTime = _this.lastMoveTime;\r\n                var now = Date.now();\r\n                if (now - prevMoveTime > 0) {\r\n                    _this.prevMoveTime = prevMoveTime;\r\n                    _this.prevMovePoints = _this.lastMovePoints;\r\n                    _this.lastMoveTime = now;\r\n                    _this.lastMovePoints = points;\r\n                }\r\n            }\r\n        };\r\n        _this.touchEnd = function (ev) {\r\n            _this.emitEnd(ev);\r\n            var lastMoveTime = _this.lastMoveTime;\r\n            var now = Date.now();\r\n            if (now - lastMoveTime < 100) {\r\n                var prevMoveTime = _this.prevMoveTime || _this.startTime;\r\n                var intervalTime = lastMoveTime - prevMoveTime;\r\n                if (intervalTime > 0) {\r\n                    var prevMovePoints = _this.prevMovePoints || _this.startPoints;\r\n                    var lastMovePoints = _this.lastMovePoints;\r\n                    var velocity = calcDistance(prevMovePoints[0], lastMovePoints[0]) / intervalTime;\r\n                    if (velocity > 0.3) {\r\n                        ev.velocity = velocity;\r\n                        ev.direction = calcDirection(prevMovePoints[0], lastMovePoints[0]);\r\n                        _this.emitEvent('swipe', ev);\r\n                    }\r\n                }\r\n            }\r\n            _this.reset();\r\n            var touches = ev.touches;\r\n            if (touches && touches.length > 0) {\r\n                _this.touchStart(ev);\r\n            }\r\n        };\r\n        _this.canvas = view.getCanvas();\r\n        _this.delegateEvent();\r\n        _this.processEvent = {};\r\n        return _this;\r\n    }\r\n    Object.defineProperty(GestureController.prototype, \"name\", {\r\n        get: function () {\r\n            return 'gesture';\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    GestureController.prototype.init = function () { };\r\n    GestureController.prototype.render = function () { };\r\n    GestureController.prototype.layout = function () { };\r\n    GestureController.prototype.update = function () { };\r\n    GestureController.prototype.destroy = function () {\r\n        this.reset();\r\n        this.offEvent();\r\n        this.processEvent = null;\r\n    };\r\n    GestureController.prototype.delegateEvent = function () {\r\n        this.canvas.on('touchstart', this.touchStart);\r\n        this.canvas.on('touchmove', this.touchMove);\r\n        this.canvas.on('touchend', this.touchEnd);\r\n    };\r\n    GestureController.prototype.offEvent = function () {\r\n        this.canvas.off('touchstart', this.touchStart);\r\n        this.canvas.off('touchmove', this.touchMove);\r\n        this.canvas.off('touchend', this.touchEnd);\r\n    };\r\n    GestureController.prototype.emitEvent = function (type, ev) {\r\n        var view = this.view;\r\n        view.emit(type, ev);\r\n    };\r\n    GestureController.prototype.emitStart = function (type, ev) {\r\n        if (this.isProcess(type)) {\r\n            return;\r\n        }\r\n        this.enable(type);\r\n        this.emitEvent(type + \"start\", ev);\r\n    };\r\n    GestureController.prototype.emitEnd = function (ev) {\r\n        var _this = this;\r\n        var processEvent = this.processEvent;\r\n        Object.keys(processEvent).forEach(function (type) {\r\n            _this.emitEvent(type + \"end\", ev);\r\n            delete processEvent[type];\r\n        });\r\n    };\r\n    GestureController.prototype.enable = function (eventType) {\r\n        this.processEvent[eventType] = true;\r\n    };\r\n    GestureController.prototype.isProcess = function (eventType) {\r\n        return this.processEvent[eventType];\r\n    };\r\n    GestureController.prototype.reset = function () {\r\n        this.clearPressTimeout();\r\n        this.startTime = 0;\r\n        this.startPoints = null;\r\n        this.startDistance = 0;\r\n        this.direction = null;\r\n        this.eventType = null;\r\n        this.prevMoveTime = 0;\r\n        this.prevMovePoints = null;\r\n        this.lastMoveTime = 0;\r\n        this.lastMovePoints = null;\r\n    };\r\n    GestureController.prototype.clearPressTimeout = function () {\r\n        if (this.pressTimeout) {\r\n            clearTimeout(this.pressTimeout);\r\n            this.pressTimeout = 0;\r\n        }\r\n    };\r\n    GestureController.prototype.getEventType = function (points) {\r\n        var _a = this, eventType = _a.eventType, view = _a.view, startTime = _a.startTime, startPoints = _a.startPoints;\r\n        if (eventType) {\r\n            return eventType;\r\n        }\r\n        var type;\r\n        var panEventListeners = view.getEvents().pan;\r\n        if (!panEventListeners || !panEventListeners.length) {\r\n            type = 'press';\r\n        }\r\n        else {\r\n            var now = Date.now();\r\n            if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], points[0]) < 10) {\r\n                type = 'press';\r\n            }\r\n            else {\r\n                type = 'pan';\r\n            }\r\n        }\r\n        this.eventType = type;\r\n        return type;\r\n    };\r\n    return GestureController;\r\n}(base_1.Controller));\r\nexports.default = GestureController;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\lib\\chart\\controller\\gesture.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\g2\\lib\\chart\\controller\\gesture.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar PRESS_DELAY = 250;\n// 计算滑动的方向\nvar calcDirection = function (start, end) {\n    var xDistance = end.x - start.x;\n    var yDistance = end.y - start.y;\n    // x 的距离大于y 说明是横向，否则就是纵向\n    if (Math.abs(xDistance) > Math.abs(yDistance)) {\n        return xDistance > 0 ? 'right' : 'left';\n    }\n    return yDistance > 0 ? 'down' : 'up';\n};\n// 计算2点之间的距离\nvar calcDistance = function (point1, point2) {\n    var xDistance = Math.abs(point2.x - point1.x);\n    var yDistance = Math.abs(point2.y - point1.y);\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n};\nvar getCenter = function (point1, point2) {\n    var x = (point1.x + point2.x) / 2;\n    var y = (point1.y + point2.y) / 2;\n    return { x: x, y: y };\n};\nvar convertPoints = function (touches, canvas) {\n    if (!touches) {\n        return;\n    }\n    var points = [];\n    var len = touches.length;\n    for (var i = 0; i < len; i++) {\n        var touch = touches[i];\n        // x, y: 相对canvas原点的位置，clientX, clientY 相对于可视窗口的位置\n        var clientX = touch.clientX, clientY = touch.clientY;\n        var point = canvas.getPointByClient(clientX, clientY);\n        points.push(point);\n    }\n    return points;\n};\nvar GestureController = /** @class */ (function (_super) {\n    tslib_1.__extends(GestureController, _super);\n    function GestureController(view) {\n        var _this = _super.call(this, view) || this;\n        _this.processEvent = {};\n        _this.touchStart = function (ev) {\n            var points = convertPoints(ev.originalEvent.touches, _this.canvas);\n            if (!points) {\n                return;\n            }\n            ev.points = points;\n            // 防止上次的内容没有清理掉，重新reset下\n            _this.reset();\n            // 记录touch start 的时间\n            _this.startTime = Date.now();\n            // 记录touch start 的点\n            _this.startPoints = points;\n            if (points.length > 1) {\n                _this.startDistance = calcDistance(points[0], points[1]);\n                _this.center = getCenter(points[0], points[1]);\n            }\n            else {\n                // 如果touchstart后停顿250ms, 则也触发press事件\n                _this.pressTimeout = setTimeout(function () {\n                    // 这里固定触发press事件\n                    var eventType = 'press';\n                    ev.direction = 'none';\n                    _this.emitStart(eventType, ev);\n                    _this.emitEvent(eventType, ev);\n                    _this.eventType = eventType;\n                }, PRESS_DELAY);\n            }\n        };\n        _this.touchMove = function (ev) {\n            var points = convertPoints(ev.originalEvent.touches, _this.canvas);\n            if (!points) {\n                return;\n            }\n            _this.clearPressTimeout();\n            ev.points = points;\n            var startPoints = _this.startPoints;\n            if (!startPoints) {\n                return;\n            }\n            // 多指触控\n            if (points.length > 1) {\n                // touchstart的距离\n                var startDistance = _this.startDistance;\n                var currentDistance = calcDistance(points[0], points[1]);\n                ev.zoom = currentDistance / startDistance;\n                ev.center = _this.center;\n                // 触发缩放事件\n                _this.emitStart('pinch', ev);\n                _this.emitEvent('pinch', ev);\n            }\n            else {\n                var deltaX = points[0].x - startPoints[0].x;\n                var deltaY = points[0].y - startPoints[0].y;\n                var direction = _this.direction || calcDirection(startPoints[0], points[0]);\n                _this.direction = direction;\n                // 获取press或者pan的事件类型\n                // press 按住滑动, pan表示平移\n                // 如果start后立刻move，则触发pan, 如果有停顿，则触发press\n                var eventType = _this.getEventType(points);\n                ev.direction = direction;\n                ev.deltaX = deltaX;\n                ev.deltaY = deltaY;\n                _this.emitStart(eventType, ev);\n                _this.emitEvent(eventType, ev);\n                // 记录最后2次move的时间和坐标，为了给swipe事件用\n                var prevMoveTime = _this.lastMoveTime;\n                var now = Date.now();\n                // 最后2次的时间间隔一定要大于0，否则swipe没发计算\n                if (now - prevMoveTime > 0) {\n                    _this.prevMoveTime = prevMoveTime;\n                    _this.prevMovePoints = _this.lastMovePoints;\n                    _this.lastMoveTime = now;\n                    _this.lastMovePoints = points;\n                }\n            }\n        };\n        _this.touchEnd = function (ev) {\n            _this.emitEnd(ev);\n            // swipe事件处理, 在touchend之后触发\n            var lastMoveTime = _this.lastMoveTime;\n            var now = Date.now();\n            // 做这个判断是为了最后一次touchmove后到end前，还有一个停顿的过程\n            // 100 是拍的一个值，理论这个值会很短，一般不卡顿的话在10ms以内\n            if (now - lastMoveTime < 100) {\n                var prevMoveTime = _this.prevMoveTime || _this.startTime;\n                var intervalTime = lastMoveTime - prevMoveTime;\n                // 时间间隔一定要大于0, 否则计算没意义\n                if (intervalTime > 0) {\n                    var prevMovePoints = _this.prevMovePoints || _this.startPoints;\n                    var lastMovePoints = _this.lastMovePoints;\n                    // move速率\n                    var velocity = calcDistance(prevMovePoints[0], lastMovePoints[0]) / intervalTime;\n                    // 0.3 是参考hammerjs的设置\n                    if (velocity > 0.3) {\n                        ev.velocity = velocity;\n                        ev.direction = calcDirection(prevMovePoints[0], lastMovePoints[0]);\n                        _this.emitEvent('swipe', ev);\n                    }\n                }\n            }\n            _this.reset();\n            var touches = ev.touches;\n            // 当多指只释放了1指时也会触发end, 这时重新触发一次start\n            if (touches && touches.length > 0) {\n                _this.touchStart(ev);\n            }\n        };\n        _this.canvas = view.getCanvas();\n        _this.delegateEvent();\n        // 用来记录当前触发的事件\n        _this.processEvent = {};\n        return _this;\n    }\n    Object.defineProperty(GestureController.prototype, \"name\", {\n        get: function () {\n            return 'gesture';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    GestureController.prototype.init = function () { };\n    GestureController.prototype.render = function () { };\n    GestureController.prototype.layout = function () { };\n    GestureController.prototype.update = function () { };\n    GestureController.prototype.destroy = function () {\n        this.reset();\n        this.offEvent();\n        this.processEvent = null;\n    };\n    GestureController.prototype.delegateEvent = function () {\n        // 代理这几个事件\n        this.canvas.on('touchstart', this.touchStart);\n        this.canvas.on('touchmove', this.touchMove);\n        this.canvas.on('touchend', this.touchEnd);\n    };\n    GestureController.prototype.offEvent = function () {\n        this.canvas.off('touchstart', this.touchStart);\n        this.canvas.off('touchmove', this.touchMove);\n        this.canvas.off('touchend', this.touchEnd);\n    };\n    GestureController.prototype.emitEvent = function (type, ev) {\n        var view = this.view;\n        view.emit(type, ev);\n    };\n    // 触发start事件\n    GestureController.prototype.emitStart = function (type, ev) {\n        if (this.isProcess(type)) {\n            return;\n        }\n        this.enable(type);\n        this.emitEvent(type + \"start\", ev);\n    };\n    // 触发end事件\n    GestureController.prototype.emitEnd = function (ev) {\n        var _this = this;\n        var processEvent = this.processEvent;\n        Object.keys(processEvent).forEach(function (type) {\n            _this.emitEvent(type + \"end\", ev);\n            delete processEvent[type];\n        });\n    };\n    GestureController.prototype.enable = function (eventType) {\n        this.processEvent[eventType] = true;\n    };\n    // 是否进行中的事件\n    GestureController.prototype.isProcess = function (eventType) {\n        return this.processEvent[eventType];\n    };\n    GestureController.prototype.reset = function () {\n        this.clearPressTimeout();\n        this.startTime = 0;\n        this.startPoints = null;\n        this.startDistance = 0;\n        this.direction = null;\n        this.eventType = null;\n        this.prevMoveTime = 0;\n        this.prevMovePoints = null;\n        this.lastMoveTime = 0;\n        this.lastMovePoints = null;\n    };\n    GestureController.prototype.clearPressTimeout = function () {\n        if (this.pressTimeout) {\n            clearTimeout(this.pressTimeout);\n            this.pressTimeout = 0;\n        }\n    };\n    GestureController.prototype.getEventType = function (points) {\n        var _a = this, eventType = _a.eventType, view = _a.view, startTime = _a.startTime, startPoints = _a.startPoints;\n        if (eventType) {\n            return eventType;\n        }\n        var type;\n        var panEventListeners = view.getEvents().pan;\n        // 如果 view 上没有 pan 事件的监听，默认都是 press\n        if (!panEventListeners || !panEventListeners.length) {\n            type = 'press';\n        }\n        else {\n            // 如果有pan事件的处理，press则需要停顿250ms, 且移动距离小于10\n            var now = Date.now();\n            if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], points[0]) < 10) {\n                type = 'press';\n            }\n            else {\n                type = 'pan';\n            }\n        }\n        this.eventType = type;\n        return type;\n    };\n    return GestureController;\n}(base_1.Controller));\nexports.default = GestureController;\n//# sourceMappingURL=gesture.js.map"]}]}