{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\cross-count.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\cross-count.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nvar _ = require(\"../lodash\");\r\nmodule.exports = crossCount;\r\nfunction crossCount(g, layering) {\r\n    var cc = 0;\r\n    for (var i = 1; i < layering.length; ++i) {\r\n        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\r\n    }\r\n    return cc;\r\n}\r\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\r\n    var southPos = _.zipObject(southLayer, _.map(southLayer, function (v, i) { return i; }));\r\n    var southEntries = _.flatten(_.map(northLayer, function (v) {\r\n        return _.chain(g.outEdges(v))\r\n            .map(function (e) {\r\n            return { pos: southPos[e.w], weight: g.edge(e).weight };\r\n        })\r\n            .sortBy(\"pos\")\r\n            .value();\r\n    }), true);\r\n    var firstIndex = 1;\r\n    while (firstIndex < southLayer.length)\r\n        firstIndex <<= 1;\r\n    var treeSize = 2 * firstIndex - 1;\r\n    firstIndex -= 1;\r\n    var tree = _.map(new Array(treeSize), function () { return 0; });\r\n    var cc = 0;\r\n    _.forEach(southEntries.forEach(function (entry) {\r\n        var index = entry.pos + firstIndex;\r\n        tree[index] += entry.weight;\r\n        var weightSum = 0;\r\n        while (index > 0) {\r\n            if (index % 2) {\r\n                weightSum += tree[index + 1];\r\n            }\r\n            index = (index - 1) >> 1;\r\n            tree[index] += entry.weight;\r\n        }\r\n        cc += entry.weight * weightSum;\r\n    }));\r\n    return cc;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\cross-count.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\cross-count.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAEb,IAAI,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC;AAE7B,MAAM,CAAC,OAAO,GAAG,UAAU,CAAC;AAkB5B,SAAS,UAAU,CAAC,CAAC,EAAE,QAAQ;IAC7B,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QACxC,EAAE,IAAI,kBAAkB,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;KACzD;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,SAAS,kBAAkB,CAAC,CAAC,EAAE,UAAU,EAAE,UAAU;IAInD,IAAI,QAAQ,GAAG,CAAC,CAAC,SAAS,CAAC,UAAU,EACV,CAAC,CAAC,GAAG,CAAC,UAAU,EAAE,UAAU,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7E,IAAI,YAAY,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,EAAE,UAAS,CAAC;QACvD,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;aACpB,GAAG,CAAC,UAAS,CAAC;YACb,OAAO,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;QAC1D,CAAC,CAAC;aACD,MAAM,CAAC,KAAK,CAAC;aACb,KAAK,EAAE,CAAC;IACnB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAGV,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,OAAO,UAAU,GAAG,UAAU,CAAC,MAAM;QAAE,UAAU,KAAK,CAAC,CAAC;IACxD,IAAI,QAAQ,GAAG,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC;IAClC,UAAU,IAAI,CAAC,CAAC;IAChB,IAAI,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,cAAa,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAGhE,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC,UAAS,KAAK;QAC3C,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,UAAU,CAAC;QACnC,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;QAC5B,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,OAAO,KAAK,GAAG,CAAC,EAAE;YAChB,IAAI,KAAK,GAAG,CAAC,EAAE;gBACb,SAAS,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;aAC9B;YACD,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;YACzB,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;SAC7B;QACD,EAAE,IAAI,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;IACjC,CAAC,CAAC,CAAC,CAAC;IAEJ,OAAO,EAAE,CAAC;AACZ,CAAC","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer,\n                             _.map(southLayer, function (v, i) { return i; }));\n  var southEntries = _.flatten(_.map(northLayer, function(v) {\n    return _.chain(g.outEdges(v))\n            .map(function(e) {\n              return { pos: southPos[e.w], weight: g.edge(e).weight };\n            })\n            .sortBy(\"pos\")\n            .value();\n  }), true);\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function() { return 0; });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(southEntries.forEach(function(entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = (index - 1) >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}\n"]}]}