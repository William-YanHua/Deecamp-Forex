{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\tree.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\tree.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { Node } from \"./hierarchy/index\";\r\nfunction defaultSeparation(a, b) {\r\n    return a.parent === b.parent ? 1 : 2;\r\n}\r\nfunction nextLeft(v) {\r\n    var children = v.children;\r\n    return children ? children[0] : v.t;\r\n}\r\nfunction nextRight(v) {\r\n    var children = v.children;\r\n    return children ? children[children.length - 1] : v.t;\r\n}\r\nfunction moveSubtree(wm, wp, shift) {\r\n    var change = shift / (wp.i - wm.i);\r\n    wp.c -= change;\r\n    wp.s += shift;\r\n    wm.c += change;\r\n    wp.z += shift;\r\n    wp.m += shift;\r\n}\r\nfunction executeShifts(v) {\r\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\r\n    while (--i >= 0) {\r\n        w = children[i];\r\n        w.z += shift;\r\n        w.m += shift;\r\n        shift += w.s + (change += w.c);\r\n    }\r\n}\r\nfunction nextAncestor(vim, v, ancestor) {\r\n    return vim.a.parent === v.parent ? vim.a : ancestor;\r\n}\r\nfunction TreeNode(node, i) {\r\n    this._ = node;\r\n    this.parent = null;\r\n    this.children = null;\r\n    this.A = null;\r\n    this.a = this;\r\n    this.z = 0;\r\n    this.m = 0;\r\n    this.c = 0;\r\n    this.s = 0;\r\n    this.t = null;\r\n    this.i = i;\r\n}\r\nTreeNode.prototype = Object.create(Node.prototype);\r\nfunction treeRoot(root) {\r\n    var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;\r\n    while (node = nodes.pop()) {\r\n        if (children = node._.children) {\r\n            node.children = new Array(n = children.length);\r\n            for (i = n - 1; i >= 0; --i) {\r\n                nodes.push(child = node.children[i] = new TreeNode(children[i], i));\r\n                child.parent = node;\r\n            }\r\n        }\r\n    }\r\n    (tree.parent = new TreeNode(null, 0)).children = [tree];\r\n    return tree;\r\n}\r\nexport default function () {\r\n    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;\r\n    function tree(root) {\r\n        var t = treeRoot(root);\r\n        t.eachAfter(firstWalk), t.parent.m = -t.z;\r\n        t.eachBefore(secondWalk);\r\n        if (nodeSize)\r\n            root.eachBefore(sizeNode);\r\n        else {\r\n            var left = root, right = root, bottom = root;\r\n            root.eachBefore(function (node) {\r\n                if (node.x < left.x)\r\n                    left = node;\r\n                if (node.x > right.x)\r\n                    right = node;\r\n                if (node.depth > bottom.depth)\r\n                    bottom = node;\r\n            });\r\n            var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);\r\n            root.eachBefore(function (node) {\r\n                node.x = (node.x + tx) * kx;\r\n                node.y = node.depth * ky;\r\n            });\r\n        }\r\n        return root;\r\n    }\r\n    function firstWalk(v) {\r\n        var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\r\n        if (children) {\r\n            executeShifts(v);\r\n            var midpoint = (children[0].z + children[children.length - 1].z) / 2;\r\n            if (w) {\r\n                v.z = w.z + separation(v._, w._);\r\n                v.m = v.z - midpoint;\r\n            }\r\n            else {\r\n                v.z = midpoint;\r\n            }\r\n        }\r\n        else if (w) {\r\n            v.z = w.z + separation(v._, w._);\r\n        }\r\n        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\r\n    }\r\n    function secondWalk(v) {\r\n        v._.x = v.z + v.parent.m;\r\n        v.m += v.parent.m;\r\n    }\r\n    function apportion(v, w, ancestor) {\r\n        if (w) {\r\n            var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\r\n            while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\r\n                vom = nextLeft(vom);\r\n                vop = nextRight(vop);\r\n                vop.a = v;\r\n                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\r\n                if (shift > 0) {\r\n                    moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\r\n                    sip += shift;\r\n                    sop += shift;\r\n                }\r\n                sim += vim.m;\r\n                sip += vip.m;\r\n                som += vom.m;\r\n                sop += vop.m;\r\n            }\r\n            if (vim && !nextRight(vop)) {\r\n                vop.t = vim;\r\n                vop.m += sim - sop;\r\n            }\r\n            if (vip && !nextLeft(vom)) {\r\n                vom.t = vip;\r\n                vom.m += sip - som;\r\n                ancestor = v;\r\n            }\r\n        }\r\n        return ancestor;\r\n    }\r\n    function sizeNode(node) {\r\n        node.x *= dx;\r\n        node.y = node.depth * dy;\r\n    }\r\n    tree.separation = function (x) {\r\n        return arguments.length ? (separation = x, tree) : separation;\r\n    };\r\n    tree.size = function (x) {\r\n        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\r\n    };\r\n    tree.nodeSize = function (x) {\r\n        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\r\n    };\r\n    return tree;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\tree.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\tree.js"],"names":[],"mappings":"AAAA,OAAO,EAAC,IAAI,EAAC,MAAM,mBAAmB,CAAC;AAEvC,SAAS,iBAAiB,CAAC,CAAC,EAAE,CAAC;IAC7B,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC,CAAC;AAUD,SAAS,QAAQ,CAAC,CAAC;IACjB,IAAI,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;IAC1B,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,CAAC;AAGD,SAAS,SAAS,CAAC,CAAC;IAClB,IAAI,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;IAC1B,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC;AAID,SAAS,WAAW,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK;IAChC,IAAI,MAAM,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACnC,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC;IACf,EAAE,CAAC,CAAC,IAAI,KAAK,CAAC;IACd,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC;IACf,EAAE,CAAC,CAAC,IAAI,KAAK,CAAC;IACd,EAAE,CAAC,CAAC,IAAI,KAAK,CAAC;AAChB,CAAC;AAKD,SAAS,aAAa,CAAC,CAAC;IACtB,IAAI,KAAK,GAAG,CAAC,EACT,MAAM,GAAG,CAAC,EACV,QAAQ,GAAG,CAAC,CAAC,QAAQ,EACrB,CAAC,GAAG,QAAQ,CAAC,MAAM,EACnB,CAAC,CAAC;IACN,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE;QACf,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;QACb,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;QACb,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;KAChC;AACH,CAAC;AAID,SAAS,YAAY,CAAC,GAAG,EAAE,CAAC,EAAE,QAAQ;IACpC,OAAO,GAAG,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;AACtD,CAAC;AAED,SAAS,QAAQ,CAAC,IAAI,EAAE,CAAC;IACvB,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;IACd,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;IACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACrB,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;IACd,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;IACd,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACX,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;IACd,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;AACb,CAAC;AAED,QAAQ,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAEnD,SAAS,QAAQ,CAAC,IAAI;IACpB,IAAI,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAC5B,IAAI,EACJ,KAAK,GAAG,CAAC,IAAI,CAAC,EACd,KAAK,EACL,QAAQ,EACR,CAAC,EACD,CAAC,CAAC;IAEN,OAAO,IAAI,GAAG,KAAK,CAAC,GAAG,EAAE,EAAE;QACzB,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE;YAC9B,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC/C,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;gBAC3B,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACpE,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;aACrB;SACF;KACF;IAED,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC;IACxD,OAAO,IAAI,CAAC;AACd,CAAC;AAGD,MAAM,CAAC,OAAO;IACZ,IAAI,UAAU,GAAG,iBAAiB,EAC9B,EAAE,GAAG,CAAC,EACN,EAAE,GAAG,CAAC,EACN,QAAQ,GAAG,IAAI,CAAC;IAEpB,SAAS,IAAI,CAAC,IAAI;QAChB,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAGvB,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1C,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QAGzB,IAAI,QAAQ;YAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;aAInC;YACH,IAAI,IAAI,GAAG,IAAI,EACX,KAAK,GAAG,IAAI,EACZ,MAAM,GAAG,IAAI,CAAC;YAClB,IAAI,CAAC,UAAU,CAAC,UAAS,IAAI;gBAC3B,IAAI,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;oBAAE,IAAI,GAAG,IAAI,CAAC;gBACjC,IAAI,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;oBAAE,KAAK,GAAG,IAAI,CAAC;gBACnC,IAAI,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK;oBAAE,MAAM,GAAG,IAAI,CAAC;YAC/C,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,GAAG,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,EACpD,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC,EACf,EAAE,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,EAC5B,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,UAAU,CAAC,UAAS,IAAI;gBAC3B,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;gBAC5B,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;YAC3B,CAAC,CAAC,CAAC;SACJ;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAMD,SAAS,SAAS,CAAC,CAAC;QAClB,IAAI,QAAQ,GAAG,CAAC,CAAC,QAAQ,EACrB,QAAQ,GAAG,CAAC,CAAC,MAAM,CAAC,QAAQ,EAC5B,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QACvC,IAAI,QAAQ,EAAE;YACZ,aAAa,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,QAAQ,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACrE,IAAI,CAAC,EAAE;gBACL,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;aACtB;iBAAM;gBACL,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;aAChB;SACF;aAAM,IAAI,CAAC,EAAE;YACZ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SAClC;QACD,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1D,CAAC;IAGD,SAAS,UAAU,CAAC,CAAC;QACnB,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;IACpB,CAAC;IAaD,SAAS,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ;QAC/B,IAAI,CAAC,EAAE;YACL,IAAI,GAAG,GAAG,CAAC,EACP,GAAG,GAAG,CAAC,EACP,GAAG,GAAG,CAAC,EACP,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAC5B,GAAG,GAAG,GAAG,CAAC,CAAC,EACX,GAAG,GAAG,GAAG,CAAC,CAAC,EACX,GAAG,GAAG,GAAG,CAAC,CAAC,EACX,GAAG,GAAG,GAAG,CAAC,CAAC,EACX,KAAK,CAAC;YACV,OAAO,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,EAAE,GAAG,IAAI,GAAG,EAAE;gBAC5D,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;gBACpB,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;gBACrB,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;gBACV,KAAK,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC7D,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,WAAW,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;oBACtD,GAAG,IAAI,KAAK,CAAC;oBACb,GAAG,IAAI,KAAK,CAAC;iBACd;gBACD,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;gBACb,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;gBACb,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;gBACb,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC;aACd;YACD,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;gBAC1B,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;gBACZ,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC;aACpB;YACD,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBACzB,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;gBACZ,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,GAAG,CAAC;gBACnB,QAAQ,GAAG,CAAC,CAAC;aACd;SACF;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,SAAS,QAAQ,CAAC,IAAI;QACpB,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;QACb,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IAC3B,CAAC;IAED,IAAI,CAAC,UAAU,GAAG,UAAS,CAAC;QAC1B,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;IAChE,CAAC,CAAC;IAEF,IAAI,CAAC,IAAI,GAAG,UAAS,CAAC;QACpB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,KAAK,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;IAC5G,CAAC,CAAC;IAEF,IAAI,CAAC,QAAQ,GAAG,UAAS,CAAC;QACxB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IAC3G,CAAC,CAAC;IAEF,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import {Node} from \"./hierarchy/index\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n"]}]}