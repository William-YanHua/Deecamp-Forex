{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/shapes/path.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/shapes/path.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var Util = require('../util/index');\nvar Shape = require('../core/shape');\nvar PathSegment = require('./util/path-segment');\nvar Format = require('../util/format');\nvar Arrow = require('./util/arrow');\nvar PathUtil = require('../util/path');\nvar CubicMath = require('./math/cubic');\nvar Path = function Path(cfg) {\n    Path.superclass.constructor.call(this, cfg);\n};\nPath.ATTRS = {\n    path: null,\n    lineWidth: 1,\n    startArrow: false,\n    endArrow: false\n};\nUtil.extend(Path, Shape);\nUtil.augment(Path, {\n    canFill: true,\n    canStroke: true,\n    type: 'path',\n    getDefaultAttrs: function getDefaultAttrs() {\n        return {\n            lineWidth: 1,\n            startArrow: false,\n            endArrow: false\n        };\n    },\n    _afterSetAttrPath: function _afterSetAttrPath(path) {\n        var self = this;\n        if (Util.isNil(path)) {\n            self.setSilent('segments', null);\n            self.setSilent('box', undefined);\n            return;\n        }\n        var pathArray = Format.parsePath(path);\n        var preSegment;\n        var segments = [];\n        if (!Util.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {\n            return;\n        }\n        var count = pathArray.length;\n        for (var i = 0; i < pathArray.length; i++) {\n            var item = pathArray[i];\n            preSegment = new PathSegment(item, preSegment, i === count - 1);\n            segments.push(preSegment);\n        }\n        self.setSilent('segments', segments);\n        self.setSilent('tCache', null);\n        self.setSilent('box', null);\n    },\n    calculateBox: function calculateBox() {\n        var self = this;\n        var segments = self.get('segments');\n        if (!segments) {\n            return null;\n        }\n        var lineWidth = this.getHitLineWidth();\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var minY = Infinity;\n        var maxY = -Infinity;\n        Util.each(segments, function (segment) {\n            segment.getBBox(lineWidth);\n            var box = segment.box;\n            if (box) {\n                if (box.minX < minX) {\n                    minX = box.minX;\n                }\n                if (box.maxX > maxX) {\n                    maxX = box.maxX;\n                }\n                if (box.minY < minY) {\n                    minY = box.minY;\n                }\n                if (box.maxY > maxY) {\n                    maxY = box.maxY;\n                }\n            }\n        });\n        if (minX === Infinity || minY === Infinity) {\n            return {\n                minX: 0,\n                minY: 0,\n                maxX: 0,\n                maxY: 0\n            };\n        }\n        return {\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY\n        };\n    },\n    _setTcache: function _setTcache() {\n        var totalLength = 0;\n        var tempLength = 0;\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        var segmentN;\n        var l;\n        var curve = this._cfg.curve;\n        if (!curve) {\n            return;\n        }\n        Util.each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n            }\n        });\n        Util.each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n                tempLength += segmentL;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this._cfg.tCache = tCache;\n    },\n    _calculateCurve: function _calculateCurve() {\n        var self = this;\n        var attrs = self._attrs;\n        var path = attrs.path;\n        this._cfg.curve = PathUtil.pathTocurve(path);\n    },\n    getStartTangent: function getStartTangent() {\n        var segments = this.get('segments');\n        var startPoint, endPoint, tangent, result;\n        if (segments.length > 1) {\n            startPoint = segments[0].endPoint;\n            endPoint = segments[1].endPoint;\n            tangent = segments[1].startTangent;\n            result = [];\n            if (Util.isFunction(tangent)) {\n                var v = tangent();\n                result.push([startPoint.x - v[0], startPoint.y - v[1]]);\n                result.push([startPoint.x, startPoint.y]);\n            }\n            else {\n                result.push([endPoint.x, endPoint.y]);\n                result.push([startPoint.x, startPoint.y]);\n            }\n        }\n        return result;\n    },\n    getEndTangent: function getEndTangent() {\n        var segments = this.get('segments');\n        var segmentsLen = segments.length;\n        var startPoint, endPoint, tangent, result;\n        if (segmentsLen > 1) {\n            startPoint = segments[segmentsLen - 2].endPoint;\n            endPoint = segments[segmentsLen - 1].endPoint;\n            tangent = segments[segmentsLen - 1].endTangent;\n            result = [];\n            if (Util.isFunction(tangent)) {\n                var v = tangent();\n                result.push([endPoint.x - v[0], endPoint.y - v[1]]);\n                result.push([endPoint.x, endPoint.y]);\n            }\n            else {\n                result.push([startPoint.x, startPoint.y]);\n                result.push([endPoint.x, endPoint.y]);\n            }\n        }\n        return result;\n    },\n    getPoint: function getPoint(t) {\n        var tCache = this._cfg.tCache;\n        var subt;\n        var index;\n        if (!tCache) {\n            this._calculateCurve();\n            this._setTcache();\n            tCache = this._cfg.tCache;\n        }\n        var curve = this._cfg.curve;\n        if (!tCache) {\n            if (curve) {\n                return {\n                    x: curve[0][1],\n                    y: curve[0][2]\n                };\n            }\n            return null;\n        }\n        Util.each(tCache, function (v, i) {\n            if (t >= v[0] && t <= v[1]) {\n                subt = (t - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        var seg = curve[index];\n        if (Util.isNil(seg) || Util.isNil(index)) {\n            return null;\n        }\n        var l = seg.length;\n        var nextSeg = curve[index + 1];\n        return {\n            x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),\n            y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt)\n        };\n    },\n    createPath: function createPath(context) {\n        var self = this;\n        var segments = self.get('segments');\n        if (!Util.isArray(segments)) {\n            return;\n        }\n        context = context || self.get('context');\n        context.beginPath();\n        var segmentsLen = segments.length;\n        for (var i = 0; i < segmentsLen; i++) {\n            segments[i].draw(context);\n        }\n    },\n    afterPath: function afterPath(context) {\n        var self = this;\n        var attrs = self._attrs;\n        var segments = self.get('segments');\n        var path = attrs.path;\n        context = context || self.get('context');\n        if (!Util.isArray(segments)) {\n            return;\n        }\n        if (segments.length === 1) {\n            return;\n        }\n        if (!attrs.startArrow && !attrs.endArrow) {\n            return;\n        }\n        if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {\n            return;\n        }\n        var startPoints = self.getStartTangent();\n        Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);\n        var endPoints = self.getEndTangent();\n        Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);\n    }\n});\nmodule.exports = Path;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/shapes/path.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/shapes/path.js"],"names":[],"mappings":"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","sourcesContent":["var Util = require('../util/index');\n\nvar Shape = require('../core/shape');\n\nvar PathSegment = require('./util/path-segment');\n\nvar Format = require('../util/format');\n\nvar Arrow = require('./util/arrow');\n\nvar PathUtil = require('../util/path');\n\nvar CubicMath = require('./math/cubic');\n\nvar Path = function Path(cfg) {\n  Path.superclass.constructor.call(this, cfg);\n};\n\nPath.ATTRS = {\n  path: null,\n  lineWidth: 1,\n  startArrow: false,\n  endArrow: false\n};\nUtil.extend(Path, Shape);\nUtil.augment(Path, {\n  canFill: true,\n  canStroke: true,\n  type: 'path',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      startArrow: false,\n      endArrow: false\n    };\n  },\n  _afterSetAttrPath: function _afterSetAttrPath(path) {\n    var self = this;\n\n    if (Util.isNil(path)) {\n      self.setSilent('segments', null);\n      self.setSilent('box', undefined);\n      return;\n    }\n\n    var pathArray = Format.parsePath(path);\n    var preSegment;\n    var segments = [];\n\n    if (!Util.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {\n      return;\n    }\n\n    var count = pathArray.length;\n\n    for (var i = 0; i < pathArray.length; i++) {\n      var item = pathArray[i];\n      preSegment = new PathSegment(item, preSegment, i === count - 1);\n      segments.push(preSegment);\n    }\n\n    self.setSilent('segments', segments);\n    self.setSilent('tCache', null);\n    self.setSilent('box', null);\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var segments = self.get('segments');\n\n    if (!segments) {\n      return null;\n    }\n\n    var lineWidth = this.getHitLineWidth();\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    Util.each(segments, function (segment) {\n      segment.getBBox(lineWidth);\n      var box = segment.box;\n\n      if (box) {\n        if (box.minX < minX) {\n          minX = box.minX;\n        }\n\n        if (box.maxX > maxX) {\n          maxX = box.maxX;\n        }\n\n        if (box.minY < minY) {\n          minY = box.minY;\n        }\n\n        if (box.maxY > maxY) {\n          maxY = box.maxY;\n        }\n      }\n    });\n\n    if (minX === Infinity || minY === Infinity) {\n      return {\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n      };\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  },\n  _setTcache: function _setTcache() {\n    var totalLength = 0;\n    var tempLength = 0;\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    var segmentN;\n    var l;\n    var curve = this._cfg.curve;\n\n    if (!curve) {\n      return;\n    }\n\n    Util.each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n      }\n    });\n    Util.each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n        tempLength += segmentL;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this._cfg.tCache = tCache;\n  },\n  _calculateCurve: function _calculateCurve() {\n    var self = this;\n    var attrs = self._attrs;\n    var path = attrs.path;\n    this._cfg.curve = PathUtil.pathTocurve(path);\n  },\n  getStartTangent: function getStartTangent() {\n    var segments = this.get('segments');\n    var startPoint, endPoint, tangent, result;\n\n    if (segments.length > 1) {\n      startPoint = segments[0].endPoint;\n      endPoint = segments[1].endPoint;\n      tangent = segments[1].startTangent;\n      result = [];\n\n      if (Util.isFunction(tangent)) {\n        var v = tangent();\n        result.push([startPoint.x - v[0], startPoint.y - v[1]]);\n        result.push([startPoint.x, startPoint.y]);\n      } else {\n        result.push([endPoint.x, endPoint.y]);\n        result.push([startPoint.x, startPoint.y]);\n      }\n    }\n\n    return result;\n  },\n  getEndTangent: function getEndTangent() {\n    var segments = this.get('segments');\n    var segmentsLen = segments.length;\n    var startPoint, endPoint, tangent, result;\n\n    if (segmentsLen > 1) {\n      startPoint = segments[segmentsLen - 2].endPoint;\n      endPoint = segments[segmentsLen - 1].endPoint;\n      tangent = segments[segmentsLen - 1].endTangent;\n      result = [];\n\n      if (Util.isFunction(tangent)) {\n        var v = tangent();\n        result.push([endPoint.x - v[0], endPoint.y - v[1]]);\n        result.push([endPoint.x, endPoint.y]);\n      } else {\n        result.push([startPoint.x, startPoint.y]);\n        result.push([endPoint.x, endPoint.y]);\n      }\n    }\n\n    return result;\n  },\n  getPoint: function getPoint(t) {\n    var tCache = this._cfg.tCache;\n    var subt;\n    var index;\n\n    if (!tCache) {\n      this._calculateCurve();\n\n      this._setTcache();\n\n      tCache = this._cfg.tCache;\n    }\n\n    var curve = this._cfg.curve;\n\n    if (!tCache) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2]\n        };\n      }\n\n      return null;\n    }\n\n    Util.each(tCache, function (v, i) {\n      if (t >= v[0] && t <= v[1]) {\n        subt = (t - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    var seg = curve[index];\n\n    if (Util.isNil(seg) || Util.isNil(index)) {\n      return null;\n    }\n\n    var l = seg.length;\n    var nextSeg = curve[index + 1];\n    return {\n      x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),\n      y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt)\n    };\n  },\n  createPath: function createPath(context) {\n    var self = this;\n    var segments = self.get('segments');\n\n    if (!Util.isArray(segments)) {\n      return;\n    }\n\n    context = context || self.get('context');\n    context.beginPath();\n    var segmentsLen = segments.length;\n\n    for (var i = 0; i < segmentsLen; i++) {\n      segments[i].draw(context);\n    }\n  },\n  afterPath: function afterPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var segments = self.get('segments');\n    var path = attrs.path;\n    context = context || self.get('context');\n\n    if (!Util.isArray(segments)) {\n      return;\n    }\n\n    if (segments.length === 1) {\n      return;\n    }\n\n    if (!attrs.startArrow && !attrs.endArrow) {\n      return;\n    }\n\n    if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {\n      // 闭合路径不绘制箭头\n      return;\n    }\n\n    var startPoints = self.getStartTangent();\n    Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);\n    var endPoints = self.getEndTangent();\n    Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);\n  }\n});\nmodule.exports = Path;"]}]}