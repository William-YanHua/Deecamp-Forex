{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/renderers/canvas/util.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/renderers/canvas/util.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var Util = require('../../util/index');\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nvar regexDot = /[^\\s\\,]+/ig;\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/ig;\nvar numColorCache = {};\nfunction addStop(steps, gradient) {\n    var arr = steps.match(regexColorStop);\n    Util.each(arr, function (item) {\n        item = item.split(':');\n        gradient.addColorStop(item[0], item[1]);\n    });\n}\nfunction parseLineGradient(color, self, context) {\n    var arr = regexLG.exec(color);\n    var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);\n    var steps = arr[2];\n    var box = self.getBBox();\n    var start;\n    var end;\n    if (angle >= 0 && angle < 0.5 * Math.PI) {\n        start = {\n            x: box.minX,\n            y: box.minY\n        };\n        end = {\n            x: box.maxX,\n            y: box.maxY\n        };\n    }\n    else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.minY\n        };\n        end = {\n            x: box.minX,\n            y: box.maxY\n        };\n    }\n    else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.maxY\n        };\n        end = {\n            x: box.minX,\n            y: box.minY\n        };\n    }\n    else {\n        start = {\n            x: box.minX,\n            y: box.maxY\n        };\n        end = {\n            x: box.maxX,\n            y: box.minY\n        };\n    }\n    var tanTheta = Math.tan(angle);\n    var tanTheta2 = tanTheta * tanTheta;\n    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n    var gradient = context.createLinearGradient(start.x, start.y, x, y);\n    addStop(steps, gradient);\n    return gradient;\n}\nfunction parseRadialGradient(color, self, context) {\n    var arr = regexRG.exec(color);\n    var fx = parseFloat(arr[1]);\n    var fy = parseFloat(arr[2]);\n    var fr = parseFloat(arr[3]);\n    var steps = arr[4];\n    if (fr === 0) {\n        var colors = steps.match(regexColorStop);\n        return colors[colors.length - 1].split(':')[1];\n    }\n    var box = self.getBBox();\n    var width = box.maxX - box.minX;\n    var height = box.maxY - box.minY;\n    var r = Math.sqrt(width * width + height * height) / 2;\n    var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, fr * r, box.minX + width / 2, box.minY + height / 2, r);\n    addStop(steps, gradient);\n    return gradient;\n}\nfunction parsePattern(color, self, context) {\n    if (self.get('patternSource') && self.get('patternSource') === color) {\n        return self.get('pattern');\n    }\n    var pattern;\n    var img;\n    var arr = regexPR.exec(color);\n    var repeat = arr[1];\n    var source = arr[2];\n    function onload() {\n        pattern = context.createPattern(img, repeat);\n        self.setSilent('pattern', pattern);\n        self.setSilent('patternSource', color);\n    }\n    switch (repeat) {\n        case 'a':\n            repeat = 'repeat';\n            break;\n        case 'x':\n            repeat = 'repeat-x';\n            break;\n        case 'y':\n            repeat = 'repeat-y';\n            break;\n        case 'n':\n            repeat = 'no-repeat';\n            break;\n        default:\n            repeat = 'no-repeat';\n    }\n    img = new Image();\n    if (!source.match(/^data:/i)) {\n        img.crossOrigin = 'Anonymous';\n    }\n    img.src = source;\n    if (img.complete) {\n        onload();\n    }\n    else {\n        img.onload = onload;\n        img.src = img.src;\n    }\n    return pattern;\n}\nmodule.exports = {\n    parsePath: function parsePath(path) {\n        path = path || [];\n        if (Util.isArray(path)) {\n            return path;\n        }\n        if (Util.isString(path)) {\n            path = path.match(regexTags);\n            Util.each(path, function (item, index) {\n                item = item.match(regexDot);\n                if (item[0].length > 1) {\n                    var tag = item[0].charAt(0);\n                    item.splice(1, 0, item[0].substr(1));\n                    item[0] = tag;\n                }\n                Util.each(item, function (sub, i) {\n                    if (!isNaN(sub)) {\n                        item[i] = +sub;\n                    }\n                });\n                path[index] = item;\n            });\n            return path;\n        }\n    },\n    parseStyle: function parseStyle(color, self, context) {\n        if (Util.isString(color)) {\n            if (color[1] === '(' || color[2] === '(') {\n                if (color[0] === 'l') {\n                    return parseLineGradient(color, self, context);\n                }\n                else if (color[0] === 'r') {\n                    return parseRadialGradient(color, self, context);\n                }\n                else if (color[0] === 'p') {\n                    return parsePattern(color, self, context);\n                }\n            }\n            return color;\n        }\n    },\n    numberToColor: function numberToColor(num) {\n        var color = numColorCache[num];\n        if (!color) {\n            var str = num.toString(16);\n            for (var i = str.length; i < 6; i++) {\n                str = '0' + str;\n            }\n            color = '#' + str;\n            numColorCache[num] = color;\n        }\n        return color;\n    }\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/renderers/canvas/util.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/renderers/canvas/util.js"],"names":[],"mappings":"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","sourcesContent":["var Util = require('../../util/index');\n\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nvar regexDot = /[^\\s\\,]+/ig;\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/ig;\nvar numColorCache = {};\n\nfunction addStop(steps, gradient) {\n  var arr = steps.match(regexColorStop);\n  Util.each(arr, function (item) {\n    item = item.split(':');\n    gradient.addColorStop(item[0], item[1]);\n  });\n}\n\nfunction parseLineGradient(color, self, context) {\n  var arr = regexLG.exec(color);\n  var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);\n  var steps = arr[2];\n  var box = self.getBBox();\n  var start;\n  var end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: box.minX,\n      y: box.minY\n    };\n    end = {\n      x: box.maxX,\n      y: box.maxY\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.minY\n    };\n    end = {\n      x: box.minX,\n      y: box.maxY\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.maxY\n    };\n    end = {\n      x: box.minX,\n      y: box.minY\n    };\n  } else {\n    start = {\n      x: box.minX,\n      y: box.maxY\n    };\n    end = {\n      x: box.maxX,\n      y: box.minY\n    };\n  }\n\n  var tanTheta = Math.tan(angle);\n  var tanTheta2 = tanTheta * tanTheta;\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  var gradient = context.createLinearGradient(start.x, start.y, x, y);\n  addStop(steps, gradient);\n  return gradient;\n}\n\nfunction parseRadialGradient(color, self, context) {\n  var arr = regexRG.exec(color);\n  var fx = parseFloat(arr[1]);\n  var fy = parseFloat(arr[2]);\n  var fr = parseFloat(arr[3]);\n  var steps = arr[4]; // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n\n  if (fr === 0) {\n    var colors = steps.match(regexColorStop);\n    return colors[colors.length - 1].split(':')[1];\n  }\n\n  var box = self.getBBox();\n  var width = box.maxX - box.minX;\n  var height = box.maxY - box.minY;\n  var r = Math.sqrt(width * width + height * height) / 2;\n  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, fr * r, box.minX + width / 2, box.minY + height / 2, r);\n  addStop(steps, gradient);\n  return gradient;\n}\n\nfunction parsePattern(color, self, context) {\n  if (self.get('patternSource') && self.get('patternSource') === color) {\n    return self.get('pattern');\n  }\n\n  var pattern;\n  var img;\n  var arr = regexPR.exec(color);\n  var repeat = arr[1];\n  var source = arr[2]; // Function to be called when pattern loads\n\n  function onload() {\n    // Create pattern\n    pattern = context.createPattern(img, repeat);\n    self.setSilent('pattern', pattern); // be a cache\n\n    self.setSilent('patternSource', color);\n  }\n\n  switch (repeat) {\n    case 'a':\n      repeat = 'repeat';\n      break;\n\n    case 'x':\n      repeat = 'repeat-x';\n      break;\n\n    case 'y':\n      repeat = 'repeat-y';\n      break;\n\n    case 'n':\n      repeat = 'no-repeat';\n      break;\n\n    default:\n      repeat = 'no-repeat';\n  }\n\n  img = new Image(); // If source URL is not a data URL\n\n  if (!source.match(/^data:/i)) {\n    // Set crossOrigin for this image\n    img.crossOrigin = 'Anonymous';\n  }\n\n  img.src = source;\n\n  if (img.complete) {\n    onload();\n  } else {\n    img.onload = onload; // Fix onload() bug in IE9\n\n    img.src = img.src;\n  }\n\n  return pattern;\n}\n\nmodule.exports = {\n  parsePath: function parsePath(path) {\n    path = path || [];\n\n    if (Util.isArray(path)) {\n      return path;\n    }\n\n    if (Util.isString(path)) {\n      path = path.match(regexTags);\n      Util.each(path, function (item, index) {\n        item = item.match(regexDot);\n\n        if (item[0].length > 1) {\n          var tag = item[0].charAt(0);\n          item.splice(1, 0, item[0].substr(1));\n          item[0] = tag;\n        }\n\n        Util.each(item, function (sub, i) {\n          if (!isNaN(sub)) {\n            item[i] = +sub;\n          }\n        });\n        path[index] = item;\n      });\n      return path;\n    }\n  },\n  parseStyle: function parseStyle(color, self, context) {\n    if (Util.isString(color)) {\n      if (color[1] === '(' || color[2] === '(') {\n        if (color[0] === 'l') {\n          // regexLG.test(color)\n          return parseLineGradient(color, self, context);\n        } else if (color[0] === 'r') {\n          // regexRG.test(color)\n          return parseRadialGradient(color, self, context);\n        } else if (color[0] === 'p') {\n          // regexPR.test(color)\n          return parsePattern(color, self, context);\n        }\n      }\n\n      return color;\n    }\n  },\n  numberToColor: function numberToColor(num) {\n    // 增加缓存\n    var color = numColorCache[num];\n\n    if (!color) {\n      var str = num.toString(16);\n\n      for (var i = str.length; i < 6; i++) {\n        str = '0' + str;\n      }\n\n      color = '#' + str;\n      numColorCache[num] = color;\n    }\n\n    return color;\n  }\n};"]}]}