{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/graphics.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/graphics.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReplaceAttrs = exports.getPolygonCentroid = exports.getAngle = exports.getArcPath = exports.getSectorPath = exports.polarToCartesian = void 0;\nvar util_1 = require(\"@antv/util\");\nfunction getPointsBox(points) {\n    if (util_1.isEmpty(points)) {\n        return null;\n    }\n    var minX = points[0].x;\n    var maxX = points[0].x;\n    var minY = points[0].y;\n    var maxY = points[0].y;\n    util_1.each(points, function (point) {\n        minX = minX > point.x ? point.x : minX;\n        maxX = maxX < point.x ? point.x : maxX;\n        minY = minY > point.y ? point.y : minY;\n        maxY = maxY < point.y ? point.y : maxY;\n    });\n    return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        centerX: (minX + maxX) / 2,\n        centerY: (minY + maxY) / 2,\n    };\n}\nfunction polarToCartesian(centerX, centerY, radius, angleInRadian) {\n    return {\n        x: centerX + radius * Math.cos(angleInRadian),\n        y: centerY + radius * Math.sin(angleInRadian),\n    };\n}\nexports.polarToCartesian = polarToCartesian;\nfunction getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n    if (innerRadius === void 0) {\n        innerRadius = 0;\n    }\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n        var circlePathCommands = [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, end.x, end.y],\n            ['M', innerStart.x, innerStart.y],\n        ];\n        if (innerRadius) {\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n        }\n        circlePathCommands.push(['M', start.x, start.y]);\n        circlePathCommands.push(['Z']);\n        return circlePathCommands;\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    var sectorPathCommands = [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n        ['L', innerEnd.x, innerEnd.y],\n    ];\n    if (innerRadius) {\n        sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n    }\n    sectorPathCommands.push(['L', start.x, start.y]);\n    sectorPathCommands.push(['Z']);\n    return sectorPathCommands;\n}\nexports.getSectorPath = getSectorPath;\nfunction getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    if (util_1.isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        return [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, start.x, start.y],\n            ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 0, start.x, start.y],\n            ['Z'],\n        ];\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    return [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ];\n}\nexports.getArcPath = getArcPath;\nfunction getAngle(shapeModel, coordinate) {\n    var points = shapeModel.points;\n    var box = getPointsBox(points);\n    var endAngle;\n    var startAngle;\n    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;\n    var diffAngle = coordEndAngle - coordStartAngle;\n    if (coordinate.isTransposed) {\n        endAngle = box.maxY * diffAngle;\n        startAngle = box.minY * diffAngle;\n    }\n    else {\n        endAngle = box.maxX * diffAngle;\n        startAngle = box.minX * diffAngle;\n    }\n    endAngle += coordStartAngle;\n    startAngle += coordStartAngle;\n    return {\n        startAngle: startAngle,\n        endAngle: endAngle,\n    };\n}\nexports.getAngle = getAngle;\nfunction getPolygonCentroid(xs, ys) {\n    if (util_1.isNumber(xs) && util_1.isNumber(ys)) {\n        return [xs, ys];\n    }\n    var i = -1;\n    var x = 0;\n    var y = 0;\n    var former;\n    var current = xs.length - 1;\n    var diff;\n    var k = 0;\n    while (++i < xs.length) {\n        former = current;\n        current = i;\n        k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n        x += (xs[former] + xs[current]) * diff;\n        y += (ys[former] + ys[current]) * diff;\n    }\n    k *= 3;\n    return [x / k, y / k];\n}\nexports.getPolygonCentroid = getPolygonCentroid;\nfunction getReplaceAttrs(sourceShape, targetShape) {\n    var originAttrs = sourceShape.attr();\n    var newAttrs = targetShape.attr();\n    util_1.each(originAttrs, function (v, k) {\n        if (newAttrs[k] === undefined) {\n            newAttrs[k] = undefined;\n        }\n    });\n    return newAttrs;\n}\nexports.getReplaceAttrs = getReplaceAttrs;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/graphics.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/graphics.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReplaceAttrs = exports.getPolygonCentroid = exports.getAngle = exports.getArcPath = exports.getSectorPath = exports.polarToCartesian = void 0;\nvar util_1 = require(\"@antv/util\");\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n    if (util_1.isEmpty(points)) {\n        return null;\n    }\n    var minX = points[0].x;\n    var maxX = points[0].x;\n    var minY = points[0].y;\n    var maxY = points[0].y;\n    util_1.each(points, function (point) {\n        minX = minX > point.x ? point.x : minX;\n        maxX = maxX < point.x ? point.x : maxX;\n        minY = minY > point.y ? point.y : minY;\n        maxY = maxY < point.y ? point.y : maxY;\n    });\n    return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        centerX: (minX + maxX) / 2,\n        centerY: (minY + maxY) / 2,\n    };\n}\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nfunction polarToCartesian(centerX, centerY, radius, angleInRadian) {\n    return {\n        x: centerX + radius * Math.cos(angleInRadian),\n        y: centerY + radius * Math.sin(angleInRadian),\n    };\n}\nexports.polarToCartesian = polarToCartesian;\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nfunction getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n    if (innerRadius === void 0) { innerRadius = 0; }\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n        // 整个圆是分割成两个圆\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n        var circlePathCommands = [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, end.x, end.y],\n            ['M', innerStart.x, innerStart.y],\n        ];\n        if (innerRadius) {\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n        }\n        circlePathCommands.push(['M', start.x, start.y]);\n        circlePathCommands.push(['Z']);\n        return circlePathCommands;\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    var sectorPathCommands = [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n        ['L', innerEnd.x, innerEnd.y],\n    ];\n    if (innerRadius) {\n        sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n    }\n    sectorPathCommands.push(['L', start.x, start.y]);\n    sectorPathCommands.push(['Z']);\n    return sectorPathCommands;\n}\nexports.getSectorPath = getSectorPath;\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nfunction getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    if (util_1.isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        return [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, start.x, start.y],\n            ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 0, start.x, start.y],\n            ['Z'],\n        ];\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    return [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ];\n}\nexports.getArcPath = getArcPath;\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nfunction getAngle(shapeModel, coordinate) {\n    var points = shapeModel.points;\n    var box = getPointsBox(points);\n    var endAngle;\n    var startAngle;\n    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;\n    var diffAngle = coordEndAngle - coordStartAngle;\n    if (coordinate.isTransposed) {\n        endAngle = box.maxY * diffAngle;\n        startAngle = box.minY * diffAngle;\n    }\n    else {\n        endAngle = box.maxX * diffAngle;\n        startAngle = box.minX * diffAngle;\n    }\n    endAngle += coordStartAngle;\n    startAngle += coordStartAngle;\n    return {\n        startAngle: startAngle,\n        endAngle: endAngle,\n    };\n}\nexports.getAngle = getAngle;\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nfunction getPolygonCentroid(xs, ys) {\n    if (util_1.isNumber(xs) && util_1.isNumber(ys)) {\n        // 普通色块图，xs 和 ys 是数值\n        return [xs, ys];\n    }\n    var i = -1;\n    var x = 0;\n    var y = 0;\n    var former;\n    var current = xs.length - 1;\n    var diff;\n    var k = 0;\n    while (++i < xs.length) {\n        former = current;\n        current = i;\n        k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n        x += (xs[former] + xs[current]) * diff;\n        y += (ys[former] + ys[current]) * diff;\n    }\n    k *= 3;\n    return [x / k, y / k];\n}\nexports.getPolygonCentroid = getPolygonCentroid;\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nfunction getReplaceAttrs(sourceShape, targetShape) {\n    var originAttrs = sourceShape.attr();\n    var newAttrs = targetShape.attr();\n    util_1.each(originAttrs, function (v, k) {\n        if (newAttrs[k] === undefined) {\n            newAttrs[k] = undefined;\n        }\n    });\n    return newAttrs;\n}\nexports.getReplaceAttrs = getReplaceAttrs;\n//# sourceMappingURL=graphics.js.map"]}]}