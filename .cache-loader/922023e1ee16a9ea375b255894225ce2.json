{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/word-cloud/wordcloud2.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/word-cloud/wordcloud2.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["'use strict';\nimport { __assign } from \"tslib\";\nimport { get, isNil } from '@antv/util';\nif (!window.setImmediate) {\n    window.setImmediate = (function setupSetImmediate() {\n        return (window.msSetImmediate ||\n            window.webkitSetImmediate ||\n            window.mozSetImmediate ||\n            window.oSetImmediate ||\n            (function setupSetZeroTimeout() {\n                if (!window.postMessage || !window.addEventListener) {\n                    return null;\n                }\n                var callbacks = [undefined];\n                var message = 'zero-timeout-message';\n                var setZeroTimeout = function setZeroTimeout(callback) {\n                    var id = callbacks.length;\n                    callbacks.push(callback);\n                    window.postMessage(message + id.toString(36), '*');\n                    return id;\n                };\n                window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n                    if (typeof evt.data !== 'string' ||\n                        evt.data.substr(0, message.length) !== message) {\n                        return;\n                    }\n                    evt.stopImmediatePropagation();\n                    var id = parseInt(evt.data.substr(message.length), 36);\n                    if (!callbacks[id]) {\n                        return;\n                    }\n                    callbacks[id]();\n                    callbacks[id] = undefined;\n                }, true);\n                window.clearImmediate = function clearZeroTimeout(id) {\n                    if (!callbacks[id]) {\n                        return;\n                    }\n                    callbacks[id] = undefined;\n                };\n                return setZeroTimeout;\n            })() ||\n            function setImmediateFallback(fn) {\n                window.setTimeout(fn, 0);\n            });\n    })();\n}\nif (!window.clearImmediate) {\n    window.clearImmediate = (function setupClearImmediate() {\n        return (window.msClearImmediate ||\n            window.webkitClearImmediate ||\n            window.mozClearImmediate ||\n            window.oClearImmediate ||\n            function clearImmediateFallback(timer) {\n                window.clearTimeout(timer);\n            });\n    })();\n}\nvar isSupported = (function isSupported() {\n    var canvas = document.createElement('canvas');\n    if (!canvas || !canvas.getContext) {\n        return false;\n    }\n    var ctx = canvas.getContext('2d');\n    if (!ctx.getImageData) {\n        return false;\n    }\n    if (!ctx.fillText) {\n        return false;\n    }\n    if (!Array.prototype.some) {\n        return false;\n    }\n    if (!Array.prototype.push) {\n        return false;\n    }\n    return true;\n})();\nvar minFontSize = (function getMinFontSize() {\n    if (!isSupported) {\n        return;\n    }\n    var ctx = document.createElement('canvas').getContext('2d');\n    var size = 20;\n    var hanWidth, mWidth;\n    while (size) {\n        ctx.font = size.toString(10) + 'px sans-serif';\n        if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n            return size + 1;\n        }\n        hanWidth = ctx.measureText('\\uFF37').width;\n        mWidth = ctx.measureText('m').width;\n        size--;\n    }\n    return 0;\n})();\nvar shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) { }\n    return arr;\n};\nvar WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n        return;\n    }\n    if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n    elements.forEach(function (el, i) {\n        if (typeof el === 'string') {\n            elements[i] = document.getElementById(el);\n            if (!elements[i]) {\n                throw 'The element id specified is not found.';\n            }\n        }\n        else if (!el.tagName && !el.appendChild) {\n            throw 'You must pass valid HTML elements, or ID of the element.';\n        }\n    });\n    var settings = {\n        data: [],\n        fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n        fontWeight: 'normal',\n        color: 'random-dark',\n        minFontSize: minFontSize,\n        maxFontSize: 60,\n        clearCanvas: true,\n        backgroundColor: '#fff',\n        gridSize: 8,\n        drawOutOfBound: false,\n        origin: null,\n        drawMask: false,\n        maskColor: 'rgba(255,0,0,0.3)',\n        maskGapWidth: 0.3,\n        wait: 0,\n        abortThreshold: 0,\n        abort: function noop() { },\n        minRotation: -Math.PI / 2,\n        maxRotation: Math.PI / 2,\n        rotateRatio: 0.5,\n        rotationSteps: 1,\n        shuffle: true,\n        shape: 'circle',\n        ellipticity: 1,\n        active: true,\n        animatable: true,\n        selected: -1,\n        shadowColor: '#333',\n        shadowBlur: 10,\n        fontScale: 1.2,\n        classes: null,\n        onWordCloudHover: null,\n        onWordCloudClick: null,\n    };\n    var interactionItems = [];\n    if (options) {\n        for (var key in options) {\n            if (key === 'wordStyle') {\n                for (var fontKey in options[key]) {\n                    if (fontKey in settings) {\n                        settings[fontKey] = options[key][fontKey];\n                    }\n                }\n            }\n            else {\n                if (key in settings) {\n                    settings[key] = options[key];\n                }\n            }\n        }\n    }\n    if (settings.minFontSize < minFontSize) {\n        settings.minFontSize = minFontSize;\n    }\n    if (settings.minFontSize > settings.maxFontSize) {\n        console.error('minSize cant bigger than maxSize');\n        return;\n    }\n    var maxWeight = 0;\n    for (var i = 0; i < settings.data.length; i++) {\n        if (maxWeight < settings.data[i].weight) {\n            maxWeight = settings.data[i].weight;\n        }\n    }\n    var getRealFontSize = function getRealFontSize(weight) {\n        var fontSize = Math.min(Math.max(settings.minFontSize, (settings.maxFontSize * weight) / maxWeight), settings.maxFontSize);\n        if (twiceRender) {\n            return fontSize * settings.fontScale;\n        }\n        return fontSize;\n    };\n    var isCardioid = false;\n    if (typeof settings.shape !== 'function') {\n        switch (settings.shape) {\n            case 'circle':\n            default:\n                settings.shape = 'circle';\n                break;\n            case 'cardioid':\n                settings.shape = function shapeCardioid(theta) {\n                    return 1 - Math.sin(theta);\n                };\n                isCardioid = true;\n                break;\n            case 'diamond':\n                settings.shape = function shapeSquare(theta) {\n                    var thetaPrime = theta % ((2 * Math.PI) / 4);\n                    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n                };\n                break;\n            case 'square':\n                settings.shape = function shapeSquare(theta) {\n                    var thetaPrime = (theta + Math.PI / 4) % ((2 * Math.PI) / 4);\n                    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-forward':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = theta % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-backward':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + Math.PI) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle':\n            case 'triangle-up':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + (Math.PI * 3) / 2) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-down':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + (Math.PI * 5) / 2) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'pentagon':\n                settings.shape = function shapePentagon(theta) {\n                    var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 5);\n                    return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n                };\n                break;\n            case 'star':\n                settings.shape = function shapeStar(theta) {\n                    var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 10);\n                    if (((theta + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >= 0) {\n                        return (1 / (Math.cos((2 * Math.PI) / 10 - thetaPrime) + 3.07768 * Math.sin((2 * Math.PI) / 10 - thetaPrime)));\n                    }\n                    else {\n                        return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n                    }\n                };\n                break;\n        }\n    }\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationSteps = settings.rotationSteps;\n    var grid, ngx, ngy, center, maxRadius;\n    var escapeTime;\n    var getTextColor;\n    function random_hsl_color(min, max) {\n        return ('hsl(' +\n            (Math.random() * 360).toFixed() +\n            ',' +\n            (Math.random() * 30 + 70).toFixed() +\n            '%,' +\n            (Math.random() * (max - min) + min).toFixed() +\n            '%)');\n    }\n    switch (settings.color) {\n        case 'random-dark':\n            getTextColor = function getRandomDarkColor() {\n                return random_hsl_color(10, 50);\n            };\n            break;\n        case 'random-light':\n            getTextColor = function getRandomLightColor() {\n                return random_hsl_color(50, 90);\n            };\n            break;\n        default:\n            if (typeof settings.color === 'function') {\n                getTextColor = settings.color;\n            }\n            break;\n    }\n    var getTextClasses = null;\n    if (typeof settings.classes === 'function') {\n        getTextClasses = settings.classes;\n    }\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n    var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n        var canvas = evt.currentTarget;\n        var rect = canvas.getBoundingClientRect();\n        var clientX;\n        var clientY;\n        if (evt.touches) {\n            clientX = evt.touches[0].clientX;\n            clientY = evt.touches[0].clientY;\n        }\n        else {\n            clientX = evt.clientX;\n            clientY = evt.clientY;\n        }\n        var eventX = clientX - rect.left;\n        var eventY = clientY - rect.top;\n        var x = Math.floor((eventX * (canvas.width / rect.width || 1)) / g);\n        var y = Math.floor((eventY * (canvas.height / rect.height || 1)) / g);\n        return infoGrid && infoGrid[x] && infoGrid[x][y];\n    };\n    var defaultHoverAction = function defaultHoverAction(item, dimension, evt, start) {\n        if (item) {\n            start(item.id);\n        }\n        else {\n            start(-1);\n        }\n    };\n    var wordcloudhover = function wordcloudhover(evt) {\n        var info = getInfoGridFromMouseTouchEvent(evt);\n        if (hovered === info) {\n            return;\n        }\n        if (twiceRender && info && info.item && !get(info, ['item', 'twiceRender'])) {\n            return;\n        }\n        if (!info) {\n            settings.onWordCloudHover(undefined, undefined, evt, start);\n            if (settings.active) {\n                defaultHoverAction(undefined, undefined, evt, start);\n            }\n            return;\n        }\n        settings.onWordCloudHover(info.item, info.dimension, evt, start);\n        if (settings.active) {\n            defaultHoverAction(info.item, info.dimension, evt, start);\n        }\n        hovered = info;\n    };\n    var wordcloudclick = function wordcloudclick(evt) {\n        var info = getInfoGridFromMouseTouchEvent(evt);\n        if (!info) {\n            return;\n        }\n        settings.onWordCloudClick(info.item, info.dimension, evt);\n        evt.preventDefault();\n    };\n    var pointsAtRadius = [];\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n        if (pointsAtRadius[radius]) {\n            return pointsAtRadius[radius];\n        }\n        var T = radius * 8;\n        var t = T;\n        var points = [];\n        if (radius === 0) {\n            points.push([center[0], center[1], 0]);\n        }\n        while (t--) {\n            var rx = 1;\n            if (settings.shape !== 'circle') {\n                rx = settings.shape((t / T) * 2 * Math.PI);\n            }\n            points.push([\n                center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),\n                center[1] + radius * rx * Math.sin((-t / T) * 2 * Math.PI) * settings.ellipticity,\n                (t / T) * 2 * Math.PI,\n            ]);\n        }\n        pointsAtRadius[radius] = points;\n        return points;\n    };\n    var exceedTime = function exceedTime() {\n        return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n    };\n    var getRotateDeg = function getRotateDeg() {\n        if (settings.rotateRatio === 0) {\n            return 0;\n        }\n        if (Math.random() > settings.rotateRatio) {\n            return 0;\n        }\n        if (rotationRange === 0) {\n            return minRotation;\n        }\n        if (rotationSteps > 0) {\n            return minRotation + (Math.floor(Math.random() * rotationSteps) * rotationRange) / rotationSteps;\n        }\n        else {\n            return minRotation + Math.random() * rotationRange;\n        }\n    };\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n        var debug = false;\n        var fontSize = getRealFontSize(weight);\n        if (fontSize <= 0) {\n            return false;\n        }\n        var mu = 1;\n        if (fontSize < minFontSize) {\n            mu = (function calculateScaleFactor() {\n                var mu = 2;\n                while (mu * fontSize < minFontSize) {\n                    mu += 2;\n                }\n                return mu;\n            })();\n        }\n        var fcanvas = document.createElement('canvas');\n        var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n        fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        var fw = fctx.measureText(word).width / mu;\n        var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu;\n        var boxWidth = fw + fh * 2;\n        var boxHeight = fh * 3;\n        var fgw = Math.ceil(boxWidth / g);\n        var fgh = Math.ceil(boxHeight / g);\n        boxWidth = fgw * g;\n        boxHeight = fgh * g;\n        var fillTextOffsetX = -fw / 2;\n        var fillTextOffsetY = -fh * 0.4;\n        var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n        var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n        var width = cgw * g;\n        var height = cgh * g;\n        fcanvas.setAttribute('width', width);\n        fcanvas.setAttribute('height', height);\n        if (debug) {\n            document.body.appendChild(fcanvas);\n            fctx.save();\n        }\n        fctx.scale(1 / mu, 1 / mu);\n        fctx.translate((width * mu) / 2, (height * mu) / 2);\n        fctx.rotate(-rotateDeg);\n        fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        fctx.fillStyle = '#000';\n        fctx.textBaseline = 'middle';\n        fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu);\n        var imageData;\n        try {\n            imageData = fctx.getImageData(0, 0, width, height).data;\n        }\n        catch (e) {\n            return false;\n        }\n        if (exceedTime()) {\n            return false;\n        }\n        if (debug) {\n            fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n            fctx.restore();\n        }\n        var occupied = [];\n        var gx = cgw, gy, x, y;\n        var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n        while (gx--) {\n            gy = cgh;\n            while (gy--) {\n                y = g;\n                singleGridLoop: {\n                    while (y--) {\n                        x = g;\n                        while (x--) {\n                            if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                                occupied.push([gx, gy]);\n                                if (gx < bounds[3]) {\n                                    bounds[3] = gx;\n                                }\n                                if (gx > bounds[1]) {\n                                    bounds[1] = gx;\n                                }\n                                if (gy < bounds[0]) {\n                                    bounds[0] = gy;\n                                }\n                                if (gy > bounds[2]) {\n                                    bounds[2] = gy;\n                                }\n                                if (debug) {\n                                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                                }\n                                break singleGridLoop;\n                            }\n                        }\n                    }\n                    if (debug) {\n                        fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n                        fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                    }\n                }\n            }\n        }\n        if (debug) {\n            fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n            fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n        }\n        return {\n            mu: mu,\n            occupied: occupied,\n            bounds: bounds,\n            gw: cgw,\n            gh: cgh,\n            fillTextOffsetX: fillTextOffsetX,\n            fillTextOffsetY: fillTextOffsetY,\n            fillTextWidth: fw,\n            fillTextHeight: fh,\n            fontSize: fontSize,\n        };\n    };\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n        var i = occupied.length;\n        while (i--) {\n            var px = gx + occupied[i][0];\n            var py = gy + occupied[i][1];\n            if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                if (!settings.drawOutOfBound) {\n                    return false;\n                }\n                continue;\n            }\n            if (!grid[px][py]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, id, refresh) {\n        var fontSize = info.fontSize;\n        var color = settings.color;\n        var classes = settings.classes;\n        if (!refresh) {\n            if (getTextColor) {\n                color = getTextColor(word, weight, fontSize, distance, theta);\n            }\n            else {\n                color = settings.color;\n            }\n            if (getTextClasses) {\n                classes = getTextClasses(word, weight, fontSize, distance, theta);\n            }\n            else {\n                classes = settings.classes;\n            }\n        }\n        else {\n            var find = getInteractionItemById(id);\n            color = find ? find.color : settings.color;\n        }\n        var dimension;\n        var bounds = info.bounds;\n        dimension = {\n            x: (gx + bounds[3]) * g,\n            y: (gy + bounds[0]) * g,\n            w: (bounds[1] - bounds[3] + 1) * g,\n            h: (bounds[2] - bounds[0] + 1) * g,\n        };\n        elements.forEach(function (el) {\n            if (el.getContext) {\n                var ctx = el.getContext('2d');\n                var mu = info.mu;\n                ctx.save();\n                var font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n                ctx.scale(1 / mu, 1 / mu);\n                ctx.font = font;\n                ctx.fillStyle = color;\n                var transX = (gx + info.gw / 2) * g * mu;\n                var transY = (gy + info.gh / 2) * g * mu;\n                ctx.translate(transX, transY);\n                if (rotateDeg !== 0) {\n                    ctx.rotate(-rotateDeg);\n                }\n                ctx.textBaseline = 'middle';\n                if (settings.selected === id) {\n                    ctx.shadowColor = settings.shadowColor;\n                    ctx.shadowBlur = settings.shadowBlur;\n                }\n                ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu);\n                if (!refresh) {\n                    interactionItems.push({\n                        gx: gx,\n                        gy: gy,\n                        info: info,\n                        word: word,\n                        weight: weight,\n                        distance: distance,\n                        theta: theta,\n                        rotateDeg: rotateDeg,\n                        attributes: attributes,\n                        id: id,\n                        color: color,\n                    });\n                }\n                ctx.restore();\n            }\n            else {\n                var span = document.createElement('span');\n                var transformRule = '';\n                transformRule = 'rotate(' + (-rotateDeg / Math.PI) * 180 + 'deg) ';\n                if (info.mu !== 1) {\n                    transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n                }\n                var styleRules = {\n                    position: 'absolute',\n                    display: 'block',\n                    font: settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n                    left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n                    top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n                    width: info.fillTextWidth + 'px',\n                    height: info.fillTextHeight + 'px',\n                    lineHeight: fontSize + 'px',\n                    whiteSpace: 'nowrap',\n                    transform: transformRule,\n                    webkitTransform: transformRule,\n                    msTransform: transformRule,\n                    transformOrigin: '50% 40%',\n                    webkitTransformOrigin: '50% 40%',\n                    msTransformOrigin: '50% 40%',\n                };\n                if (color) {\n                    styleRules.color = color;\n                }\n                span.textContent = word;\n                for (var cssProp in styleRules) {\n                    span.style[cssProp] = styleRules[cssProp];\n                }\n                if (attributes) {\n                    for (var attribute in attributes) {\n                        span.setAttribute(attribute, attributes[attribute]);\n                    }\n                }\n                if (classes) {\n                    span.className += classes;\n                }\n                el.appendChild(span);\n            }\n        });\n    };\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n        if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n            return;\n        }\n        grid[x][y] = false;\n        if (drawMask) {\n            var ctx = elements[0].getContext('2d');\n            ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n        }\n        if (interactive) {\n            infoGrid[x][y] = { item: item, dimension: dimension };\n        }\n    };\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info) {\n        var occupied = info.occupied;\n        var drawMask = settings.drawMask;\n        var ctx;\n        if (drawMask) {\n            ctx = elements[0].getContext('2d');\n            ctx.save();\n            ctx.fillStyle = settings.maskColor;\n        }\n        var dimension;\n        if (interactive) {\n            var bounds = info.bounds;\n            dimension = {\n                x: (gx + bounds[3]) * g,\n                y: (gy + bounds[0]) * g,\n                w: (bounds[1] - bounds[3] + 1) * g,\n                h: (bounds[2] - bounds[0] + 1) * g,\n            };\n        }\n        var i = occupied.length;\n        while (i--) {\n            var px = gx + occupied[i][0];\n            var py = gy + occupied[i][1];\n            if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                continue;\n            }\n            var find = getInteractionItemById(info.item.id);\n            if (find) {\n                info.item.color = find.color;\n            }\n            fillGridAt(px, py, drawMask, dimension, info.item);\n        }\n        if (drawMask) {\n            ctx.restore();\n        }\n    };\n    var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy, info, word, weight, distance, rotateDeg, attributes, id) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh;\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n            return false;\n        }\n        drawText(gx, gy, info, word, weight, distance, gxy[2], rotateDeg, attributes, id, false);\n        updateGrid(gx, gy, gw, gh, info);\n        return {\n            gx: gx,\n            gy: gy,\n            rot: rotateDeg,\n            info: info,\n        };\n    };\n    var putWord = function putWord(item) {\n        var word, weight, attributes, id;\n        if (Array.isArray(item)) {\n            word = item[0];\n            weight = item[1];\n        }\n        else {\n            word = item.word;\n            weight = item.weight;\n            attributes = item.attributes;\n            id = item.id;\n        }\n        var rotateDeg = isNil(item.rotateDeg) ? getRotateDeg() : item.rotateDeg;\n        var info = getTextInfo(word, weight, rotateDeg);\n        if (info) {\n            info['item'] = item;\n        }\n        if (!info) {\n            return false;\n        }\n        if (exceedTime()) {\n            return false;\n        }\n        if (!settings.drawOutOfBound) {\n            var bounds = info.bounds;\n            if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n                return false;\n            }\n        }\n        var r = maxRadius + 1;\n        while (r--) {\n            var points = getPointsAtRadius(maxRadius - r);\n            if (settings.shuffle) {\n                points = [].concat(points);\n                shuffleArray(points);\n            }\n            for (var i = 0; i < points.length; i++) {\n                var res = tryToPutWordAtPoint(points[i], info, word, weight, maxRadius - r, rotateDeg, attributes, id);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n        return null;\n    };\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n        if (cancelable) {\n            return !elements.some(function (el) {\n                var evt = document.createEvent('CustomEvent');\n                evt.initCustomEvent(type, true, cancelable, detail || {});\n                return !el.dispatchEvent(evt);\n            }, this);\n        }\n        else {\n            elements.forEach(function (el) {\n                var evt = document.createEvent('CustomEvent');\n                evt.initCustomEvent(type, true, cancelable, detail || {});\n                el.dispatchEvent(evt);\n            }, this);\n        }\n    };\n    var getInteractionItemById = function getInteractionItemById(id) {\n        for (var i = 0; i < interactionItems.length; i++) {\n            var find = interactionItems[i];\n            if (interactionItems[i].id === id) {\n                return find;\n            }\n        }\n        return undefined;\n    };\n    var twiceRender;\n    var start = function start(selected) {\n        if (selected !== undefined) {\n            if (settings.selected !== selected && elements[0].getContext) {\n                settings.selected = selected;\n                var ctx = elements[0].getContext('2d');\n                ctx.fillStyle = settings.backgroundColor;\n                ctx.clearRect(0, 0, elements[0].width, elements[0].height);\n                ctx.fillRect(0, 0, elements[0].width, elements[0].height);\n                for (var i_1 = 0; i_1 < interactionItems.length; i_1++) {\n                    var find = interactionItems[i_1];\n                    if (!twiceRender || (twiceRender && get(find, ['info', 'item', 'twiceRender']))) {\n                        drawText(find.gx, find.gy, find.info, find.word, find.weight, find.distance, find.theta, find.rotateDeg, find.attributes, find.id, true);\n                    }\n                }\n            }\n            return;\n        }\n        var canvas = elements[0];\n        if (canvas.getContext) {\n            ngx = Math.ceil(canvas.width / g);\n            ngy = Math.ceil(canvas.height / g);\n        }\n        else {\n            var rect = canvas.getBoundingClientRect();\n            ngx = Math.ceil(rect.width / g);\n            ngy = Math.ceil(rect.height / g);\n        }\n        if (!sendEvent('wordcloudstart', true)) {\n            return;\n        }\n        center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / (isCardioid ? 4 : 2)];\n        maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n        grid = [];\n        var gx, gy, i;\n        if (!canvas.getContext || settings.clearCanvas) {\n            elements.forEach(function (el) {\n                if (el.getContext) {\n                    var ctx = el.getContext('2d');\n                    ctx.fillStyle = settings.backgroundColor;\n                    ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                    ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                }\n                else {\n                    el.textContent = '';\n                    el.style.backgroundColor = settings.backgroundColor;\n                    el.style.position = 'relative';\n                }\n            });\n            gx = ngx;\n            while (gx--) {\n                grid[gx] = [];\n                gy = ngy;\n                while (gy--) {\n                    grid[gx][gy] = true;\n                }\n            }\n        }\n        else {\n            var bctx = document.createElement('canvas').getContext('2d');\n            bctx.fillStyle = settings.backgroundColor;\n            bctx.fillRect(0, 0, 1, 1);\n            var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n            var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n            gx = ngx;\n            var x, y;\n            while (gx--) {\n                grid[gx] = [];\n                gy = ngy;\n                while (gy--) {\n                    y = g;\n                    singleGridLoop: while (y--) {\n                        x = g;\n                        while (x--) {\n                            i = 4;\n                            while (i--) {\n                                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                                    grid[gx][gy] = false;\n                                    break singleGridLoop;\n                                }\n                            }\n                        }\n                    }\n                    if (grid[gx][gy] !== false) {\n                        grid[gx][gy] = true;\n                    }\n                }\n            }\n            imageData = bctx = bgPixel = undefined;\n        }\n        if (settings.onWordCloudHover || settings.onWordCloudClick) {\n            interactive = true;\n            gx = ngx + 1;\n            while (gx--) {\n                infoGrid[gx] = [];\n            }\n            if (settings.onWordCloudHover) {\n                canvas.addEventListener('mousemove', wordcloudhover);\n            }\n            if (settings.onWordCloudClick) {\n                canvas.addEventListener('click', wordcloudclick);\n                canvas.addEventListener('touchstart', wordcloudclick);\n                canvas.addEventListener('touchend', function (e) {\n                    e.preventDefault();\n                });\n                canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n            }\n            canvas.addEventListener('wordcloudstart', function stopInteraction() {\n                canvas.removeEventListener('wordcloudstart', stopInteraction);\n                canvas.removeEventListener('mousemove', wordcloudhover);\n                canvas.removeEventListener('click', wordcloudclick);\n                hovered = undefined;\n            });\n        }\n        if (!settings.animatable) {\n            if (options.maskImage) {\n                elements.forEach(function (el) {\n                    if (el.getContext) {\n                        var ctx = el.getContext('2d');\n                        ctx.fillStyle = settings.backgroundColor;\n                        ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                        ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                    }\n                });\n            }\n            var renderedWords = [];\n            for (var i_2 = 0; i_2 < settings.data.length; i_2++) {\n                var response = putWord(settings.data[i_2]);\n                if (response) {\n                    renderedWords.push(response);\n                }\n            }\n            if (renderedWords.length === settings.data.length) {\n                if (!twiceRender) {\n                    elements.forEach(function (el) {\n                        if (el.getContext) {\n                            var ctx = el.getContext('2d');\n                            ctx.fillStyle = settings.backgroundColor;\n                            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                        }\n                    });\n                    gx = ngx;\n                    while (gx--) {\n                        grid[gx] = [];\n                        gy = ngy;\n                        while (gy--) {\n                            grid[gx][gy] = true;\n                        }\n                    }\n                    twiceRender = true;\n                    for (var i_3 = 0; i_3 < settings.data.length; i_3++) {\n                        putWord(__assign(__assign({}, settings.data[i_3]), { twiceRender: twiceRender }));\n                    }\n                }\n            }\n        }\n        else {\n            i = 0;\n            var loopingFunction, stoppingFunction;\n            if (settings.wait !== 0) {\n                loopingFunction = window.setTimeout;\n                stoppingFunction = window.clearTimeout;\n            }\n            else {\n                loopingFunction = window.setImmediate;\n                stoppingFunction = window.clearImmediate;\n            }\n            var addEventListener = function addEventListener(type, listener) {\n                elements.forEach(function (el) {\n                    el.addEventListener(type, listener);\n                }, this);\n            };\n            var removeEventListener = function removeEventListener(type, listener) {\n                elements.forEach(function (el) {\n                    el.removeEventListener(type, listener);\n                }, this);\n            };\n            var anotherWordCloudStart = function anotherWordCloudStart() {\n                removeEventListener('wordcloudstart', anotherWordCloudStart);\n                stoppingFunction(timer);\n            };\n            addEventListener('wordcloudstart', anotherWordCloudStart);\n            var timer = loopingFunction(function loop() {\n                if (i >= settings.data.length) {\n                    stoppingFunction(timer);\n                    sendEvent('wordcloudstop', false);\n                    removeEventListener('wordcloudstart', anotherWordCloudStart);\n                    return;\n                }\n                escapeTime = new Date().getTime();\n                var drawn = putWord(settings.data[i]);\n                var canceled = !sendEvent('wordclouddrawn', true, {\n                    item: settings.data[i],\n                    drawn: drawn,\n                });\n                if (exceedTime() || canceled) {\n                    stoppingFunction(timer);\n                    settings.abort();\n                    sendEvent('wordcloudabort', false);\n                    sendEvent('wordcloudstop', false);\n                    removeEventListener('wordcloudstart', anotherWordCloudStart);\n                    return;\n                }\n                i++;\n                timer = loopingFunction(loop, settings.wait);\n            }, settings.wait);\n        }\n    };\n    start();\n};\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\nexport default WordCloud;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/word-cloud/wordcloud2.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/plots/word-cloud/wordcloud2.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Create By Bruce Too\n * On 2020-02-14\n */\n/* eslint-disable unicorn/no-abusive-eslint-disable */\n/* eslint-disable */\n// @ts-nocheck\n// TODO rewrite with typescript @brucetoo\n/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n'use strict';\nimport { __assign } from \"tslib\";\nimport { get, isNil } from '@antv/util';\n// setImmediate\nif (!window.setImmediate) {\n    window.setImmediate = (function setupSetImmediate() {\n        return (window.msSetImmediate ||\n            window.webkitSetImmediate ||\n            window.mozSetImmediate ||\n            window.oSetImmediate ||\n            (function setupSetZeroTimeout() {\n                if (!window.postMessage || !window.addEventListener) {\n                    return null;\n                }\n                var callbacks = [undefined];\n                var message = 'zero-timeout-message';\n                // Like setTimeout, but only takes a function argument.  There's\n                // no time argument (always zero) and no arguments (you have to\n                // use a closure).\n                var setZeroTimeout = function setZeroTimeout(callback) {\n                    var id = callbacks.length;\n                    callbacks.push(callback);\n                    window.postMessage(message + id.toString(36), '*');\n                    return id;\n                };\n                window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n                    // Skipping checking event source, retarded IE confused this window\n                    // object with another in the presence of iframe\n                    if (typeof evt.data !== 'string' ||\n                        evt.data.substr(0, message.length) !== message /* ||\n                  evt.source !== window */) {\n                        return;\n                    }\n                    evt.stopImmediatePropagation();\n                    var id = parseInt(evt.data.substr(message.length), 36);\n                    if (!callbacks[id]) {\n                        return;\n                    }\n                    callbacks[id]();\n                    callbacks[id] = undefined;\n                }, true);\n                /* specify clearImmediate() here since we need the scope */\n                window.clearImmediate = function clearZeroTimeout(id) {\n                    if (!callbacks[id]) {\n                        return;\n                    }\n                    callbacks[id] = undefined;\n                };\n                return setZeroTimeout;\n            })() ||\n            // fallback\n            function setImmediateFallback(fn) {\n                window.setTimeout(fn, 0);\n            });\n    })();\n}\nif (!window.clearImmediate) {\n    window.clearImmediate = (function setupClearImmediate() {\n        return (window.msClearImmediate ||\n            window.webkitClearImmediate ||\n            window.mozClearImmediate ||\n            window.oClearImmediate ||\n            // \"clearZeroTimeout\" is implement on the previous block ||\n            // fallback\n            function clearImmediateFallback(timer) {\n                window.clearTimeout(timer);\n            });\n    })();\n}\n// Check if WordCloud can run on this browser\nvar isSupported = (function isSupported() {\n    var canvas = document.createElement('canvas');\n    if (!canvas || !canvas.getContext) {\n        return false;\n    }\n    var ctx = canvas.getContext('2d');\n    if (!ctx.getImageData) {\n        return false;\n    }\n    if (!ctx.fillText) {\n        return false;\n    }\n    if (!Array.prototype.some) {\n        return false;\n    }\n    if (!Array.prototype.push) {\n        return false;\n    }\n    return true;\n})();\n// Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\nvar minFontSize = (function getMinFontSize() {\n    if (!isSupported) {\n        return;\n    }\n    var ctx = document.createElement('canvas').getContext('2d');\n    // start from 20\n    var size = 20;\n    // two sizes to measure\n    var hanWidth, mWidth;\n    while (size) {\n        ctx.font = size.toString(10) + 'px sans-serif';\n        if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n            return size + 1;\n        }\n        hanWidth = ctx.measureText('\\uFF37').width;\n        mWidth = ctx.measureText('m').width;\n        size--;\n    }\n    return 0;\n})();\n// Based on http://jsfromhell.com/array/shuffle\nvar shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) { }\n    return arr;\n};\nvar WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n        return;\n    }\n    if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n    elements.forEach(function (el, i) {\n        if (typeof el === 'string') {\n            elements[i] = document.getElementById(el);\n            if (!elements[i]) {\n                throw 'The element id specified is not found.';\n            }\n        }\n        else if (!el.tagName && !el.appendChild) {\n            throw 'You must pass valid HTML elements, or ID of the element.';\n        }\n    });\n    /* Default values to be overwritten by options object */\n    var settings = {\n        data: [],\n        fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n        fontWeight: 'normal',\n        color: 'random-dark',\n        minFontSize: minFontSize,\n        maxFontSize: 60,\n        clearCanvas: true,\n        backgroundColor: '#fff',\n        gridSize: 8,\n        drawOutOfBound: false,\n        origin: null,\n        drawMask: false,\n        maskColor: 'rgba(255,0,0,0.3)',\n        maskGapWidth: 0.3,\n        wait: 0,\n        abortThreshold: 0,\n        abort: function noop() { },\n        minRotation: -Math.PI / 2,\n        maxRotation: Math.PI / 2,\n        rotateRatio: 0.5,\n        rotationSteps: 1,\n        shuffle: true,\n        shape: 'circle',\n        ellipticity: 1,\n        active: true,\n        animatable: true,\n        selected: -1,\n        shadowColor: '#333',\n        shadowBlur: 10,\n        fontScale: 1.2,\n        classes: null,\n        onWordCloudHover: null,\n        onWordCloudClick: null,\n    };\n    var interactionItems = [];\n    if (options) {\n        for (var key in options) {\n            if (key === 'wordStyle') {\n                for (var fontKey in options[key]) {\n                    if (fontKey in settings) {\n                        settings[fontKey] = options[key][fontKey];\n                    }\n                }\n            }\n            else {\n                if (key in settings) {\n                    settings[key] = options[key];\n                }\n            }\n        }\n    }\n    if (settings.minFontSize < minFontSize) {\n        // can't less than browse's min font size\n        settings.minFontSize = minFontSize;\n    }\n    if (settings.minFontSize > settings.maxFontSize) {\n        console.error('minSize cant bigger than maxSize');\n        return;\n    }\n    var maxWeight = 0;\n    for (var i = 0; i < settings.data.length; i++) {\n        if (maxWeight < settings.data[i].weight) {\n            maxWeight = settings.data[i].weight;\n        }\n    }\n    var getRealFontSize = function getRealFontSize(weight) {\n        var fontSize = Math.min(Math.max(settings.minFontSize, (settings.maxFontSize * weight) / maxWeight), settings.maxFontSize);\n        if (twiceRender) {\n            return fontSize * settings.fontScale;\n        }\n        return fontSize;\n    };\n    var isCardioid = false;\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n        switch (settings.shape) {\n            case 'circle':\n            /* falls through */\n            default:\n                // 'circle' is the default and a shortcut in the code loop.\n                settings.shape = 'circle';\n                break;\n            case 'cardioid':\n                // https://baike.baidu.com/item/%E5%BF%83%E8%84%8F%E7%BA%BF/10323843?fromtitle=%E5%BF%83%E5%BD%A2%E7%BA%BF&fromid=10018818\n                settings.shape = function shapeCardioid(theta) {\n                    return 1 - Math.sin(theta);\n                };\n                isCardioid = true;\n                break;\n            /*\n            To work out an X-gon, one has to calculate \"m\",\n            where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n            http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n            2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n            Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n            where t' equals to mod(t, 2PI/X);\n            */\n            case 'diamond':\n                settings.shape = function shapeSquare(theta) {\n                    var thetaPrime = theta % ((2 * Math.PI) / 4);\n                    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n                };\n                break;\n            case 'square':\n                // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n                // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n                // +0+..+2*PI\n                settings.shape = function shapeSquare(theta) {\n                    var thetaPrime = (theta + Math.PI / 4) % ((2 * Math.PI) / 4);\n                    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-forward':\n                // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n                // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n                // %29%29%2C+t+%3D+0+..+2*PI\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = theta % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-backward':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + Math.PI) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle':\n            case 'triangle-up':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + (Math.PI * 3) / 2) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'triangle-down':\n                settings.shape = function shapeTriangle(theta) {\n                    var thetaPrime = (theta + (Math.PI * 5) / 2) % ((2 * Math.PI) / 3);\n                    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n                };\n                break;\n            case 'pentagon':\n                settings.shape = function shapePentagon(theta) {\n                    var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 5);\n                    return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n                };\n                break;\n            case 'star':\n                settings.shape = function shapeStar(theta) {\n                    var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 10);\n                    if (((theta + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >= 0) {\n                        return (1 / (Math.cos((2 * Math.PI) / 10 - thetaPrime) + 3.07768 * Math.sin((2 * Math.PI) / 10 - thetaPrime)));\n                    }\n                    else {\n                        return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n                    }\n                };\n                break;\n        }\n    }\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n    /* shorthand */\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationSteps = settings.rotationSteps;\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n    ngx, ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n    /* timestamp for measuring each putWord() action */\n    var escapeTime;\n    /* function for getting the color of the text */\n    var getTextColor;\n    function random_hsl_color(min, max) {\n        return ('hsl(' +\n            (Math.random() * 360).toFixed() +\n            ',' +\n            (Math.random() * 30 + 70).toFixed() +\n            '%,' +\n            (Math.random() * (max - min) + min).toFixed() +\n            '%)');\n    }\n    switch (settings.color) {\n        case 'random-dark':\n            getTextColor = function getRandomDarkColor() {\n                return random_hsl_color(10, 50);\n            };\n            break;\n        case 'random-light':\n            getTextColor = function getRandomLightColor() {\n                return random_hsl_color(50, 90);\n            };\n            break;\n        default:\n            if (typeof settings.color === 'function') {\n                getTextColor = settings.color;\n            }\n            break;\n    }\n    /* function for getting the classes of the text */\n    var getTextClasses = null;\n    if (typeof settings.classes === 'function') {\n        getTextClasses = settings.classes;\n    }\n    /* Interactive */\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n    var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n        var canvas = evt.currentTarget;\n        var rect = canvas.getBoundingClientRect();\n        var clientX;\n        var clientY;\n        /** Detect if touches are available */\n        if (evt.touches) {\n            clientX = evt.touches[0].clientX;\n            clientY = evt.touches[0].clientY;\n        }\n        else {\n            clientX = evt.clientX;\n            clientY = evt.clientY;\n        }\n        var eventX = clientX - rect.left;\n        var eventY = clientY - rect.top;\n        var x = Math.floor((eventX * (canvas.width / rect.width || 1)) / g);\n        var y = Math.floor((eventY * (canvas.height / rect.height || 1)) / g);\n        return infoGrid && infoGrid[x] && infoGrid[x][y];\n    };\n    var defaultHoverAction = function defaultHoverAction(item, dimension, evt, start) {\n        if (item) {\n            start(item.id);\n        }\n        else {\n            start(-1);\n        }\n    };\n    var wordcloudhover = function wordcloudhover(evt) {\n        var info = getInfoGridFromMouseTouchEvent(evt);\n        if (hovered === info) {\n            return;\n        }\n        if (twiceRender && info && info.item && !get(info, ['item', 'twiceRender'])) {\n            return;\n        }\n        if (!info) {\n            settings.onWordCloudHover(undefined, undefined, evt, start);\n            if (settings.active) {\n                defaultHoverAction(undefined, undefined, evt, start);\n            }\n            return;\n        }\n        settings.onWordCloudHover(info.item, info.dimension, evt, start);\n        if (settings.active) {\n            defaultHoverAction(info.item, info.dimension, evt, start);\n        }\n        hovered = info;\n    };\n    var wordcloudclick = function wordcloudclick(evt) {\n        var info = getInfoGridFromMouseTouchEvent(evt);\n        if (!info) {\n            return;\n        }\n        settings.onWordCloudClick(info.item, info.dimension, evt);\n        evt.preventDefault();\n    };\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = [];\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n        if (pointsAtRadius[radius]) {\n            return pointsAtRadius[radius];\n        }\n        // Look for these number of points on each radius\n        var T = radius * 8;\n        // Getting all the points at this radius\n        var t = T;\n        var points = [];\n        if (radius === 0) {\n            points.push([center[0], center[1], 0]);\n        }\n        while (t--) {\n            // distort the radius to put the cloud in shape\n            var rx = 1;\n            if (settings.shape !== 'circle') {\n                rx = settings.shape((t / T) * 2 * Math.PI); // 0 to 1\n            }\n            // Push [x, y, t]; t is used solely for getTextColor()\n            points.push([\n                center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),\n                center[1] + radius * rx * Math.sin((-t / T) * 2 * Math.PI) * settings.ellipticity,\n                (t / T) * 2 * Math.PI,\n            ]);\n        }\n        pointsAtRadius[radius] = points;\n        return points;\n    };\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime() {\n        return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n    };\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg() {\n        if (settings.rotateRatio === 0) {\n            return 0;\n        }\n        if (Math.random() > settings.rotateRatio) {\n            return 0;\n        }\n        if (rotationRange === 0) {\n            return minRotation;\n        }\n        // return minRotation + Math.round(Math.random() * rotationRange / rotationSteps) * rotationSteps;\n        if (rotationSteps > 0) {\n            // Min rotation + zero or more steps * span of one step\n            return minRotation + (Math.floor(Math.random() * rotationSteps) * rotationRange) / rotationSteps;\n        }\n        else {\n            return minRotation + Math.random() * rotationRange;\n        }\n    };\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n        // calculate the acutal font size\n        // fontSize === 0 means wants the text skipped,\n        // and size < minSize means we cannot draw the text\n        var debug = false;\n        var fontSize = getRealFontSize(weight);\n        if (fontSize <= 0) {\n            return false;\n        }\n        // Scale factor here is to make sure fillText is not limited by\n        // the minium font size set by browser.\n        // It will always be 1 or 2n.\n        var mu = 1;\n        if (fontSize < minFontSize) {\n            mu = (function calculateScaleFactor() {\n                var mu = 2;\n                while (mu * fontSize < minFontSize) {\n                    mu += 2;\n                }\n                return mu;\n            })();\n        }\n        var fcanvas = document.createElement('canvas');\n        var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n        fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        // Estimate the dimension of the text with measureText().\n        var fw = fctx.measureText(word).width / mu;\n        var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu;\n        // Create a boundary box that is larger than our estimates,\n        // so text don't get cut of (it sill might)\n        var boxWidth = fw + fh * 2;\n        var boxHeight = fh * 3;\n        var fgw = Math.ceil(boxWidth / g);\n        var fgh = Math.ceil(boxHeight / g);\n        boxWidth = fgw * g;\n        boxHeight = fgh * g;\n        // Calculate the proper offsets to make the text centered at\n        // the preferred position.\n        // This is simply half of the width.\n        var fillTextOffsetX = -fw / 2;\n        // Instead of moving the box to the exact middle of the preferred\n        // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n        // vertical centered.\n        var fillTextOffsetY = -fh * 0.4;\n        // Calculate the actual dimension of the canvas, considering the rotation.\n        var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n        var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n        var width = cgw * g;\n        var height = cgh * g;\n        fcanvas.setAttribute('width', width);\n        fcanvas.setAttribute('height', height);\n        if (debug) {\n            // Attach fcanvas to the DOM\n            document.body.appendChild(fcanvas);\n            // Save it's state so that we could restore and draw the grid correctly.\n            fctx.save();\n        }\n        // Scale the canvas with |mu|.\n        fctx.scale(1 / mu, 1 / mu);\n        fctx.translate((width * mu) / 2, (height * mu) / 2);\n        fctx.rotate(-rotateDeg);\n        // Once the width/height is set, ctx info will be reset.\n        // Set it again here.\n        fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        // Fill the text into the fcanvas.\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n        fctx.fillStyle = '#000';\n        fctx.textBaseline = 'middle';\n        fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu);\n        // Get the pixels of the text\n        var imageData;\n        try {\n            imageData = fctx.getImageData(0, 0, width, height).data;\n        }\n        catch (e) {\n            // data not long type\n            return false;\n        }\n        if (exceedTime()) {\n            return false;\n        }\n        if (debug) {\n            // Draw the box of the original estimation\n            fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n            fctx.restore();\n        }\n        // Read the pixels and save the information to the occupied array\n        var occupied = [];\n        var gx = cgw, gy, x, y;\n        var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n        while (gx--) {\n            gy = cgh;\n            while (gy--) {\n                y = g;\n                singleGridLoop: {\n                    while (y--) {\n                        x = g;\n                        while (x--) {\n                            if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                                occupied.push([gx, gy]);\n                                if (gx < bounds[3]) {\n                                    bounds[3] = gx;\n                                }\n                                if (gx > bounds[1]) {\n                                    bounds[1] = gx;\n                                }\n                                if (gy < bounds[0]) {\n                                    bounds[0] = gy;\n                                }\n                                if (gy > bounds[2]) {\n                                    bounds[2] = gy;\n                                }\n                                if (debug) {\n                                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                                }\n                                break singleGridLoop;\n                            }\n                        }\n                    }\n                    if (debug) {\n                        fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n                        fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                    }\n                }\n            }\n        }\n        if (debug) {\n            // real bounds\n            fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n            fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n        }\n        // Return information needed to create the text on the real canvas\n        return {\n            mu: mu,\n            occupied: occupied,\n            bounds: bounds,\n            gw: cgw,\n            gh: cgh,\n            fillTextOffsetX: fillTextOffsetX,\n            fillTextOffsetY: fillTextOffsetY,\n            fillTextWidth: fw,\n            fillTextHeight: fh,\n            fontSize: fontSize,\n        };\n    };\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n        // Go through the occupied points,\n        // return false if the space is not available.\n        var i = occupied.length;\n        while (i--) {\n            var px = gx + occupied[i][0];\n            var py = gy + occupied[i][1];\n            if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                if (!settings.drawOutOfBound) {\n                    return false;\n                }\n                continue;\n            }\n            if (!grid[px][py]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /* Actually draw the text on the grid */\n    var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, id, refresh) {\n        var fontSize = info.fontSize;\n        var color = settings.color;\n        var classes = settings.classes;\n        if (!refresh) {\n            if (getTextColor) {\n                color = getTextColor(word, weight, fontSize, distance, theta);\n            }\n            else {\n                color = settings.color;\n            }\n            if (getTextClasses) {\n                classes = getTextClasses(word, weight, fontSize, distance, theta);\n            }\n            else {\n                classes = settings.classes;\n            }\n        }\n        else {\n            var find = getInteractionItemById(id);\n            color = find ? find.color : settings.color;\n        }\n        var dimension;\n        var bounds = info.bounds;\n        dimension = {\n            x: (gx + bounds[3]) * g,\n            y: (gy + bounds[0]) * g,\n            w: (bounds[1] - bounds[3] + 1) * g,\n            h: (bounds[2] - bounds[0] + 1) * g,\n        };\n        elements.forEach(function (el) {\n            if (el.getContext) {\n                var ctx = el.getContext('2d');\n                var mu = info.mu;\n                // Save the current state before messing it\n                ctx.save();\n                var font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n                ctx.scale(1 / mu, 1 / mu);\n                ctx.font = font;\n                ctx.fillStyle = color;\n                // Translate the canvas position to the origin coordinate of where\n                // the text should be put.\n                var transX = (gx + info.gw / 2) * g * mu;\n                var transY = (gy + info.gh / 2) * g * mu;\n                ctx.translate(transX, transY);\n                if (rotateDeg !== 0) {\n                    ctx.rotate(-rotateDeg);\n                }\n                // Finally, fill the text.\n                // XXX: We cannot because textBaseline = 'top' here because\n                // Firefox and Chrome uses different default line-height for canvas.\n                // Please read https://bugzil.la/737852#c6.\n                // Here, we use textBaseline = 'middle' and draw the text at exactly\n                // 0.5 * fontSize lower.\n                ctx.textBaseline = 'middle';\n                if (settings.selected === id) {\n                    ctx.shadowColor = settings.shadowColor;\n                    ctx.shadowBlur = settings.shadowBlur;\n                }\n                ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu);\n                // The below box is always matches how <span>s are positioned\n                // ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n                //   info.fillTextWidth, info.fillTextHeight);\n                if (!refresh) {\n                    interactionItems.push({\n                        gx: gx,\n                        gy: gy,\n                        info: info,\n                        word: word,\n                        weight: weight,\n                        distance: distance,\n                        theta: theta,\n                        rotateDeg: rotateDeg,\n                        attributes: attributes,\n                        id: id,\n                        color: color,\n                    });\n                }\n                // Restore the state.\n                ctx.restore();\n            }\n            else {\n                // drawText on DIV element\n                var span = document.createElement('span');\n                var transformRule = '';\n                transformRule = 'rotate(' + (-rotateDeg / Math.PI) * 180 + 'deg) ';\n                if (info.mu !== 1) {\n                    transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n                }\n                var styleRules = {\n                    position: 'absolute',\n                    display: 'block',\n                    font: settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n                    left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n                    top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n                    width: info.fillTextWidth + 'px',\n                    height: info.fillTextHeight + 'px',\n                    lineHeight: fontSize + 'px',\n                    whiteSpace: 'nowrap',\n                    transform: transformRule,\n                    webkitTransform: transformRule,\n                    msTransform: transformRule,\n                    transformOrigin: '50% 40%',\n                    webkitTransformOrigin: '50% 40%',\n                    msTransformOrigin: '50% 40%',\n                };\n                if (color) {\n                    styleRules.color = color;\n                }\n                span.textContent = word;\n                for (var cssProp in styleRules) {\n                    span.style[cssProp] = styleRules[cssProp];\n                }\n                if (attributes) {\n                    for (var attribute in attributes) {\n                        span.setAttribute(attribute, attributes[attribute]);\n                    }\n                }\n                if (classes) {\n                    span.className += classes;\n                }\n                el.appendChild(span);\n            }\n        });\n    };\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n        if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n            return;\n        }\n        grid[x][y] = false;\n        if (drawMask) {\n            var ctx = elements[0].getContext('2d');\n            ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n        }\n        if (interactive) {\n            infoGrid[x][y] = { item: item, dimension: dimension };\n        }\n    };\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info) {\n        var occupied = info.occupied;\n        var drawMask = settings.drawMask;\n        var ctx;\n        if (drawMask) {\n            ctx = elements[0].getContext('2d');\n            ctx.save();\n            ctx.fillStyle = settings.maskColor;\n        }\n        var dimension;\n        if (interactive) {\n            var bounds = info.bounds;\n            dimension = {\n                x: (gx + bounds[3]) * g,\n                y: (gy + bounds[0]) * g,\n                w: (bounds[1] - bounds[3] + 1) * g,\n                h: (bounds[2] - bounds[0] + 1) * g,\n            };\n        }\n        var i = occupied.length;\n        while (i--) {\n            var px = gx + occupied[i][0];\n            var py = gy + occupied[i][1];\n            if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n                continue;\n            }\n            // save item's color from info\n            var find = getInteractionItemById(info.item.id);\n            if (find) {\n                info.item.color = find.color;\n            }\n            fillGridAt(px, py, drawMask, dimension, info.item);\n        }\n        if (drawMask) {\n            ctx.restore();\n        }\n    };\n    var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy, info, word, weight, distance, rotateDeg, attributes, id) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh;\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n            return false;\n        }\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight, distance, gxy[2], rotateDeg, attributes, id, false);\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info);\n        return {\n            gx: gx,\n            gy: gy,\n            rot: rotateDeg,\n            info: info,\n        };\n    };\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord(item) {\n        var word, weight, attributes, id;\n        if (Array.isArray(item)) {\n            word = item[0];\n            weight = item[1];\n        }\n        else {\n            word = item.word;\n            weight = item.weight;\n            attributes = item.attributes;\n            id = item.id;\n        }\n        var rotateDeg = isNil(item.rotateDeg) ? getRotateDeg() : item.rotateDeg;\n        // get info needed to put the text onto the canvas\n        var info = getTextInfo(word, weight, rotateDeg);\n        if (info) {\n            info['item'] = item;\n        }\n        // not getting the info means we shouldn't be drawing this one.\n        if (!info) {\n            return false;\n        }\n        if (exceedTime()) {\n            return false;\n        }\n        // If drawOutOfBound is set to false,\n        // skip the loop if we have already know the bounding box of\n        // word is larger than the canvas.\n        if (!settings.drawOutOfBound) {\n            var bounds = info.bounds;\n            if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n                return false;\n            }\n        }\n        // Determine the position to put the text by\n        // start looking for the nearest points\n        var r = maxRadius + 1;\n        while (r--) {\n            var points = getPointsAtRadius(maxRadius - r);\n            if (settings.shuffle) {\n                points = [].concat(points);\n                shuffleArray(points);\n            }\n            // Try to fit the words by looking at each point.\n            // array.some() will stop and return true\n            // when putWordAtPoint() returns true.\n            for (var i = 0; i < points.length; i++) {\n                var res = tryToPutWordAtPoint(points[i], info, word, weight, maxRadius - r, rotateDeg, attributes, id);\n                if (res) {\n                    return res;\n                }\n            }\n            // var drawn = points.some(tryToPutWordAtPoint);\n            // if (drawn) {\n            //   // leave putWord() and return true\n            //   return true;\n            // }\n        }\n        // we tried all distances but text won't fit, return null\n        return null;\n    };\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n        if (cancelable) {\n            return !elements.some(function (el) {\n                var evt = document.createEvent('CustomEvent');\n                evt.initCustomEvent(type, true, cancelable, detail || {});\n                return !el.dispatchEvent(evt);\n            }, this);\n        }\n        else {\n            elements.forEach(function (el) {\n                var evt = document.createEvent('CustomEvent');\n                evt.initCustomEvent(type, true, cancelable, detail || {});\n                el.dispatchEvent(evt);\n            }, this);\n        }\n    };\n    var getInteractionItemById = function getInteractionItemById(id) {\n        for (var i = 0; i < interactionItems.length; i++) {\n            var find = interactionItems[i];\n            if (interactionItems[i].id === id) {\n                return find;\n            }\n        }\n        return undefined;\n    };\n    var twiceRender;\n    /* Start drawing on a canvas */\n    var start = function start(selected) {\n        if (selected !== undefined) {\n            // re-refresh canvas with selected\n            // work in canvas only for now\n            if (settings.selected !== selected && elements[0].getContext) {\n                settings.selected = selected;\n                var ctx = elements[0].getContext('2d');\n                // draw background\n                ctx.fillStyle = settings.backgroundColor;\n                ctx.clearRect(0, 0, elements[0].width, elements[0].height);\n                ctx.fillRect(0, 0, elements[0].width, elements[0].height);\n                // draw text\n                for (var i_1 = 0; i_1 < interactionItems.length; i_1++) {\n                    var find = interactionItems[i_1];\n                    if (!twiceRender || (twiceRender && get(find, ['info', 'item', 'twiceRender']))) {\n                        /**\n                         * 词云图词量较少的时候，重新渲染一次词汇，放大词云图效果\n                         * 这里先临时解决，后续还是需要优化词云图算法来解决\n                         */\n                        drawText(find.gx, find.gy, find.info, find.word, find.weight, find.distance, find.theta, find.rotateDeg, find.attributes, find.id, true);\n                    }\n                }\n            }\n            return;\n        }\n        // For dimensions, clearCanvas etc.,\n        // we only care about the first element.\n        var canvas = elements[0];\n        if (canvas.getContext) {\n            ngx = Math.ceil(canvas.width / g);\n            ngy = Math.ceil(canvas.height / g);\n        }\n        else {\n            var rect = canvas.getBoundingClientRect();\n            ngx = Math.ceil(rect.width / g);\n            ngy = Math.ceil(rect.height / g);\n        }\n        // Sending a wordcloudstart event which cause the previous loop to stop.\n        // Do nothing if the event is canceled.\n        if (!sendEvent('wordcloudstart', true)) {\n            return;\n        }\n        // Determine the center of the word cloud\n        center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / (isCardioid ? 4 : 2)];\n        // Maxium radius to look for space\n        maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n        /* Clear the canvas only if the clearCanvas is set,\n           if not, update the grid to the current canvas state */\n        grid = [];\n        var gx, gy, i;\n        if (!canvas.getContext || settings.clearCanvas) {\n            elements.forEach(function (el) {\n                if (el.getContext) {\n                    var ctx = el.getContext('2d');\n                    ctx.fillStyle = settings.backgroundColor;\n                    ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                    ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                }\n                else {\n                    el.textContent = '';\n                    el.style.backgroundColor = settings.backgroundColor;\n                    el.style.position = 'relative';\n                }\n            });\n            /* fill the grid with empty state */\n            gx = ngx;\n            while (gx--) {\n                grid[gx] = [];\n                gy = ngy;\n                while (gy--) {\n                    grid[gx][gy] = true;\n                }\n            }\n        }\n        else {\n            /* Determine bgPixel by creating\n               another canvas and fill the specified background color. */\n            var bctx = document.createElement('canvas').getContext('2d');\n            bctx.fillStyle = settings.backgroundColor;\n            bctx.fillRect(0, 0, 1, 1);\n            var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n            /* Read back the pixels of the canvas we got to tell which part of the\n               canvas is empty.\n               (no clearCanvas only works with a canvas, not divs) */\n            var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n            gx = ngx;\n            var x, y;\n            while (gx--) {\n                grid[gx] = [];\n                gy = ngy;\n                while (gy--) {\n                    y = g;\n                    singleGridLoop: while (y--) {\n                        x = g;\n                        while (x--) {\n                            i = 4;\n                            while (i--) {\n                                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                                    grid[gx][gy] = false;\n                                    break singleGridLoop;\n                                }\n                            }\n                        }\n                    }\n                    if (grid[gx][gy] !== false) {\n                        grid[gx][gy] = true;\n                    }\n                }\n            }\n            imageData = bctx = bgPixel = undefined;\n        }\n        // fill the infoGrid with empty state if we need it\n        if (settings.onWordCloudHover || settings.onWordCloudClick) {\n            interactive = true;\n            /* fill the grid with empty state */\n            gx = ngx + 1;\n            while (gx--) {\n                infoGrid[gx] = [];\n            }\n            if (settings.onWordCloudHover) {\n                canvas.addEventListener('mousemove', wordcloudhover);\n            }\n            if (settings.onWordCloudClick) {\n                canvas.addEventListener('click', wordcloudclick);\n                canvas.addEventListener('touchstart', wordcloudclick);\n                canvas.addEventListener('touchend', function (e) {\n                    e.preventDefault();\n                });\n                canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n            }\n            canvas.addEventListener('wordcloudstart', function stopInteraction() {\n                canvas.removeEventListener('wordcloudstart', stopInteraction);\n                canvas.removeEventListener('mousemove', wordcloudhover);\n                canvas.removeEventListener('click', wordcloudclick);\n                hovered = undefined;\n            });\n        }\n        if (!settings.animatable) {\n            if (options.maskImage) {\n                /** 修复颜色透明，还留有 maskImage 的情况 */\n                elements.forEach(function (el) {\n                    if (el.getContext) {\n                        var ctx = el.getContext('2d');\n                        ctx.fillStyle = settings.backgroundColor;\n                        ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                        ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                    }\n                });\n            }\n            var renderedWords = [];\n            for (var i_2 = 0; i_2 < settings.data.length; i_2++) {\n                var response = putWord(settings.data[i_2]);\n                if (response) {\n                    renderedWords.push(response);\n                }\n            }\n            if (renderedWords.length === settings.data.length) {\n                if (!twiceRender) {\n                    elements.forEach(function (el) {\n                        if (el.getContext) {\n                            var ctx = el.getContext('2d');\n                            ctx.fillStyle = settings.backgroundColor;\n                            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n                        }\n                    });\n                    /* fill the grid with empty state */\n                    gx = ngx;\n                    while (gx--) {\n                        grid[gx] = [];\n                        gy = ngy;\n                        while (gy--) {\n                            grid[gx][gy] = true;\n                        }\n                    }\n                    twiceRender = true;\n                    for (var i_3 = 0; i_3 < settings.data.length; i_3++) {\n                        putWord(__assign(__assign({}, settings.data[i_3]), { twiceRender: twiceRender }));\n                    }\n                }\n            }\n        }\n        else {\n            i = 0;\n            var loopingFunction, stoppingFunction;\n            if (settings.wait !== 0) {\n                loopingFunction = window.setTimeout;\n                stoppingFunction = window.clearTimeout;\n            }\n            else {\n                loopingFunction = window.setImmediate;\n                stoppingFunction = window.clearImmediate;\n            }\n            var addEventListener = function addEventListener(type, listener) {\n                elements.forEach(function (el) {\n                    el.addEventListener(type, listener);\n                }, this);\n            };\n            var removeEventListener = function removeEventListener(type, listener) {\n                elements.forEach(function (el) {\n                    el.removeEventListener(type, listener);\n                }, this);\n            };\n            var anotherWordCloudStart = function anotherWordCloudStart() {\n                removeEventListener('wordcloudstart', anotherWordCloudStart);\n                stoppingFunction(timer);\n            };\n            addEventListener('wordcloudstart', anotherWordCloudStart);\n            var timer = loopingFunction(function loop() {\n                if (i >= settings.data.length) {\n                    stoppingFunction(timer);\n                    sendEvent('wordcloudstop', false);\n                    removeEventListener('wordcloudstart', anotherWordCloudStart);\n                    return;\n                }\n                escapeTime = new Date().getTime();\n                var drawn = putWord(settings.data[i]);\n                var canceled = !sendEvent('wordclouddrawn', true, {\n                    item: settings.data[i],\n                    drawn: drawn,\n                });\n                if (exceedTime() || canceled) {\n                    stoppingFunction(timer);\n                    settings.abort();\n                    sendEvent('wordcloudabort', false);\n                    sendEvent('wordcloudstop', false);\n                    removeEventListener('wordcloudstart', anotherWordCloudStart);\n                    return;\n                }\n                i++;\n                timer = loopingFunction(loop, settings.wait);\n            }, settings.wait);\n        }\n    };\n    // All set, start the drawing\n    start();\n};\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\nexport default WordCloud;\n//# sourceMappingURL=wordcloud2.js.map"]}]}