{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\build-layer-graph.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\build-layer-graph.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var _ = require(\"../lodash\"), Graph = require(\"../graphlib\").Graph;\r\nmodule.exports = buildLayerGraph;\r\nfunction buildLayerGraph(g, rank, relationship) {\r\n    var root = createRootNode(g), result = new Graph({ compound: true }).setGraph({ root: root })\r\n        .setDefaultNodeLabel(function (v) { return g.node(v); });\r\n    _.forEach(g.nodes(), function (v) {\r\n        var node = g.node(v), parent = g.parent(v);\r\n        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\r\n            result.setNode(v);\r\n            result.setParent(v, parent || root);\r\n            _.forEach(g[relationship](v), function (e) {\r\n                var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_.isUndefined(edge) ? edge.weight : 0;\r\n                result.setEdge(u, v, { weight: g.edge(e).weight + weight });\r\n            });\r\n            if (_.has(node, \"minRank\")) {\r\n                result.setNode(v, {\r\n                    borderLeft: node.borderLeft[rank],\r\n                    borderRight: node.borderRight[rank]\r\n                });\r\n            }\r\n        }\r\n    });\r\n    return result;\r\n}\r\nfunction createRootNode(g) {\r\n    var v;\r\n    while (g.hasNode((v = _.uniqueId(\"_root\"))))\r\n        ;\r\n    return v;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\build-layer-graph.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\order\\build-layer-graph.js"],"names":[],"mappings":"AAAA,IAAI,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,EACxB,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC,KAAK,CAAC;AAEzC,MAAM,CAAC,OAAO,GAAG,eAAe,CAAC;AAgCjC,SAAS,eAAe,CAAC,CAAC,EAAE,IAAI,EAAE,YAAY;IAC5C,IAAI,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,EACxB,MAAM,GAAG,IAAI,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;SAClD,mBAAmB,CAAC,UAAS,CAAC,IAAI,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAExE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,UAAS,CAAC;QAC7B,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAChB,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAEzB,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YACtE,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,IAAI,IAAI,CAAC,CAAC;YAGpC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE,UAAS,CAAC;gBACtC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACzB,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EACxB,MAAM,GAAG,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpD,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC,CAAC;YAC9D,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE;gBAC1B,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE;oBAChB,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;oBACjC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;iBACpC,CAAC,CAAC;aACJ;SACF;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,cAAc,CAAC,CAAC;IACvB,IAAI,CAAC,CAAC;IACN,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QAAC,CAAC;IAC7C,OAAO,CAAC,CAAC;AACX,CAAC","sourcesContent":["var _ = require(\"../lodash\"),\n    Graph = require(\"../graphlib\").Graph;\n\nmodule.exports = buildLayerGraph;\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n      result = new Graph({ compound: true }).setGraph({ root: root })\n                  .setDefaultNodeLabel(function(v) { return g.node(v); });\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v),\n        parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function(e) {\n        var u = e.v === v ? e.w : e.v,\n            edge = result.edge(u, v),\n            weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_.has(node, \"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId(\"_root\"))));\n  return v;\n}\n"]}]}