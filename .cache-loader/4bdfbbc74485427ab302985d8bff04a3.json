{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\remark-parse\\lib\\tokenize\\table.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\remark-parse\\lib\\tokenize\\table.js","mtime":1516191690000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["'use strict';\r\nvar whitespace = require('is-whitespace-character');\r\nmodule.exports = table;\r\nvar C_BACKSLASH = '\\\\';\r\nvar C_TICK = '`';\r\nvar C_DASH = '-';\r\nvar C_PIPE = '|';\r\nvar C_COLON = ':';\r\nvar C_SPACE = ' ';\r\nvar C_NEWLINE = '\\n';\r\nvar C_TAB = '\\t';\r\nvar MIN_TABLE_COLUMNS = 1;\r\nvar MIN_TABLE_ROWS = 2;\r\nvar TABLE_ALIGN_LEFT = 'left';\r\nvar TABLE_ALIGN_CENTER = 'center';\r\nvar TABLE_ALIGN_RIGHT = 'right';\r\nvar TABLE_ALIGN_NONE = null;\r\nfunction table(eat, value, silent) {\r\n    var self = this;\r\n    var index;\r\n    var alignments;\r\n    var alignment;\r\n    var subvalue;\r\n    var row;\r\n    var length;\r\n    var lines;\r\n    var queue;\r\n    var character;\r\n    var hasDash;\r\n    var align;\r\n    var cell;\r\n    var preamble;\r\n    var count;\r\n    var opening;\r\n    var now;\r\n    var position;\r\n    var lineCount;\r\n    var line;\r\n    var rows;\r\n    var table;\r\n    var lineIndex;\r\n    var pipeIndex;\r\n    var first;\r\n    if (!self.options.gfm) {\r\n        return;\r\n    }\r\n    index = 0;\r\n    lineCount = 0;\r\n    length = value.length + 1;\r\n    lines = [];\r\n    while (index < length) {\r\n        lineIndex = value.indexOf(C_NEWLINE, index);\r\n        pipeIndex = value.indexOf(C_PIPE, index + 1);\r\n        if (lineIndex === -1) {\r\n            lineIndex = value.length;\r\n        }\r\n        if (pipeIndex === -1 || pipeIndex > lineIndex) {\r\n            if (lineCount < MIN_TABLE_ROWS) {\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        lines.push(value.slice(index, lineIndex));\r\n        lineCount++;\r\n        index = lineIndex + 1;\r\n    }\r\n    subvalue = lines.join(C_NEWLINE);\r\n    alignments = lines.splice(1, 1)[0] || [];\r\n    index = 0;\r\n    length = alignments.length;\r\n    lineCount--;\r\n    alignment = false;\r\n    align = [];\r\n    while (index < length) {\r\n        character = alignments.charAt(index);\r\n        if (character === C_PIPE) {\r\n            hasDash = null;\r\n            if (alignment === false) {\r\n                if (first === false) {\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                align.push(alignment);\r\n                alignment = false;\r\n            }\r\n            first = false;\r\n        }\r\n        else if (character === C_DASH) {\r\n            hasDash = true;\r\n            alignment = alignment || TABLE_ALIGN_NONE;\r\n        }\r\n        else if (character === C_COLON) {\r\n            if (alignment === TABLE_ALIGN_LEFT) {\r\n                alignment = TABLE_ALIGN_CENTER;\r\n            }\r\n            else if (hasDash && alignment === TABLE_ALIGN_NONE) {\r\n                alignment = TABLE_ALIGN_RIGHT;\r\n            }\r\n            else {\r\n                alignment = TABLE_ALIGN_LEFT;\r\n            }\r\n        }\r\n        else if (!whitespace(character)) {\r\n            return;\r\n        }\r\n        index++;\r\n    }\r\n    if (alignment !== false) {\r\n        align.push(alignment);\r\n    }\r\n    if (align.length < MIN_TABLE_COLUMNS) {\r\n        return;\r\n    }\r\n    if (silent) {\r\n        return true;\r\n    }\r\n    position = -1;\r\n    rows = [];\r\n    table = eat(subvalue).reset({\r\n        type: 'table',\r\n        align: align,\r\n        children: rows\r\n    });\r\n    while (++position < lineCount) {\r\n        line = lines[position];\r\n        row = { type: 'tableRow', children: [] };\r\n        if (position) {\r\n            eat(C_NEWLINE);\r\n        }\r\n        eat(line).reset(row, table);\r\n        length = line.length + 1;\r\n        index = 0;\r\n        queue = '';\r\n        cell = '';\r\n        preamble = true;\r\n        count = null;\r\n        opening = null;\r\n        while (index < length) {\r\n            character = line.charAt(index);\r\n            if (character === C_TAB || character === C_SPACE) {\r\n                if (cell) {\r\n                    queue += character;\r\n                }\r\n                else {\r\n                    eat(character);\r\n                }\r\n                index++;\r\n                continue;\r\n            }\r\n            if (character === '' || character === C_PIPE) {\r\n                if (preamble) {\r\n                    eat(character);\r\n                }\r\n                else {\r\n                    if (character && opening) {\r\n                        queue += character;\r\n                        index++;\r\n                        continue;\r\n                    }\r\n                    if ((cell || character) && !preamble) {\r\n                        subvalue = cell;\r\n                        if (queue.length > 1) {\r\n                            if (character) {\r\n                                subvalue += queue.slice(0, queue.length - 1);\r\n                                queue = queue.charAt(queue.length - 1);\r\n                            }\r\n                            else {\r\n                                subvalue += queue;\r\n                                queue = '';\r\n                            }\r\n                        }\r\n                        now = eat.now();\r\n                        eat(subvalue)({\r\n                            type: 'tableCell',\r\n                            children: self.tokenizeInline(cell, now)\r\n                        }, row);\r\n                    }\r\n                    eat(queue + character);\r\n                    queue = '';\r\n                    cell = '';\r\n                }\r\n            }\r\n            else {\r\n                if (queue) {\r\n                    cell += queue;\r\n                    queue = '';\r\n                }\r\n                cell += character;\r\n                if (character === C_BACKSLASH && index !== length - 2) {\r\n                    cell += line.charAt(index + 1);\r\n                    index++;\r\n                }\r\n                if (character === C_TICK) {\r\n                    count = 1;\r\n                    while (line.charAt(index + 1) === character) {\r\n                        cell += character;\r\n                        index++;\r\n                        count++;\r\n                    }\r\n                    if (!opening) {\r\n                        opening = count;\r\n                    }\r\n                    else if (count >= opening) {\r\n                        opening = 0;\r\n                    }\r\n                }\r\n            }\r\n            preamble = false;\r\n            index++;\r\n        }\r\n        if (!position) {\r\n            eat(C_NEWLINE + alignments);\r\n        }\r\n    }\r\n    return table;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\remark-parse\\lib\\tokenize\\table.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\remark-parse\\lib\\tokenize\\table.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\n\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {type: 'tableRow', children: []};\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}\n"]}]}