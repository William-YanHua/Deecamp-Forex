{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-voronoi/src/Cell.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-voronoi/src/Cell.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { createBorderEdge } from \"./Edge\";\nimport { cells, edges, epsilon } from \"./Diagram\";\nexport function createCell(site) {\n    return cells[site.index] = {\n        site: site,\n        halfedges: []\n    };\n}\nfunction cellHalfedgeAngle(cell, edge) {\n    var site = cell.site, va = edge.left, vb = edge.right;\n    if (site === vb)\n        vb = va, va = site;\n    if (vb)\n        return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n    if (site === va)\n        va = edge[1], vb = edge[0];\n    else\n        va = edge[0], vb = edge[1];\n    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\nexport function cellHalfedgeStart(cell, edge) {\n    return edge[+(edge.left !== cell.site)];\n}\nexport function cellHalfedgeEnd(cell, edge) {\n    return edge[+(edge.left === cell.site)];\n}\nexport function sortCellHalfedges() {\n    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n        if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n            var index = new Array(m), array = new Array(m);\n            for (j = 0; j < m; ++j)\n                index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n            index.sort(function (i, j) { return array[j] - array[i]; });\n            for (j = 0; j < m; ++j)\n                array[j] = halfedges[index[j]];\n            for (j = 0; j < m; ++j)\n                halfedges[j] = array[j];\n        }\n    }\n}\nexport function clipCells(x0, y0, x1, y1) {\n    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;\n    for (iCell = 0; iCell < nCells; ++iCell) {\n        if (cell = cells[iCell]) {\n            site = cell.site;\n            halfedges = cell.halfedges;\n            iHalfedge = halfedges.length;\n            while (iHalfedge--) {\n                if (!edges[halfedges[iHalfedge]]) {\n                    halfedges.splice(iHalfedge, 1);\n                }\n            }\n            iHalfedge = 0, nHalfedges = halfedges.length;\n            while (iHalfedge < nHalfedges) {\n                end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n                start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n                if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n                    halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n                        : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n                            : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n                                : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n                                    : null)) - 1);\n                    ++nHalfedges;\n                }\n            }\n            if (nHalfedges)\n                cover = false;\n        }\n    }\n    if (cover) {\n        var dx, dy, d2, dc = Infinity;\n        for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n            if (cell = cells[iCell]) {\n                site = cell.site;\n                dx = site[0] - x0;\n                dy = site[1] - y0;\n                d2 = dx * dx + dy * dy;\n                if (d2 < dc)\n                    dc = d2, cover = cell;\n            }\n        }\n        if (cover) {\n            var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n            cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);\n        }\n    }\n    for (iCell = 0; iCell < nCells; ++iCell) {\n        if (cell = cells[iCell]) {\n            if (!cell.halfedges.length) {\n                delete cells[iCell];\n            }\n        }\n    }\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-voronoi/src/Cell.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-voronoi/src/Cell.js"],"names":[],"mappings":"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","sourcesContent":["import {createBorderEdge} from \"./Edge\";\nimport {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n"]}]}