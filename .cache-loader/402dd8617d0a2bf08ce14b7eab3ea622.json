{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/event/event-contoller.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/event/event-contoller.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = [\n    'mousedown',\n    'mouseup',\n    'dblclick',\n    'mouseout',\n    'mouseover',\n    'mousemove',\n    'mouseleave',\n    'mouseenter',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'dragenter',\n    'dragover',\n    'dragleave',\n    'drop',\n    'contextmenu',\n    'mousewheel',\n];\nfunction hasDelegation(events, type) {\n    for (var key in events) {\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction emitTargetEvent(target, type, eventObj) {\n    eventObj.name = type;\n    eventObj.target = target;\n    eventObj.currentTarget = target;\n    eventObj.delegateTarget = target;\n    target.emit(type, eventObj);\n}\nfunction bubbleEvent(container, type, eventObj) {\n    if (eventObj.bubbles) {\n        var relativeShape = void 0;\n        var isOverEvent = false;\n        if (type === 'mouseenter') {\n            relativeShape = eventObj.fromShape;\n            isOverEvent = true;\n        }\n        else if (type === 'mouseleave') {\n            isOverEvent = true;\n            relativeShape = eventObj.toShape;\n        }\n        if (container.isCanvas() && isOverEvent) {\n            return;\n        }\n        if (relativeShape && isParent(container, relativeShape)) {\n            eventObj.bubbles = false;\n            return;\n        }\n        eventObj.name = type;\n        eventObj.currentTarget = container;\n        eventObj.delegateTarget = container;\n        container.emit(type, eventObj);\n    }\n}\nvar EventController = (function () {\n    function EventController(cfg) {\n        var _this = this;\n        this.draggingShape = null;\n        this.dragging = false;\n        this.currentShape = null;\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n        this._eventCallback = function (ev) {\n            var type = ev.type;\n            _this._triggerEvent(type, ev);\n        };\n        this._onDocumentMove = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                if (_this.dragging || _this.currentShape) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    if (_this.dragging) {\n                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n                    }\n                }\n            }\n        };\n        this._onDocumentMouseUp = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                if (_this.dragging) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    if (_this.draggingShape) {\n                        _this._emitEvent('drop', ev, pointInfo, null);\n                    }\n                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n                    _this._afterDrag(_this.draggingShape, pointInfo, ev);\n                }\n            }\n        };\n        this.canvas = cfg.canvas;\n    }\n    EventController.prototype.init = function () {\n        this._bindEvents();\n    };\n    EventController.prototype._bindEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.addEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            document.addEventListener('mousemove', this._onDocumentMove);\n            document.addEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    EventController.prototype._clearEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.removeEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            document.removeEventListener('mousemove', this._onDocumentMove);\n            document.removeEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n        var eventObj = new GraphEvent(type, event);\n        eventObj.fromShape = fromShape;\n        eventObj.toShape = toShape;\n        eventObj.x = point.x;\n        eventObj.y = point.y;\n        eventObj.clientX = point.clientX;\n        eventObj.clientY = point.clientY;\n        eventObj.propagationPath.push(target);\n        return eventObj;\n    };\n    EventController.prototype._getShape = function (point, ev) {\n        return this.canvas.getShape(point.x, point.y, ev);\n    };\n    EventController.prototype._getPointInfo = function (ev) {\n        var canvas = this.canvas;\n        var clientPoint = canvas.getClientByEvent(ev);\n        var point = canvas.getPointByEvent(ev);\n        return {\n            x: point.x,\n            y: point.y,\n            clientX: clientPoint.x,\n            clientY: clientPoint.y,\n        };\n    };\n    EventController.prototype._triggerEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        var shape = this._getShape(pointInfo, ev);\n        var method = this[\"_on\" + type];\n        var leaveCanvas = false;\n        if (method) {\n            method.call(this, pointInfo, shape, ev);\n        }\n        else {\n            var preShape = this.currentShape;\n            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n                this._emitEvent(type, ev, pointInfo, null, null, shape);\n                if (shape) {\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape);\n                }\n                if (type === 'mouseenter' && this.draggingShape) {\n                    this._emitEvent('dragenter', ev, pointInfo, null);\n                }\n            }\n            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n                leaveCanvas = true;\n                if (preShape) {\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null);\n                }\n                this._emitEvent(type, ev, pointInfo, null, preShape, null);\n                if (type === 'mouseleave' && this.draggingShape) {\n                    this._emitEvent('dragleave', ev, pointInfo, null);\n                }\n            }\n            else {\n                this._emitEvent(type, ev, pointInfo, shape, null, null);\n            }\n        }\n        if (!leaveCanvas) {\n            this.currentShape = shape;\n        }\n        if (shape && !shape.get('destroyed')) {\n            var canvas = this.canvas;\n            var el = canvas.get('el');\n            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n        }\n    };\n    EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n        if (event.button === LEFT_BTN_CODE) {\n            this.mousedownShape = shape;\n            this.mousedownPoint = pointInfo;\n            this.mousedownTimeStamp = event.timeStamp;\n        }\n        this._emitEvent('mousedown', event, pointInfo, shape, null, null);\n    };\n    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n        var el = this.canvas.get('el');\n        if (fromShape !== toShape) {\n            if (fromShape) {\n                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n                if (!toShape || toShape.get('destroyed')) {\n                    el.style.cursor = this.canvas.get('cursor');\n                }\n            }\n            if (toShape) {\n                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n        }\n    };\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n        if (toShape) {\n            if (toShape !== fromShape) {\n                if (fromShape) {\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n                }\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n            if (!isCanvasEmit) {\n                this._emitEvent('dragover', event, pointInfo, toShape);\n            }\n        }\n        else if (fromShape) {\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        if (isCanvasEmit) {\n            this._emitEvent('dragover', event, pointInfo, toShape);\n        }\n    };\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n        if (draggingShape) {\n            draggingShape.set('capture', true);\n            this.draggingShape = null;\n        }\n        this.dragging = false;\n        var shape = this._getShape(pointInfo, event);\n        if (shape !== draggingShape) {\n            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n        }\n        this.currentShape = shape;\n    };\n    EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n        if (event.button === LEFT_BTN_CODE) {\n            var draggingShape = this.draggingShape;\n            if (this.dragging) {\n                if (draggingShape) {\n                    this._emitEvent('drop', event, pointInfo, shape);\n                }\n                this._emitEvent('dragend', event, pointInfo, draggingShape);\n                this._afterDrag(draggingShape, pointInfo, event);\n            }\n            else {\n                this._emitEvent('mouseup', event, pointInfo, shape);\n                if (shape === this.mousedownShape) {\n                    this._emitEvent('click', event, pointInfo, shape);\n                }\n                this.mousedownShape = null;\n                this.mousedownPoint = null;\n            }\n        }\n    };\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\n        event.preventDefault();\n        var preShape = this.currentShape;\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n    };\n    EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n        var canvas = this.canvas;\n        var preShape = this.currentShape;\n        var draggingShape = this.draggingShape;\n        if (this.dragging) {\n            if (draggingShape) {\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n            }\n            this._emitEvent('drag', event, pointInfo, draggingShape);\n        }\n        else {\n            var mousedownPoint = this.mousedownPoint;\n            if (mousedownPoint) {\n                var mousedownShape = this.mousedownShape;\n                var now = event.timeStamp;\n                var timeWindow = now - this.mousedownTimeStamp;\n                var dx = mousedownPoint.clientX - pointInfo.clientX;\n                var dy = mousedownPoint.clientY - pointInfo.clientY;\n                var dist = dx * dx + dy * dy;\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\n                    if (mousedownShape && mousedownShape.get('draggable')) {\n                        draggingShape = this.mousedownShape;\n                        draggingShape.set('capture', false);\n                        this.draggingShape = draggingShape;\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else if (!mousedownShape && canvas.get('draggable')) {\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, null);\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else {\n                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                        this._emitEvent('mousemove', event, pointInfo, shape);\n                    }\n                }\n                else {\n                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                    this._emitEvent('mousemove', event, pointInfo, shape);\n                }\n            }\n            else {\n                this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                this._emitEvent('mousemove', event, pointInfo, shape);\n            }\n        }\n    };\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n        if (shape) {\n            eventObj.shape = shape;\n            emitTargetEvent(shape, type, eventObj);\n            var parent_1 = shape.getParent();\n            while (parent_1) {\n                parent_1.emitDelegation(type, eventObj);\n                if (!eventObj.propagationStopped) {\n                    bubbleEvent(parent_1, type, eventObj);\n                }\n                eventObj.propagationPath.push(parent_1);\n                parent_1 = parent_1.getParent();\n            }\n        }\n        else {\n            var canvas = this.canvas;\n            emitTargetEvent(canvas, type, eventObj);\n        }\n    };\n    EventController.prototype.destroy = function () {\n        this._clearEvents();\n        this.canvas = null;\n        this.currentShape = null;\n        this.draggingShape = null;\n        this.mousedownPoint = null;\n        this.mousedownShape = null;\n        this.mousedownTimeStamp = null;\n    };\n    return EventController;\n}());\nexport default EventController;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/event/event-contoller.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-base/esm/event/event-contoller.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = [\n    'mousedown',\n    'mouseup',\n    'dblclick',\n    'mouseout',\n    'mouseover',\n    'mousemove',\n    'mouseleave',\n    'mouseenter',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'dragenter',\n    'dragover',\n    'dragleave',\n    'drop',\n    'contextmenu',\n    'mousewheel',\n];\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n    for (var key in events) {\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n    eventObj.name = type;\n    eventObj.target = target;\n    eventObj.currentTarget = target;\n    eventObj.delegateTarget = target;\n    target.emit(type, eventObj);\n}\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n    if (eventObj.bubbles) {\n        var relativeShape = void 0;\n        var isOverEvent = false;\n        if (type === 'mouseenter') {\n            relativeShape = eventObj.fromShape;\n            isOverEvent = true;\n        }\n        else if (type === 'mouseleave') {\n            isOverEvent = true;\n            relativeShape = eventObj.toShape;\n        }\n        // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n        if (container.isCanvas() && isOverEvent) {\n            return;\n        }\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\n        if (relativeShape && isParent(container, relativeShape)) {\n            // 阻止继续向上冒泡\n            eventObj.bubbles = false;\n            return;\n        }\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n        eventObj.name = type;\n        eventObj.currentTarget = container;\n        eventObj.delegateTarget = container;\n        container.emit(type, eventObj);\n    }\n}\nvar EventController = /** @class */ (function () {\n    function EventController(cfg) {\n        var _this = this;\n        // 正在被拖拽的图形\n        this.draggingShape = null;\n        this.dragging = false;\n        // 当前鼠标/touch所在位置的图形\n        this.currentShape = null;\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n        // 统一处理所有的回调\n        this._eventCallback = function (ev) {\n            var type = ev.type;\n            _this._triggerEvent(type, ev);\n        };\n        // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n        this._onDocumentMove = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging || _this.currentShape) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    // 还在拖拽过程中\n                    if (_this.dragging) {\n                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n                    }\n                    // 说明从某个图形直接移动到了画布外面，\n                    // 修复了 mouseleave 的 bug 后不再出现这种情况\n                    // if (this.currentShape) {\n                    //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n                    //   this.currentShape = null;\n                    // }\n                }\n            }\n        };\n        // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n        this._onDocumentMouseUp = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    if (_this.draggingShape) {\n                        // 如果存在拖拽的图形，则也触发 drop 事件\n                        _this._emitEvent('drop', ev, pointInfo, null);\n                    }\n                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n                    _this._afterDrag(_this.draggingShape, pointInfo, ev);\n                }\n            }\n        };\n        this.canvas = cfg.canvas;\n    }\n    EventController.prototype.init = function () {\n        this._bindEvents();\n    };\n    // 注册事件\n    EventController.prototype._bindEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.addEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            // 处理移动到外面没有触发 shape mouse leave 的事件\n            // 处理拖拽到外部的问题\n            document.addEventListener('mousemove', this._onDocumentMove);\n            // 处理拖拽过程中在外部释放鼠标的问题\n            document.addEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    // 清理事件\n    EventController.prototype._clearEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.removeEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            document.removeEventListener('mousemove', this._onDocumentMove);\n            document.removeEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n        var eventObj = new GraphEvent(type, event);\n        eventObj.fromShape = fromShape;\n        eventObj.toShape = toShape;\n        eventObj.x = point.x;\n        eventObj.y = point.y;\n        eventObj.clientX = point.clientX;\n        eventObj.clientY = point.clientY;\n        eventObj.propagationPath.push(target);\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n        return eventObj;\n    };\n    // 根据点获取图形，提取成独立方法，便于后续优化\n    EventController.prototype._getShape = function (point, ev) {\n        return this.canvas.getShape(point.x, point.y, ev);\n    };\n    // 获取事件的当前点的信息\n    EventController.prototype._getPointInfo = function (ev) {\n        var canvas = this.canvas;\n        var clientPoint = canvas.getClientByEvent(ev);\n        var point = canvas.getPointByEvent(ev);\n        return {\n            x: point.x,\n            y: point.y,\n            clientX: clientPoint.x,\n            clientY: clientPoint.y,\n        };\n    };\n    // 触发事件\n    EventController.prototype._triggerEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n        var shape = this._getShape(pointInfo, ev);\n        var method = this[\"_on\" + type];\n        var leaveCanvas = false;\n        if (method) {\n            method.call(this, pointInfo, shape, ev);\n        }\n        else {\n            var preShape = this.currentShape;\n            // 如果进入、移出画布时存在图形，则要分别触发事件\n            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n                if (shape) {\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n                }\n                if (type === 'mouseenter' && this.draggingShape) {\n                    // 如果正在拖拽图形, 则触发 dragleave\n                    this._emitEvent('dragenter', ev, pointInfo, null);\n                }\n            }\n            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n                leaveCanvas = true;\n                if (preShape) {\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n                }\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n                if (type === 'mouseleave' && this.draggingShape) {\n                    this._emitEvent('dragleave', ev, pointInfo, null);\n                }\n            }\n            else {\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n            }\n        }\n        if (!leaveCanvas) {\n            this.currentShape = shape;\n        }\n        // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n        if (shape && !shape.get('destroyed')) {\n            var canvas = this.canvas;\n            var el = canvas.get('el');\n            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n        }\n    };\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n    EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n        // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n        if (event.button === LEFT_BTN_CODE) {\n            this.mousedownShape = shape;\n            this.mousedownPoint = pointInfo;\n            this.mousedownTimeStamp = event.timeStamp;\n        }\n        this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n    };\n    // mouseleave 和 mouseenter 都是成对存在的\n    // mouseenter 和 mouseover 同时触发\n    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n        var el = this.canvas.get('el');\n        if (fromShape !== toShape) {\n            if (fromShape) {\n                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n                // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n                if (!toShape || toShape.get('destroyed')) {\n                    el.style.cursor = this.canvas.get('cursor');\n                }\n            }\n            if (toShape) {\n                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n        }\n    };\n    // dragover 不等同于 mouseover，而等同于 mousemove\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n        if (toShape) {\n            if (toShape !== fromShape) {\n                if (fromShape) {\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n                }\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n            if (!isCanvasEmit) {\n                this._emitEvent('dragover', event, pointInfo, toShape);\n            }\n        }\n        else if (fromShape) {\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n            // 经过空白区域\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        if (isCanvasEmit) {\n            this._emitEvent('dragover', event, pointInfo, toShape);\n        }\n    };\n    // drag 完成后，需要做一些清理工作\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n        if (draggingShape) {\n            draggingShape.set('capture', true); // 恢复可以拾取\n            this.draggingShape = null;\n        }\n        this.dragging = false;\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n        var shape = this._getShape(pointInfo, event);\n        // 拖拽完成后，进行 enter，leave 的判定\n        if (shape !== draggingShape) {\n            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n        }\n        this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n    };\n    // 按键抬起时，会终止拖拽、触发点击\n    EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n        // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n        if (event.button === LEFT_BTN_CODE) {\n            var draggingShape = this.draggingShape;\n            if (this.dragging) {\n                // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n                if (draggingShape) {\n                    this._emitEvent('drop', event, pointInfo, shape);\n                }\n                this._emitEvent('dragend', event, pointInfo, draggingShape);\n                this._afterDrag(draggingShape, pointInfo, event);\n            }\n            else {\n                this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n                if (shape === this.mousedownShape) {\n                    this._emitEvent('click', event, pointInfo, shape);\n                }\n                this.mousedownShape = null;\n                this.mousedownPoint = null;\n            }\n        }\n    };\n    // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\n        event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n        var preShape = this.currentShape;\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n    };\n    // 大量的图形事件，都通过 mousemove 模拟\n    EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n        var canvas = this.canvas;\n        var preShape = this.currentShape;\n        var draggingShape = this.draggingShape;\n        // 正在拖拽时\n        if (this.dragging) {\n            // 正在拖拽中\n            if (draggingShape) {\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n            }\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n            // 否则在 canvas 上触发 drag 事件\n            this._emitEvent('drag', event, pointInfo, draggingShape);\n        }\n        else {\n            var mousedownPoint = this.mousedownPoint;\n            if (mousedownPoint) {\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\n                var mousedownShape = this.mousedownShape;\n                var now = event.timeStamp;\n                var timeWindow = now - this.mousedownTimeStamp;\n                var dx = mousedownPoint.clientX - pointInfo.clientX;\n                var dy = mousedownPoint.clientY - pointInfo.clientY;\n                var dist = dx * dx + dy * dy;\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\n                    if (mousedownShape && mousedownShape.get('draggable')) {\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n                        draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n                        this.draggingShape = draggingShape;\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else if (!mousedownShape && canvas.get('draggable')) {\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, null);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else {\n                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                        this._emitEvent('mousemove', event, pointInfo, shape);\n                    }\n                }\n                else {\n                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                    this._emitEvent('mousemove', event, pointInfo, shape);\n                }\n            }\n            else {\n                // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n                this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                // 始终触发移动\n                this._emitEvent('mousemove', event, pointInfo, shape);\n            }\n        }\n    };\n    // 触发事件\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n        // 存在 shape 触发，则进行冒泡处理\n        if (shape) {\n            eventObj.shape = shape;\n            // 触发 shape 上的事件\n            emitTargetEvent(shape, type, eventObj);\n            var parent_1 = shape.getParent();\n            // 执行冒泡\n            while (parent_1) {\n                // 委托事件要先触发\n                parent_1.emitDelegation(type, eventObj);\n                // 事件冒泡停止，不能妨碍委托事件\n                if (!eventObj.propagationStopped) {\n                    bubbleEvent(parent_1, type, eventObj);\n                }\n                eventObj.propagationPath.push(parent_1);\n                parent_1 = parent_1.getParent();\n            }\n        }\n        else {\n            // 如果没有 shape 直接在 canvas 上触发\n            var canvas = this.canvas;\n            // 直接触发 canvas 上的事件\n            emitTargetEvent(canvas, type, eventObj);\n        }\n    };\n    EventController.prototype.destroy = function () {\n        // 清理事件\n        this._clearEvents();\n        // 清理缓存的对象\n        this.canvas = null;\n        this.currentShape = null;\n        this.draggingShape = null;\n        this.mousedownPoint = null;\n        this.mousedownShape = null;\n        this.mousedownTimeStamp = null;\n    };\n    return EventController;\n}());\nexport default EventController;\n//# sourceMappingURL=event-contoller.js.map"]}]}