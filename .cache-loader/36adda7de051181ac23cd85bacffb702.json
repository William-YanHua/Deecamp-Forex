{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\axis\\overlap\\auto-hide.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\axis\\overlap\\auto-hide.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { getMaxLabelWidth } from '../../util/label';\r\nfunction isRotate(label) {\r\n    var matrix = label.attr('matrix');\r\n    return matrix && matrix[0] !== 1;\r\n}\r\nfunction isOverlap(isVertical, rotated, preBox, curBox, reversed) {\r\n    if (reversed === void 0) {\r\n        reversed = false;\r\n    }\r\n    var overlap = false;\r\n    if (isVertical) {\r\n        overlap = Math.abs(preBox.y - curBox.y) < preBox.height;\r\n    }\r\n    else {\r\n        if (rotated) {\r\n            var height = reversed ? curBox.height : preBox.height;\r\n            overlap = Math.abs(preBox.x - curBox.x) < height;\r\n        }\r\n        else {\r\n            var width = reversed ? curBox.width : preBox.width;\r\n            overlap = Math.abs(preBox.x - curBox.x) < width;\r\n        }\r\n    }\r\n    return overlap;\r\n}\r\nfunction reserveOne(isVertical, labelsGroup, reversed) {\r\n    var labels = labelsGroup.getChildren().slice();\r\n    if (!labels.length) {\r\n        return false;\r\n    }\r\n    var hasHide = false;\r\n    if (reversed) {\r\n        labels.reverse();\r\n    }\r\n    var count = labels.length;\r\n    var first = labels[0];\r\n    var rotated = isRotate(first);\r\n    var preBox = first.getBBox();\r\n    for (var i = 1; i < count; i++) {\r\n        var label = labels[i];\r\n        var curBBox = label.getBBox();\r\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox, reversed);\r\n        if (isHide) {\r\n            label.hide();\r\n            hasHide = true;\r\n        }\r\n        else {\r\n            preBox = curBBox;\r\n        }\r\n    }\r\n    return hasHide;\r\n}\r\nexport function getDefault() {\r\n    return equidistance;\r\n}\r\nexport function reserveFirst(isVertical, labelsGroup) {\r\n    return reserveOne(isVertical, labelsGroup, false);\r\n}\r\nexport function reserveLast(isVertical, labelsGroup) {\r\n    return reserveOne(isVertical, labelsGroup, true);\r\n}\r\nexport function reserveBoth(isVertical, labelsGroup) {\r\n    var labels = labelsGroup.getChildren().slice();\r\n    if (labels.length <= 2) {\r\n        return false;\r\n    }\r\n    var hasHide = false;\r\n    var count = labels.length;\r\n    var first = labels[0];\r\n    var last = labels[count - 1];\r\n    var rotated = isRotate(first);\r\n    var preBox = first.getBBox();\r\n    var preLabel = first;\r\n    for (var i = 1; i < count - 1; i++) {\r\n        var label = labels[i];\r\n        var curBBox = label.getBBox();\r\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox);\r\n        if (isHide) {\r\n            label.hide();\r\n            hasHide = true;\r\n        }\r\n        else {\r\n            preBox = curBBox;\r\n            preLabel = label;\r\n        }\r\n    }\r\n    var lastBBox = last.getBBox();\r\n    var overlap = isOverlap(isVertical, rotated, preBox, lastBBox);\r\n    if (overlap) {\r\n        preLabel.hide();\r\n        hasHide = true;\r\n    }\r\n    return hasHide;\r\n}\r\nexport function equidistance(isVertical, labelsGroup) {\r\n    var labels = labelsGroup.getChildren().slice();\r\n    if (labels.length < 2) {\r\n        return false;\r\n    }\r\n    var hasHide = false;\r\n    var first = labels[0];\r\n    var firstBBox = first.getBBox();\r\n    var second = labels[1];\r\n    var rotated = isRotate(first);\r\n    var count = labels.length;\r\n    var interval = 0;\r\n    if (isVertical) {\r\n        var distance = Math.abs(second.attr('y') - first.attr('y'));\r\n        interval = firstBBox.height / distance;\r\n    }\r\n    else {\r\n        if (rotated) {\r\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\r\n            interval = firstBBox.width / distance;\r\n        }\r\n        else {\r\n            var maxWidth = getMaxLabelWidth(labels);\r\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\r\n            interval = maxWidth / distance;\r\n        }\r\n    }\r\n    if (interval > 1) {\r\n        interval = Math.ceil(interval);\r\n        for (var i = 0; i < count; i++) {\r\n            if (i % interval !== 0) {\r\n                labels[i].hide();\r\n                hasHide = true;\r\n            }\r\n        }\r\n    }\r\n    return hasHide;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\axis\\overlap\\auto-hide.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\axis\\overlap\\auto-hide.js"],"names":[],"mappings":"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","sourcesContent":["import { getMaxLabelWidth } from '../../util/label';\n// 文本是否旋转\nfunction isRotate(label) {\n    var matrix = label.attr('matrix');\n    return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n}\n// autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n// 是否重叠\nfunction isOverlap(isVertical, rotated, preBox, curBox, reversed) {\n    if (reversed === void 0) { reversed = false; }\n    var overlap = false;\n    if (isVertical) {\n        // 垂直时检测边高\n        overlap = Math.abs(preBox.y - curBox.y) < preBox.height;\n    }\n    else {\n        // 水平时检测\n        if (rotated) {\n            // 如果旋转了，则检测两者 x 之间的间距是否小于前一个的高度\n            var height = reversed ? curBox.height : preBox.height;\n            overlap = Math.abs(preBox.x - curBox.x) < height;\n        }\n        else {\n            // 检测两者是否 x 方向重合\n            var width = reversed ? curBox.width : preBox.width;\n            overlap = Math.abs(preBox.x - curBox.x) < width;\n        }\n    }\n    return overlap;\n}\n// 保留第一个或者最后一个\nfunction reserveOne(isVertical, labelsGroup, reversed) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (!labels.length) {\n        return false;\n    }\n    var hasHide = false;\n    if (reversed) {\n        // 翻转\n        labels.reverse();\n    }\n    var count = labels.length;\n    var first = labels[0];\n    var rotated = isRotate(first);\n    var preBox = first.getBBox();\n    for (var i = 1; i < count; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox, reversed);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            preBox = curBBox;\n        }\n    }\n    return hasHide;\n}\nexport function getDefault() {\n    return equidistance;\n}\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveFirst(isVertical, labelsGroup) {\n    return reserveOne(isVertical, labelsGroup, false);\n}\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveLast(isVertical, labelsGroup) {\n    return reserveOne(isVertical, labelsGroup, true);\n}\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function reserveBoth(isVertical, labelsGroup) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length <= 2) {\n        // 如果数量小于或等于 2 则直接返回\n        return false;\n    }\n    var hasHide = false;\n    var count = labels.length;\n    var first = labels[0];\n    var last = labels[count - 1];\n    var rotated = isRotate(first);\n    var preBox = first.getBBox();\n    var preLabel = first;\n    // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n    for (var i = 1; i < count - 1; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 废弃 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, rotated, preBox, curBBox);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            preBox = curBBox;\n            preLabel = label;\n        }\n    }\n    var lastBBox = last.getBBox();\n    var overlap = isOverlap(isVertical, rotated, preBox, lastBBox); // 不检测超出 limit\n    if (overlap) {\n        // 发生冲突，则隐藏前一个保留后一个\n        preLabel.hide();\n        hasHide = true;\n    }\n    return hasHide;\n}\n/**\n * 保证 label 均匀显示，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n */\nexport function equidistance(isVertical, labelsGroup) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length < 2) {\n        // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n        return false;\n    }\n    var hasHide = false;\n    var first = labels[0];\n    var firstBBox = first.getBBox();\n    var second = labels[1];\n    var rotated = isRotate(first);\n    var count = labels.length;\n    var interval = 0; // 不重叠的坐标文本间距个数\n    if (isVertical) {\n        // 垂直的坐标轴计算垂直方向的间距\n        var distance = Math.abs(second.attr('y') - first.attr('y'));\n        interval = firstBBox.height / distance;\n    }\n    else {\n        // 水平坐标轴\n        if (rotated) {\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\n            interval = firstBBox.width / distance;\n        }\n        else {\n            var maxWidth = getMaxLabelWidth(labels);\n            var distance = Math.abs(second.attr('x') - first.attr('x'));\n            interval = maxWidth / distance;\n        }\n    }\n    // interval > 1 时需要对 label 进行隐藏\n    if (interval > 1) {\n        interval = Math.ceil(interval);\n        for (var i = 0; i < count; i++) {\n            if (i % interval !== 0) {\n                // 仅保留被整除的 label\n                labels[i].hide();\n                hasHide = true;\n            }\n        }\n    }\n    return hasHide;\n}\n//# sourceMappingURL=auto-hide.js.map"]}]}