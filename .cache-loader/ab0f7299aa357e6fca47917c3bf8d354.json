{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\cartesian.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\cartesian.js","mtime":1466440270000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { asin, atan2, cos, sin, sqrt } from \"./math\";\r\nexport function spherical(cartesian) {\r\n    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\r\n}\r\nexport function cartesian(spherical) {\r\n    var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\r\n    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\r\n}\r\nexport function cartesianDot(a, b) {\r\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\nexport function cartesianCross(a, b) {\r\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\r\n}\r\nexport function cartesianAddInPlace(a, b) {\r\n    a[0] += b[0], a[1] += b[1], a[2] += b[2];\r\n}\r\nexport function cartesianScale(vector, k) {\r\n    return [vector[0] * k, vector[1] * k, vector[2] * k];\r\n}\r\nexport function cartesianNormalizeInPlace(d) {\r\n    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\r\n    d[0] /= l, d[1] /= l, d[2] /= l;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\cartesian.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\cartesian.js"],"names":[],"mappings":"AAAA,OAAO,EAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAC,MAAM,QAAQ,CAAC;AAEnD,MAAM,UAAU,SAAS,CAAC,SAAS;IACjC,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACjE,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,SAAS;IACjC,IAAI,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;IACjE,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAChE,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,CAAC,EAAE,CAAC;IAC/B,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,CAAC,EAAE,CAAC;IACjC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3F,CAAC;AAGD,MAAM,UAAU,mBAAmB,CAAC,CAAC,EAAE,CAAC;IACtC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,MAAM,EAAE,CAAC;IACtC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACvD,CAAC;AAGD,MAAM,UAAU,yBAAyB,CAAC,CAAC;IACzC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AAClC,CAAC","sourcesContent":["import {asin, atan2, cos, sin, sqrt} from \"./math\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n"]}]}