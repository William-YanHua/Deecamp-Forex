{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/regression.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/regression.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar assign = require('@antv/util/lib/mix');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar isNumber = require('@antv/util/lib/type/is-number');\nvar regression = require('regression');\nvar getSeriesValues = require('../util/get-series-values');\nvar registerTransform = require('../data-set').registerTransform;\nvar getFields = require('../util/option-parser').getFields;\nvar silverman = require('../util/bandwidth').silverman;\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    method: 'linear',\n    order: 2,\n    precision: 2\n};\nvar REGRESSION_METHODS = [\n    'linear',\n    'exponential',\n    'logarithmic',\n    'power',\n    'polynomial'\n];\nfunction transform(dataView, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var fields = getFields(options);\n    if (!isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings.');\n    }\n    var _a = __read(fields, 2), xField = _a[0], yField = _a[1];\n    var method = options.method;\n    if (REGRESSION_METHODS.indexOf(method) === -1) {\n        throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + REGRESSION_METHODS.join(', '));\n    }\n    var points = dataView.rows.map(function (row) { return [row[xField], row[yField]]; });\n    var regressionResult = regression[method](points, options);\n    var extent = options.extent;\n    if (!isArray(extent) || extent.length !== 2) {\n        extent = dataView.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = silverman(dataView.getColumn(xField));\n    }\n    var valuesToPredict = getSeriesValues(extent, bandwidth);\n    var result = [];\n    var _b = __read(options.as, 2), asX = _b[0], asY = _b[1];\n    valuesToPredict.forEach(function (value) {\n        var row = {};\n        var _a = __read(regressionResult.predict(value), 2), x = _a[0], y = _a[1];\n        row[asX] = x;\n        row[asY] = y;\n        if (isFinite(y)) {\n            result.push(row);\n        }\n    });\n    dataView.rows = result;\n}\nregisterTransform('regression', transform);\nmodule.exports = {\n    REGRESSION_METHODS: REGRESSION_METHODS\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/regression.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/regression.js"],"names":[],"mappings":"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","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst regression = require('regression');\nconst getSeriesValues = require('../util/get-series-values');\nconst {\n  registerTransform\n} = require('../data-set');\nconst {\n  getFields\n} = require('../util/option-parser');\nconst {\n  silverman\n} = require('../util/bandwidth');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y' ],\n  // fields: [ 'x', 'y' ], // required two fields\n  method: 'linear', // regression method: linear, exponential, logarithmic, power, polynomial\n  // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]\n  // bandwidth: 1, // bandWidth to execute regression function\n  order: 2, // order of the polynomial curve\n  precision: 2 // the number of significant figures the output is rounded to\n};\n\nconst REGRESSION_METHODS = [\n  'linear',\n  'exponential',\n  'logarithmic',\n  'power',\n  'polynomial'\n];\n\nfunction transform(dataView, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length !== 2) {\n    throw new TypeError('invalid fields: must be an array of 2 strings.');\n  }\n  const [ xField, yField ] = fields;\n  const method = options.method;\n  if (REGRESSION_METHODS.indexOf(method) === -1) {\n    throw new TypeError(`invalid method: ${method}. Must be one of ${REGRESSION_METHODS.join(', ')}`);\n  }\n  const points = dataView.rows.map(row => [ row[xField], row[yField] ]);\n  const regressionResult = regression[method](points, options);\n  let extent = options.extent;\n  if (!isArray(extent) || extent.length !== 2) {\n    extent = dataView.range(xField);\n  }\n  let bandwidth = options.bandwidth;\n  if (!isNumber(bandwidth) || bandwidth <= 0) {\n    bandwidth = silverman(dataView.getColumn(xField));\n  }\n  const valuesToPredict = getSeriesValues(extent, bandwidth);\n  const result = [];\n  const [ asX, asY ] = options.as;\n  valuesToPredict.forEach(value => {\n    const row = {};\n    const [ x, y ] = regressionResult.predict(value);\n    row[asX] = x;\n    row[asY] = y;\n    if (isFinite(y)) {\n      result.push(row);\n    }\n  });\n  dataView.rows = result;\n}\n\nregisterTransform('regression', transform);\n\nmodule.exports = {\n  REGRESSION_METHODS\n};\n"]}]}