{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js","mtime":1573552214000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import adder from \"./adder.js\";\nimport { areaStream, areaRingSum } from \"./area.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nimport { abs, degrees, epsilon, radians } from \"./math.js\";\nimport stream from \"./stream.js\";\nvar lambda0, phi0, lambda1, phi1, lambda2, lambda00, phi00, p0, deltaSum = adder(), ranges, range;\nvar boundsStream = {\n    point: boundsPoint,\n    lineStart: boundsLineStart,\n    lineEnd: boundsLineEnd,\n    polygonStart: function () {\n        boundsStream.point = boundsRingPoint;\n        boundsStream.lineStart = boundsRingStart;\n        boundsStream.lineEnd = boundsRingEnd;\n        deltaSum.reset();\n        areaStream.polygonStart();\n    },\n    polygonEnd: function () {\n        areaStream.polygonEnd();\n        boundsStream.point = boundsPoint;\n        boundsStream.lineStart = boundsLineStart;\n        boundsStream.lineEnd = boundsLineEnd;\n        if (areaRingSum < 0)\n            lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n        else if (deltaSum > epsilon)\n            phi1 = 90;\n        else if (deltaSum < -epsilon)\n            phi0 = -90;\n        range[0] = lambda0, range[1] = lambda1;\n    },\n    sphere: function () {\n        lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    }\n};\nfunction boundsPoint(lambda, phi) {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n    if (phi < phi0)\n        phi0 = phi;\n    if (phi > phi1)\n        phi1 = phi;\n}\nfunction linePoint(lambda, phi) {\n    var p = cartesian([lambda * radians, phi * radians]);\n    if (p0) {\n        var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n        cartesianNormalizeInPlace(inflection);\n        inflection = spherical(inflection);\n        var delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign, phii, antimeridian = abs(delta) > 180;\n        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n            phii = inflection[1] * degrees;\n            if (phii > phi1)\n                phi1 = phii;\n        }\n        else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n            phii = -inflection[1] * degrees;\n            if (phii < phi0)\n                phi0 = phii;\n        }\n        else {\n            if (phi < phi0)\n                phi0 = phi;\n            if (phi > phi1)\n                phi1 = phi;\n        }\n        if (antimeridian) {\n            if (lambda < lambda2) {\n                if (angle(lambda0, lambda) > angle(lambda0, lambda1))\n                    lambda1 = lambda;\n            }\n            else {\n                if (angle(lambda, lambda1) > angle(lambda0, lambda1))\n                    lambda0 = lambda;\n            }\n        }\n        else {\n            if (lambda1 >= lambda0) {\n                if (lambda < lambda0)\n                    lambda0 = lambda;\n                if (lambda > lambda1)\n                    lambda1 = lambda;\n            }\n            else {\n                if (lambda > lambda2) {\n                    if (angle(lambda0, lambda) > angle(lambda0, lambda1))\n                        lambda1 = lambda;\n                }\n                else {\n                    if (angle(lambda, lambda1) > angle(lambda0, lambda1))\n                        lambda0 = lambda;\n                }\n            }\n        }\n    }\n    else {\n        ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n    }\n    if (phi < phi0)\n        phi0 = phi;\n    if (phi > phi1)\n        phi1 = phi;\n    p0 = p, lambda2 = lambda;\n}\nfunction boundsLineStart() {\n    boundsStream.point = linePoint;\n}\nfunction boundsLineEnd() {\n    range[0] = lambda0, range[1] = lambda1;\n    boundsStream.point = boundsPoint;\n    p0 = null;\n}\nfunction boundsRingPoint(lambda, phi) {\n    if (p0) {\n        var delta = lambda - lambda2;\n        deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n    }\n    else {\n        lambda00 = lambda, phi00 = phi;\n    }\n    areaStream.point(lambda, phi);\n    linePoint(lambda, phi);\n}\nfunction boundsRingStart() {\n    areaStream.lineStart();\n}\nfunction boundsRingEnd() {\n    boundsRingPoint(lambda00, phi00);\n    areaStream.lineEnd();\n    if (abs(deltaSum) > epsilon)\n        lambda0 = -(lambda1 = 180);\n    range[0] = lambda0, range[1] = lambda1;\n    p0 = null;\n}\nfunction angle(lambda0, lambda1) {\n    return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\nfunction rangeCompare(a, b) {\n    return a[0] - b[0];\n}\nfunction rangeContains(range, x) {\n    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\nexport default function (feature) {\n    var i, n, a, b, merged, deltaMax, delta;\n    phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n    ranges = [];\n    stream(feature, boundsStream);\n    if (n = ranges.length) {\n        ranges.sort(rangeCompare);\n        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n            b = ranges[i];\n            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n                if (angle(a[0], b[1]) > angle(a[0], a[1]))\n                    a[1] = b[1];\n                if (angle(b[0], a[1]) > angle(a[0], a[1]))\n                    a[0] = b[0];\n            }\n            else {\n                merged.push(a = b);\n            }\n        }\n        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n            b = merged[i];\n            if ((delta = angle(a[1], b[0])) > deltaMax)\n                deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n        }\n    }\n    ranges = range = null;\n    return lambda0 === Infinity || phi0 === Infinity\n        ? [[NaN, NaN], [NaN, NaN]]\n        : [[lambda0, phi0], [lambda1, phi1]];\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js"],"names":[],"mappings":"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","sourcesContent":["import adder from \"./adder.js\";\nimport {areaStream, areaRingSum} from \"./area.js\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian.js\";\nimport {abs, degrees, epsilon, radians} from \"./math.js\";\nimport stream from \"./stream.js\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n"]}]}