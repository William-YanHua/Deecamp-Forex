{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/list.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/list.js","mtime":1516191690000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["'use strict';\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\nmodule.exports = list;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\nvar LIST_UNORDERED_MARKERS = {};\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\nvar LIST_ORDERED_MARKERS = {};\nLIST_ORDERED_MARKERS[C_DOT] = true;\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\nfunction list(eat, value, silent) {\n    var self = this;\n    var commonmark = self.options.commonmark;\n    var pedantic = self.options.pedantic;\n    var tokenizers = self.blockTokenizers;\n    var interuptors = self.interruptList;\n    var markers;\n    var index = 0;\n    var length = value.length;\n    var start = null;\n    var size = 0;\n    var queue;\n    var ordered;\n    var character;\n    var marker;\n    var nextIndex;\n    var startIndex;\n    var prefixed;\n    var currentMarker;\n    var content;\n    var line;\n    var prevEmpty;\n    var empty;\n    var items;\n    var allLines;\n    var emptyLines;\n    var item;\n    var enterTop;\n    var exitBlockquote;\n    var isLoose;\n    var node;\n    var now;\n    var end;\n    var indented;\n    while (index < length) {\n        character = value.charAt(index);\n        if (character === C_TAB) {\n            size += TAB_SIZE - (size % TAB_SIZE);\n        }\n        else if (character === C_SPACE) {\n            size++;\n        }\n        else {\n            break;\n        }\n        index++;\n    }\n    if (size >= TAB_SIZE) {\n        return;\n    }\n    character = value.charAt(index);\n    markers = commonmark ?\n        LIST_ORDERED_COMMONMARK_MARKERS :\n        LIST_ORDERED_MARKERS;\n    if (LIST_UNORDERED_MARKERS[character] === true) {\n        marker = character;\n        ordered = false;\n    }\n    else {\n        ordered = true;\n        queue = '';\n        while (index < length) {\n            character = value.charAt(index);\n            if (!decimal(character)) {\n                break;\n            }\n            queue += character;\n            index++;\n        }\n        character = value.charAt(index);\n        if (!queue || markers[character] !== true) {\n            return;\n        }\n        start = parseInt(queue, 10);\n        marker = character;\n    }\n    character = value.charAt(++index);\n    if (character !== C_SPACE && character !== C_TAB) {\n        return;\n    }\n    if (silent) {\n        return true;\n    }\n    index = 0;\n    items = [];\n    allLines = [];\n    emptyLines = [];\n    while (index < length) {\n        nextIndex = value.indexOf(C_NEWLINE, index);\n        startIndex = index;\n        prefixed = false;\n        indented = false;\n        if (nextIndex === -1) {\n            nextIndex = length;\n        }\n        end = index + TAB_SIZE;\n        size = 0;\n        while (index < length) {\n            character = value.charAt(index);\n            if (character === C_TAB) {\n                size += TAB_SIZE - (size % TAB_SIZE);\n            }\n            else if (character === C_SPACE) {\n                size++;\n            }\n            else {\n                break;\n            }\n            index++;\n        }\n        if (size >= TAB_SIZE) {\n            indented = true;\n        }\n        if (item && size >= item.indent) {\n            indented = true;\n        }\n        character = value.charAt(index);\n        currentMarker = null;\n        if (!indented) {\n            if (LIST_UNORDERED_MARKERS[character] === true) {\n                currentMarker = character;\n                index++;\n                size++;\n            }\n            else {\n                queue = '';\n                while (index < length) {\n                    character = value.charAt(index);\n                    if (!decimal(character)) {\n                        break;\n                    }\n                    queue += character;\n                    index++;\n                }\n                character = value.charAt(index);\n                index++;\n                if (queue && markers[character] === true) {\n                    currentMarker = character;\n                    size += queue.length + 1;\n                }\n            }\n            if (currentMarker) {\n                character = value.charAt(index);\n                if (character === C_TAB) {\n                    size += TAB_SIZE - (size % TAB_SIZE);\n                    index++;\n                }\n                else if (character === C_SPACE) {\n                    end = index + TAB_SIZE;\n                    while (index < end) {\n                        if (value.charAt(index) !== C_SPACE) {\n                            break;\n                        }\n                        index++;\n                        size++;\n                    }\n                    if (index === end && value.charAt(index) === C_SPACE) {\n                        index -= TAB_SIZE - 1;\n                        size -= TAB_SIZE - 1;\n                    }\n                }\n                else if (character !== C_NEWLINE && character !== '') {\n                    currentMarker = null;\n                }\n            }\n        }\n        if (currentMarker) {\n            if (!pedantic && marker !== currentMarker) {\n                break;\n            }\n            prefixed = true;\n        }\n        else {\n            if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n                indented = true;\n            }\n            else if (commonmark && item) {\n                indented = size >= item.indent || size > TAB_SIZE;\n            }\n            prefixed = false;\n            index = startIndex;\n        }\n        line = value.slice(startIndex, nextIndex);\n        content = startIndex === index ? line : value.slice(index, nextIndex);\n        if (currentMarker === C_ASTERISK ||\n            currentMarker === C_UNDERSCORE ||\n            currentMarker === C_DASH) {\n            if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n                break;\n            }\n        }\n        prevEmpty = empty;\n        empty = !trim(content).length;\n        if (indented && item) {\n            item.value = item.value.concat(emptyLines, line);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        }\n        else if (prefixed) {\n            if (emptyLines.length !== 0) {\n                item.value.push('');\n                item.trail = emptyLines.concat();\n            }\n            item = {\n                value: [line],\n                indent: size,\n                trail: []\n            };\n            items.push(item);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        }\n        else if (empty) {\n            if (prevEmpty) {\n                break;\n            }\n            emptyLines.push(line);\n        }\n        else {\n            if (prevEmpty) {\n                break;\n            }\n            if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n                break;\n            }\n            item.value = item.value.concat(emptyLines, line);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        }\n        index = nextIndex + 1;\n    }\n    node = eat(allLines.join(C_NEWLINE)).reset({\n        type: 'list',\n        ordered: ordered,\n        start: start,\n        loose: null,\n        children: []\n    });\n    enterTop = self.enterList();\n    exitBlockquote = self.enterBlock();\n    isLoose = false;\n    index = -1;\n    length = items.length;\n    while (++index < length) {\n        item = items[index].value.join(C_NEWLINE);\n        now = eat.now();\n        item = eat(item)(listItem(self, item, now), node);\n        if (item.loose) {\n            isLoose = true;\n        }\n        item = items[index].trail.join(C_NEWLINE);\n        if (index !== length - 1) {\n            item += C_NEWLINE;\n        }\n        eat(item);\n    }\n    enterTop();\n    exitBlockquote();\n    node.loose = isLoose;\n    return node;\n}\nfunction listItem(ctx, value, position) {\n    var offsets = ctx.offset;\n    var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n    var checked = null;\n    var task;\n    var indent;\n    value = fn.apply(null, arguments);\n    if (ctx.options.gfm) {\n        task = value.match(EXPRESSION_TASK_ITEM);\n        if (task) {\n            indent = task[0].length;\n            checked = task[1].toLowerCase() === C_X_LOWER;\n            offsets[position.line] += indent;\n            value = value.slice(indent);\n        }\n    }\n    return {\n        type: 'listItem',\n        loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n            value.charAt(value.length - 1) === C_NEWLINE,\n        checked: checked,\n        children: ctx.tokenizeBlock(value, position)\n    };\n}\nfunction pedanticListItem(ctx, value, position) {\n    var offsets = ctx.offset;\n    var line = position.line;\n    value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n    line = position.line;\n    return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n    function replacer($0) {\n        offsets[line] = (offsets[line] || 0) + $0.length;\n        line++;\n        return '';\n    }\n}\nfunction normalListItem(ctx, value, position) {\n    var offsets = ctx.offset;\n    var line = position.line;\n    var max;\n    var bullet;\n    var rest;\n    var lines;\n    var trimmedLines;\n    var index;\n    var length;\n    value = value.replace(EXPRESSION_BULLET, replacer);\n    lines = value.split(C_NEWLINE);\n    trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n    trimmedLines[0] = rest;\n    offsets[line] = (offsets[line] || 0) + bullet.length;\n    line++;\n    index = 0;\n    length = lines.length;\n    while (++index < length) {\n        offsets[line] = (offsets[line] || 0) +\n            lines[index].length - trimmedLines[index].length;\n        line++;\n    }\n    return trimmedLines.join(C_NEWLINE);\n    function replacer($0, $1, $2, $3, $4) {\n        bullet = $1 + $2 + $3;\n        rest = $4;\n        if (Number($2) < 10 && bullet.length % 2 === 1) {\n            $2 = C_SPACE + $2;\n        }\n        max = $1 + repeat(C_SPACE, $2.length) + $3;\n        return max + rest;\n    }\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/list.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/list.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable max-params */\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\n\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - (size % TAB_SIZE);\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n\n  markers = commonmark ?\n    LIST_ORDERED_COMMONMARK_MARKERS :\n    LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - (size % TAB_SIZE);\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - (size % TAB_SIZE);\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (\n      currentMarker === C_ASTERISK ||\n      currentMarker === C_UNDERSCORE ||\n      currentMarker === C_DASH\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n\n  node.loose = isLoose;\n\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n      value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n\n  lines = value.split(C_NEWLINE);\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) +\n      lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n    return max + rest;\n  }\n}\n"]}]}