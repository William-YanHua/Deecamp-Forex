{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/impute.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/impute.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var assign = require('@antv/util/lib/mix');\nvar forIn = require('@antv/util/lib/each');\nvar has = require('@antv/util/lib/object/has');\nvar isFunction = require('@antv/util/lib/type/is-function');\nvar isUndefined = require('@antv/util/lib/type/is-undefined');\nvar isString = require('@antv/util/lib/type/is-string');\nvar simpleStatistics = require('simple-statistics');\nvar partition = require('../util/partition');\nvar registerTransform = require('../data-set').registerTransform;\nvar getField = require('../util/option-parser').getField;\nvar DEFAULT_OPTIONS = {\n    groupBy: []\n};\nfunction notUndefinedValues(values) {\n    return values.filter(function (value) { return !isUndefined(value); });\n}\nvar STATISTICS_METHODS = [\n    'mean',\n    'median',\n    'max',\n    'min'\n];\nvar imputations = {};\nSTATISTICS_METHODS.forEach(function (method) {\n    imputations[method] = function (row, values) { return simpleStatistics[method](values); };\n});\nimputations.value = function (row, values, value) { return value; };\nfunction transform(dataView, options) {\n    if (options === void 0) { options = {}; }\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var field = getField(options);\n    var method = options.method;\n    if (!method) {\n        throw new TypeError('Invalid method!');\n    }\n    if ((method === 'value' && !has(options, 'value'))) {\n        throw new TypeError('Invalid value: it is nil.');\n    }\n    var column = notUndefinedValues(dataView.getColumn(field));\n    var groups = partition(dataView.rows, options.groupBy);\n    forIn(groups, function (group) {\n        var fieldValues = notUndefinedValues(group.map(function (row) { return row[field]; }));\n        if (fieldValues.length === 0) {\n            fieldValues = column;\n        }\n        group.forEach(function (row) {\n            if (isUndefined(row[field])) {\n                if (isFunction(method)) {\n                    row[field] = method(row, fieldValues, options.value, group);\n                }\n                else if (isString(method)) {\n                    row[field] = imputations[method](row, fieldValues, options.value);\n                }\n                else {\n                    throw new TypeError(\"Invalid method: must be a function or one of \" + STATISTICS_METHODS.join(', '));\n                }\n            }\n        });\n    });\n}\nregisterTransform('impute', transform);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/impute.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/impute.js"],"names":[],"mappings":"AAAA,IAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAC7C,IAAM,KAAK,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAC7C,IAAM,GAAG,GAAG,OAAO,CAAC,2BAA2B,CAAC,CAAC;AACjD,IAAM,UAAU,GAAG,OAAO,CAAC,iCAAiC,CAAC,CAAC;AAC9D,IAAM,WAAW,GAAG,OAAO,CAAC,kCAAkC,CAAC,CAAC;AAChE,IAAM,QAAQ,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC1D,IAAM,gBAAgB,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AACtD,IAAM,SAAS,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAE7C,IAAA,iBAAiB,GACf,OAAO,CAAC,aAAa,CAAC,kBADP,CACQ;AAEzB,IAAA,QAAQ,GACN,OAAO,CAAC,uBAAuB,CAAC,SAD1B,CAC2B;AAErC,IAAM,eAAe,GAAG;IAItB,OAAO,EAAE,EAAE;CACZ,CAAC;AAEF,SAAS,kBAAkB,CAAC,MAAM;IAChC,OAAO,MAAM,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,WAAW,CAAC,KAAK,CAAC,EAAnB,CAAmB,CAAC,CAAC;AACrD,CAAC;AAED,IAAM,kBAAkB,GAAG;IACzB,MAAM;IACN,QAAQ;IACR,KAAK;IACL,KAAK;CACN,CAAC;AACF,IAAM,WAAW,GAAG,EAAE,CAAC;AACvB,kBAAkB,CAAC,OAAO,CAAC,UAAA,MAAM;IAC/B,WAAW,CAAC,MAAM,CAAC,GAAG,UAAC,GAAG,EAAE,MAAM,IAAK,OAAA,gBAAgB,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,EAAhC,CAAgC,CAAC;AAC1E,CAAC,CAAC,CAAC;AACH,WAAW,CAAC,KAAK,GAAG,UAAC,GAAG,EAAE,MAAM,EAAE,KAAK,IAAK,OAAA,KAAK,EAAL,CAAK,CAAC;AAElD,SAAS,SAAS,CAAC,QAAQ,EAAE,OAAY;IAAZ,wBAAA,EAAA,YAAY;IACvC,OAAO,GAAG,MAAM,CAAC,EAAE,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;IAC/C,IAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;IAChC,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC9B,IAAI,CAAC,MAAM,EAAE;QACX,MAAM,IAAI,SAAS,CAAC,iBAAiB,CAAC,CAAC;KACxC;IACD,IAAI,CAAC,MAAM,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE;QAClD,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;KAClD;IACD,IAAM,MAAM,GAAG,kBAAkB,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7D,IAAM,MAAM,GAAG,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;IACzD,KAAK,CAAC,MAAM,EAAE,UAAA,KAAK;QACjB,IAAI,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,KAAK,CAAC,EAAV,CAAU,CAAC,CAAC,CAAC;QACnE,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,WAAW,GAAG,MAAM,CAAC;SACtB;QACD,KAAK,CAAC,OAAO,CAAC,UAAA,GAAG;YACf,IAAI,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC3B,IAAI,UAAU,CAAC,MAAM,CAAC,EAAE;oBACtB,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,GAAG,EAAE,WAAW,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;iBAC7D;qBAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;oBAC3B,GAAG,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,WAAW,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;iBACnE;qBAAM;oBACL,MAAM,IAAI,SAAS,CAAC,kDAAgD,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAG,CAAC,CAAC;iBACtG;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,iBAAiB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst has = require('@antv/util/lib/object/has');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isUndefined = require('@antv/util/lib/type/is-undefined');\nconst isString = require('@antv/util/lib/type/is-string');\nconst simpleStatistics = require('simple-statistics');\nconst partition = require('../util/partition');\nconst {\n  registerTransform\n} = require('../data-set');\nconst {\n  getField\n} = require('../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  // field: '', // required\n  // method: 'value', // required\n  // value: 10, // required if (method === 'value')\n  groupBy: []\n};\n\nfunction notUndefinedValues(values) {\n  return values.filter(value => !isUndefined(value));\n}\n\nconst STATISTICS_METHODS = [\n  'mean',\n  'median',\n  'max',\n  'min'\n];\nconst imputations = {};\nSTATISTICS_METHODS.forEach(method => {\n  imputations[method] = (row, values) => simpleStatistics[method](values);\n});\nimputations.value = (row, values, value) => value;\n\nfunction transform(dataView, options = {}) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const field = getField(options);\n  const method = options.method;\n  if (!method) {\n    throw new TypeError('Invalid method!');\n  }\n  if ((method === 'value' && !has(options, 'value'))) {\n    throw new TypeError('Invalid value: it is nil.');\n  }\n  const column = notUndefinedValues(dataView.getColumn(field));\n  const groups = partition(dataView.rows, options.groupBy);\n  forIn(groups, group => {\n    let fieldValues = notUndefinedValues(group.map(row => row[field]));\n    if (fieldValues.length === 0) {\n      fieldValues = column;\n    }\n    group.forEach(row => {\n      if (isUndefined(row[field])) {\n        if (isFunction(method)) {\n          row[field] = method(row, fieldValues, options.value, group);\n        } else if (isString(method)) {\n          row[field] = imputations[method](row, fieldValues, options.value);\n        } else {\n          throw new TypeError(`Invalid method: must be a function or one of ${STATISTICS_METHODS.join(', ')}`);\n        }\n      }\n    });\n  });\n}\n\nregisterTransform('impute', transform);\n"]}]}