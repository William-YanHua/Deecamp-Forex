{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\topojson-client\\src\\quantize.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\topojson-client\\src\\quantize.js","mtime":1490936621000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import bbox from \"./bbox\";\r\nimport untransform from \"./untransform\";\r\nexport default function (topology, transform) {\r\n    if (topology.transform)\r\n        throw new Error(\"already quantized\");\r\n    if (!transform || !transform.scale) {\r\n        if (!((n = Math.floor(transform)) >= 2))\r\n            throw new Error(\"n must be ≥2\");\r\n        box = topology.bbox || bbox(topology);\r\n        var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\r\n        transform = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };\r\n    }\r\n    else {\r\n        box = topology.bbox;\r\n    }\r\n    var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\r\n    function quantizePoint(point) {\r\n        return t(point);\r\n    }\r\n    function quantizeGeometry(input) {\r\n        var output;\r\n        switch (input.type) {\r\n            case \"GeometryCollection\":\r\n                output = { type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry) };\r\n                break;\r\n            case \"Point\":\r\n                output = { type: \"Point\", coordinates: quantizePoint(input.coordinates) };\r\n                break;\r\n            case \"MultiPoint\":\r\n                output = { type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint) };\r\n                break;\r\n            default: return input;\r\n        }\r\n        if (input.id != null)\r\n            output.id = input.id;\r\n        if (input.bbox != null)\r\n            output.bbox = input.bbox;\r\n        if (input.properties != null)\r\n            output.properties = input.properties;\r\n        return output;\r\n    }\r\n    function quantizeArc(input) {\r\n        var i = 0, j = 1, n = input.length, p, output = new Array(n);\r\n        output[0] = t(input[0], 0);\r\n        while (++i < n)\r\n            if ((p = t(input[i], i))[0] || p[1])\r\n                output[j++] = p;\r\n        if (j === 1)\r\n            output[j++] = [0, 0];\r\n        output.length = j;\r\n        return output;\r\n    }\r\n    for (key in inputs)\r\n        outputs[key] = quantizeGeometry(inputs[key]);\r\n    return {\r\n        type: \"Topology\",\r\n        bbox: box,\r\n        transform: transform,\r\n        objects: outputs,\r\n        arcs: topology.arcs.map(quantizeArc)\r\n    };\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\topojson-client\\src\\quantize.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\topojson-client\\src\\quantize.js"],"names":[],"mappings":"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","sourcesContent":["import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n"]}]}