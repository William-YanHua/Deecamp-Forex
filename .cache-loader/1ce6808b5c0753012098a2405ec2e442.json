{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/bin/hexagon.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/bin/hexagon.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar assign = require('@antv/util/lib/mix');\nvar forIn = require('@antv/util/lib/each');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar registerTransform = require('../../data-set').registerTransform;\nvar getFields = require('../../util/option-parser').getFields;\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'count'],\n    bins: [30, 30],\n    offset: [0, 0],\n    sizeByCount: false\n};\nvar SQRT3 = Math.sqrt(3);\nvar THIRD_PI = Math.PI / 3;\nvar ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];\nfunction distance(x0, y0, x1, y1) {\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\n}\nfunction nearestBinsCenters(value, scale, offset) {\n    var temp = value - offset;\n    scale = scale / 2;\n    var div = Math.floor(temp / scale);\n    var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\n    var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\n    return [rounded + offset, roundedScaled + offset];\n}\nfunction generateBins(points, binWidth, offset) {\n    if (binWidth === void 0) { binWidth = [1, 1]; }\n    if (offset === void 0) { offset = [0, 0]; }\n    var bins = {};\n    var _a = __read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];\n    var _b = __read(offset, 2), offsetX = _b[0], offsetY = _b[1];\n    points.forEach(function (point) {\n        var _a, _b;\n        var _c = __read(point, 2), x = _c[0], y = _c[1];\n        var _d = __read(nearestBinsCenters(x, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];\n        var _e = __read(nearestBinsCenters(y, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];\n        var d1 = distance(x, y, xRounded, yRounded);\n        var d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\n        var binKey;\n        var binX;\n        var binY;\n        if (d1 < d2) {\n            binKey = \"x\" + xRounded + \"y\" + yRounded;\n            _a = __read([xRounded, yRounded], 2), binX = _a[0], binY = _a[1];\n        }\n        else {\n            binKey = \"x\" + xRoundedScaled + \"y\" + yRoundedScaled;\n            _b = __read([xRoundedScaled, yRoundedScaled], 2), binX = _b[0], binY = _b[1];\n        }\n        bins[binKey] = bins[binKey] || {\n            x: binX,\n            y: binY,\n            count: 0\n        };\n        bins[binKey].count++;\n    });\n    return bins;\n}\nfunction transform(dataView, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var fields = getFields(options);\n    if (!isArray(fields) || fields.length !== 2) {\n        throw new TypeError('Invalid fields: it must be an array with 2 strings!');\n    }\n    var _a = __read(fields, 2), fieldX = _a[0], fieldY = _a[1];\n    var rangeFieldX = dataView.range(fieldX);\n    var rangeFieldY = dataView.range(fieldY);\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\n    var binWidth = options.binWidth || [];\n    if (binWidth.length !== 2) {\n        var _b = __read(options.bins, 2), binsX = _b[0], binsY = _b[1];\n        if (binsX <= 0 || binsY <= 0) {\n            throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\n        }\n        binWidth = [widthX / binsX, widthY / binsY];\n    }\n    var _c = __read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\n    var yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);\n    var points = dataView.rows.map(function (row) { return [row[fieldX], yScale * row[fieldY]]; });\n    var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);\n    var _d = __read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\n    if (!asX || !asY || !asCount) {\n        throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\n    }\n    var radius = binWidth[0] / SQRT3;\n    var hexagonPoints = ANGLES.map(function (angle) { return [Math.sin(angle) * radius, -Math.cos(angle) * radius]; });\n    var result = [];\n    var maxCount = 0;\n    if (options.sizeByCount) {\n        forIn(bins, function (bin) {\n            if (bin.count > maxCount) {\n                maxCount = bin.count;\n            }\n        });\n    }\n    forIn(bins, function (bin) {\n        var x = bin.x, y = bin.y, count = bin.count;\n        var row = {};\n        row[asCount] = count;\n        if (options.sizeByCount) {\n            row[asX] = hexagonPoints.map(function (p) { return x + (bin.count / maxCount) * p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + (bin.count / maxCount) * p[1]) / yScale; });\n        }\n        else {\n            row[asX] = hexagonPoints.map(function (p) { return x + p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + p[1]) / yScale; });\n        }\n        result.push(row);\n    });\n    dataView.rows = result;\n}\nregisterTransform('bin.hexagon', transform);\nregisterTransform('bin.hex', transform);\nregisterTransform('hexbin', transform);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/bin/hexagon.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/bin/hexagon.js"],"names":[],"mappings":"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","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y', 'count' ],\n  bins: [ 30, 30 ], // Numeric vector giving number of bins in both horizontal and vertical directions\n  offset: [ 0, 0 ],\n  sizeByCount: false // calculate bin size by binning count\n  // fields: ['field0', 'field1'], // required\n  // binWidth: [ 30, 30 ], // Numeric vector giving bin width in both horizontal and vertical directions. Overrides bins if both set.\n};\nconst SQRT3 = Math.sqrt(3);\nconst THIRD_PI = Math.PI / 3;\nconst ANGLES = [ 0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI ];\n\nfunction distance(x0, y0, x1, y1) {\n  return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\n}\nfunction nearestBinsCenters(value, scale, offset) {\n  const temp = value - offset;\n  scale = scale / 2;\n  const div = Math.floor(temp / scale);\n  const rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\n  const roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\n  return [ rounded + offset, roundedScaled + offset ];\n}\nfunction generateBins(points, binWidth = [ 1, 1 ], offset = [ 0, 0 ]) { // processing aligned data\n  const bins = {};\n  const [ binWidthX, binWidthY ] = binWidth;\n  const [ offsetX, offsetY ] = offset;\n  points.forEach(point => {\n    const [ x, y ] = point;\n    // step3.1: nearest two centers\n    const [ xRounded, xRoundedScaled ] = nearestBinsCenters(x, binWidthX, offsetX);\n    const [ yRounded, yRoundedScaled ] = nearestBinsCenters(y, binWidthY, offsetY);\n    // step3.2: compare distances\n    const d1 = distance(x, y, xRounded, yRounded);\n    const d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\n    let binKey;\n    let binX;\n    let binY;\n\n    if (d1 < d2) {\n      binKey = `x${xRounded}y${yRounded}`;\n      [ binX, binY ] = [ xRounded, yRounded ];\n    } else {\n      binKey = `x${xRoundedScaled}y${yRoundedScaled}`;\n      [ binX, binY ] = [ xRoundedScaled, yRoundedScaled ];\n    }\n    bins[binKey] = bins[binKey] || {\n      x: binX,\n      y: binY,\n      count: 0\n    };\n    bins[binKey].count ++;\n  });\n  return bins;\n}\n\nfunction transform(dataView, options) {\n  // step1: get binWidth, etc.\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length !== 2) {\n    throw new TypeError('Invalid fields: it must be an array with 2 strings!');\n  }\n  const [ fieldX, fieldY ] = fields;\n  const rangeFieldX = dataView.range(fieldX);\n  const rangeFieldY = dataView.range(fieldY);\n  const widthX = rangeFieldX[1] - rangeFieldX[0];\n  const widthY = rangeFieldY[1] - rangeFieldY[0];\n  let binWidth = options.binWidth || [];\n  if (binWidth.length !== 2) {\n    const [ binsX, binsY ] = options.bins;\n    if (binsX <= 0 || binsY <= 0) {\n      throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\n    }\n    binWidth = [ widthX / binsX, widthY / binsY ];\n  }\n  // step2: align scale (squash Y)\n  /*\n   * binWidthX / binWidthY should be Math.sqrt3 / 1.5\n   * -: binWidthX |: binWidthY\n   *           3\n   *           |\n   *   4       |        2\n   *           |\n   *           |\n   *   5----------------1\n   *\n   *           0\n   */\n  const [ offsetX, offsetY ] = options.offset;\n  const yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);\n  // const yScale = binWidth[0] / (SQRT3 * binWidth[1]);\n  const points = dataView.rows.map(row => [ row[fieldX], yScale * row[fieldY] ]);\n  // step3: binning\n  const bins = generateBins(points, [ binWidth[0], yScale * binWidth[1] ], [ offsetX, yScale * offsetY ]);\n  // step4: restore scale (for Y)\n  const [ asX, asY, asCount ] = options.as;\n  if (!asX || !asY || !asCount) {\n    throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\n  }\n  const radius = binWidth[0] / SQRT3;\n  const hexagonPoints = ANGLES.map(angle => [ Math.sin(angle) * radius, -Math.cos(angle) * radius ]);\n  const result = [];\n  let maxCount = 0;\n  if (options.sizeByCount) {\n    forIn(bins, bin => {\n      if (bin.count > maxCount) {\n        maxCount = bin.count;\n      }\n    });\n  }\n  forIn(bins, bin => {\n    const { x, y, count } = bin;\n    const row = {};\n    row[asCount] = count;\n    if (options.sizeByCount) {\n      row[asX] = hexagonPoints.map(p => x + (bin.count / maxCount) * p[0]);\n      row[asY] = hexagonPoints.map(p => (y + (bin.count / maxCount) * p[1]) / yScale);\n    } else {\n      row[asX] = hexagonPoints.map(p => x + p[0]);\n      row[asY] = hexagonPoints.map(p => (y + p[1]) / yScale);\n    }\n    result.push(row);\n  });\n\n  dataView.rows = result;\n}\n\nregisterTransform('bin.hexagon', transform);\nregisterTransform('bin.hex', transform);\nregisterTransform('hexbin', transform);\n"]}]}