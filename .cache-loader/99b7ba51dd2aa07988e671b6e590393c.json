{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/trough/wrap.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/trough/wrap.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["'use strict';\nvar slice = [].slice;\nmodule.exports = wrap;\nfunction wrap(fn, callback) {\n    var invoked;\n    return wrapped;\n    function wrapped() {\n        var params = slice.call(arguments, 0);\n        var callback = fn.length > params.length;\n        var result;\n        if (callback) {\n            params.push(done);\n        }\n        try {\n            result = fn.apply(null, params);\n        }\n        catch (error) {\n            if (callback && invoked) {\n                throw error;\n            }\n            return done(error);\n        }\n        if (!callback) {\n            if (result && typeof result.then === 'function') {\n                result.then(then, done);\n            }\n            else if (result instanceof Error) {\n                done(result);\n            }\n            else {\n                then(result);\n            }\n        }\n    }\n    function done() {\n        if (!invoked) {\n            invoked = true;\n            callback.apply(null, arguments);\n        }\n    }\n    function then(value) {\n        done(null, value);\n    }\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/trough/wrap.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/trough/wrap.js"],"names":[],"mappings":"AAAA,YAAY,CAAA;AAEZ,IAAI,KAAK,GAAG,EAAE,CAAC,KAAK,CAAA;AAEpB,MAAM,CAAC,OAAO,GAAG,IAAI,CAAA;AAKrB,SAAS,IAAI,CAAC,EAAE,EAAE,QAAQ;IACxB,IAAI,OAAO,CAAA;IAEX,OAAO,OAAO,CAAA;IAEd,SAAS,OAAO;QACd,IAAI,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;QACrC,IAAI,QAAQ,GAAG,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAA;QACxC,IAAI,MAAM,CAAA;QAEV,IAAI,QAAQ,EAAE;YACZ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SAClB;QAED,IAAI;YACF,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;SAChC;QAAC,OAAO,KAAK,EAAE;YAMd,IAAI,QAAQ,IAAI,OAAO,EAAE;gBACvB,MAAM,KAAK,CAAA;aACZ;YAED,OAAO,IAAI,CAAC,KAAK,CAAC,CAAA;SACnB;QAED,IAAI,CAAC,QAAQ,EAAE;YACb,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;aACxB;iBAAM,IAAI,MAAM,YAAY,KAAK,EAAE;gBAClC,IAAI,CAAC,MAAM,CAAC,CAAA;aACb;iBAAM;gBACL,IAAI,CAAC,MAAM,CAAC,CAAA;aACb;SACF;IACH,CAAC;IAGD,SAAS,IAAI;QACX,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,IAAI,CAAA;YAEd,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;SAChC;IACH,CAAC;IAID,SAAS,IAAI,CAAC,KAAK;QACjB,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;IACnB,CAAC;AACH,CAAC","sourcesContent":["'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n// Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // We’re not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error\n      }\n\n      return done(error)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  // Invoke `next`, only once.\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n  function then(value) {\n    done(null, value)\n  }\n}\n"]}]}