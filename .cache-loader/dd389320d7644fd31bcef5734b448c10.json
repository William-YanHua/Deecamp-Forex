{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/circle.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/circle.js","mtime":1489500401000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical } from \"../cartesian\";\nimport { circleStream } from \"../circle\";\nimport { abs, cos, epsilon, pi, sqrt } from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\nexport default function (radius, delta) {\n    var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;\n    function interpolate(from, to, direction, stream) {\n        circleStream(stream, radius, delta, direction, from, to);\n    }\n    function visible(lambda, phi) {\n        return cos(lambda) * cos(phi) > cr;\n    }\n    function clipLine(stream) {\n        var point0, c0, v0, v00, clean;\n        return {\n            lineStart: function () {\n                v00 = v0 = false;\n                clean = 1;\n            },\n            point: function (lambda, phi) {\n                var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius\n                    ? v ? 0 : code(lambda, phi)\n                    : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n                if (!point0 && (v00 = v0 = v))\n                    stream.lineStart();\n                if (v !== v0) {\n                    point2 = intersect(point0, point1);\n                    if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n                        point1[0] += epsilon;\n                        point1[1] += epsilon;\n                        v = visible(point1[0], point1[1]);\n                    }\n                }\n                if (v !== v0) {\n                    clean = 0;\n                    if (v) {\n                        stream.lineStart();\n                        point2 = intersect(point1, point0);\n                        stream.point(point2[0], point2[1]);\n                    }\n                    else {\n                        point2 = intersect(point0, point1);\n                        stream.point(point2[0], point2[1]);\n                        stream.lineEnd();\n                    }\n                    point0 = point2;\n                }\n                else if (notHemisphere && point0 && smallRadius ^ v) {\n                    var t;\n                    if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                        clean = 0;\n                        if (smallRadius) {\n                            stream.lineStart();\n                            stream.point(t[0][0], t[0][1]);\n                            stream.point(t[1][0], t[1][1]);\n                            stream.lineEnd();\n                        }\n                        else {\n                            stream.point(t[1][0], t[1][1]);\n                            stream.lineEnd();\n                            stream.lineStart();\n                            stream.point(t[0][0], t[0][1]);\n                        }\n                    }\n                }\n                if (v && (!point0 || !pointEqual(point0, point1))) {\n                    stream.point(point1[0], point1[1]);\n                }\n                point0 = point1, v0 = v, c0 = c;\n            },\n            lineEnd: function () {\n                if (v0)\n                    stream.lineEnd();\n                point0 = null;\n            },\n            clean: function () {\n                return clean | ((v00 && v0) << 1);\n            }\n        };\n    }\n    function intersect(a, b, two) {\n        var pa = cartesian(a), pb = cartesian(b);\n        var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n        if (!determinant)\n            return !two && a;\n        var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);\n        cartesianAddInPlace(A, B);\n        var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);\n        if (t2 < 0)\n            return;\n        var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);\n        cartesianAddInPlace(q, A);\n        q = spherical(q);\n        if (!two)\n            return q;\n        var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;\n        if (lambda1 < lambda0)\n            z = lambda0, lambda0 = lambda1, lambda1 = z;\n        var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;\n        if (!polar && phi1 < phi0)\n            z = phi0, phi0 = phi1, phi1 = z;\n        if (meridian\n            ? polar\n                ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n                : phi0 <= q[1] && q[1] <= phi1\n            : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n            var q1 = cartesianScale(u, (-w + t) / uu);\n            cartesianAddInPlace(q1, A);\n            return [q, spherical(q1)];\n        }\n    }\n    function code(lambda, phi) {\n        var r = smallRadius ? radius : pi - radius, code = 0;\n        if (lambda < -r)\n            code |= 1;\n        else if (lambda > r)\n            code |= 2;\n        if (phi < -r)\n            code |= 4;\n        else if (phi > r)\n            code |= 8;\n        return code;\n    }\n    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/circle.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/circle.js"],"names":[],"mappings":"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","sourcesContent":["import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\nimport {circleStream} from \"../circle\";\nimport {abs, cos, epsilon, pi, sqrt} from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\n\nexport default function(radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n"]}]}