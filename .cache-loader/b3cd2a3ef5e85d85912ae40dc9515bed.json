{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g2/lib/geom/util/path.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g2/lib/geom/util/path.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var Util = require('../../util');\nvar Spline = require('./spline');\nfunction points2path(points, isInCircle) {\n    if (!points.length) {\n        return [];\n    }\n    var path = [];\n    for (var i = 0, length = points.length; i < length; i++) {\n        var item = points[i];\n        if (i === 0) {\n            path.push(['M', item.x, item.y]);\n        }\n        else {\n            path.push(['L', item.x, item.y]);\n        }\n    }\n    if (isInCircle) {\n        path.push(['Z']);\n    }\n    return path;\n}\nfunction _getPointRadius(coord, point) {\n    var center = coord.getCenter();\n    var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n    return r;\n}\nfunction convertArr(arr, coord) {\n    var len = arr.length;\n    var tmp = [arr[0]];\n    for (var i = 1; i < len; i = i + 2) {\n        var point = coord.convertPoint({\n            x: arr[i],\n            y: arr[i + 1]\n        });\n        tmp.push(point.x, point.y);\n    }\n    return tmp;\n}\nfunction _convertPolarPath(pre, cur, coord) {\n    var transposed = coord.isTransposed;\n    var startAngle = coord.startAngle;\n    var endAngle = coord.endAngle;\n    var prePoint = {\n        x: pre[1],\n        y: pre[2]\n    };\n    var curPoint = {\n        x: cur[1],\n        y: cur[2]\n    };\n    var rst = [];\n    var xDim = transposed ? 'y' : 'x';\n    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n    var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;\n    var flag = angleRange > Math.PI ? 1 : 0;\n    var convertPoint = coord.convertPoint(curPoint);\n    var r = _getPointRadius(coord, convertPoint);\n    if (r >= 0.5) {\n        if (angleRange === Math.PI * 2) {\n            var middlePoint = {\n                x: (curPoint.x + prePoint.x) / 2,\n                y: (curPoint.y + prePoint.y) / 2\n            };\n            var middleConvertPoint = coord.convertPoint(middlePoint);\n            rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n        }\n        else {\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n        }\n    }\n    return rst;\n}\nfunction filterFullCirleLine(path) {\n    Util.each(path, function (subPath, index) {\n        var cur = subPath;\n        if (cur[0].toLowerCase() === 'a') {\n            var pre = path[index - 1];\n            var next = path[index + 1];\n            if (next && next[0].toLowerCase() === 'a') {\n                if (pre && pre[0].toLowerCase() === 'l') {\n                    pre[0] = 'M';\n                }\n            }\n            else if (pre && pre[0].toLowerCase() === 'a') {\n                if (next && next[0].toLowerCase() === 'l') {\n                    next[0] = 'M';\n                }\n            }\n        }\n    });\n}\nvar PathUtil = {\n    getLinePath: function getLinePath(points, isInCircle) {\n        return points2path(points, isInCircle);\n    },\n    getSplinePath: function getSplinePath(points, isInCircle, constaint) {\n        var data = [];\n        var first = points[0];\n        var prePoint = null;\n        if (points.length <= 2) {\n            return PathUtil.getLinePath(points, isInCircle);\n        }\n        Util.each(points, function (point) {\n            if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n                data.push(point.x);\n                data.push(point.y);\n                prePoint = point;\n            }\n        });\n        constaint = constaint || [\n            [0, 0], [1, 1]\n        ];\n        var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);\n        splinePath.unshift(['M', first.x, first.y]);\n        return splinePath;\n    },\n    getPointRadius: function getPointRadius(coord, point) {\n        var result = _getPointRadius(coord, point);\n        return result;\n    },\n    getPointAngle: function getPointAngle(coord, point) {\n        var center = coord.getCenter();\n        var angle = Math.atan2(point.y - center.y, point.x - center.x);\n        return angle;\n    },\n    convertNormalPath: function convertNormalPath(coord, path) {\n        var tmp = [];\n        Util.each(path, function (subPath) {\n            var action = subPath[0];\n            switch (action.toLowerCase()) {\n                case 'm':\n                case 'l':\n                case 'c':\n                    tmp.push(convertArr(subPath, coord));\n                    break;\n                case 'z':\n                default:\n                    tmp.push(subPath);\n                    break;\n            }\n        });\n        return tmp;\n    },\n    convertPolarPath: function convertPolarPath(coord, path) {\n        var tmp = [];\n        var pre;\n        var cur;\n        var transposed;\n        var equals;\n        Util.each(path, function (subPath, index) {\n            var action = subPath[0];\n            switch (action.toLowerCase()) {\n                case 'm':\n                case 'c':\n                case 'q':\n                    tmp.push(convertArr(subPath, coord));\n                    break;\n                case 'l':\n                    pre = path[index - 1];\n                    cur = subPath;\n                    transposed = coord.isTransposed;\n                    equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n                    if (equals) {\n                        tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n                    }\n                    else {\n                        tmp.push(convertArr(subPath, coord));\n                    }\n                    break;\n                case 'z':\n                default:\n                    tmp.push(subPath);\n                    break;\n            }\n        });\n        filterFullCirleLine(tmp);\n        return tmp;\n    }\n};\nmodule.exports = PathUtil;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g2/lib/geom/util/path.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g2/lib/geom/util/path.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview 计算path 使用的工具方法\n * @author dxq613@gmail.com\n */\nvar Util = require('../../util');\n\nvar Spline = require('./spline');\n\nfunction points2path(points, isInCircle) {\n  if (!points.length) {\n    return [];\n  }\n\n  var path = [];\n\n  for (var i = 0, length = points.length; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      path.push(['M', item.x, item.y]);\n    } else {\n      path.push(['L', item.x, item.y]);\n    }\n  }\n\n  if (isInCircle) {\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\nfunction _getPointRadius(coord, point) {\n  var center = coord.getCenter();\n  var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n  return r;\n}\n\nfunction convertArr(arr, coord) {\n  var len = arr.length;\n  var tmp = [arr[0]];\n\n  for (var i = 1; i < len; i = i + 2) {\n    var point = coord.convertPoint({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  // const radius = coord.getRadius();\n  // const inner = coord.innerRadius || 0;\n  // let innerRadius = inner * radius;\n  var transposed = coord.isTransposed;\n  var startAngle = coord.startAngle;\n  var endAngle = coord.endAngle;\n  var prePoint = {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = []; // innerRadius = innerRadius || 0;\n\n  var xDim = transposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convertPoint(curPoint);\n\n  var r = _getPointRadius(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convertPoint(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction filterFullCirleLine(path) {\n  Util.each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\nvar PathUtil = {\n  // 线的path\n  getLinePath: function getLinePath(points, isInCircle) {\n    return points2path(points, isInCircle);\n  },\n  // get spline： 限定了范围的平滑线\n  getSplinePath: function getSplinePath(points, isInCircle, constaint) {\n    var data = [];\n    var first = points[0];\n    var prePoint = null;\n\n    if (points.length <= 2) {\n      return PathUtil.getLinePath(points, isInCircle);\n    }\n\n    Util.each(points, function (point) {\n      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n        data.push(point.x);\n        data.push(point.y);\n        prePoint = point;\n      }\n    });\n    constaint = constaint || [// 范围\n    [0, 0], [1, 1]];\n    var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);\n    splinePath.unshift(['M', first.x, first.y]);\n    return splinePath;\n  },\n  getPointRadius: function getPointRadius(coord, point) {\n    var result = _getPointRadius(coord, point);\n\n    return result;\n  },\n  getPointAngle: function getPointAngle(coord, point) {\n    var center = coord.getCenter();\n    var angle = Math.atan2(point.y - center.y, point.x - center.x);\n    return angle;\n  },\n  convertNormalPath: function convertNormalPath(coord, path) {\n    var tmp = [];\n    Util.each(path, function (subPath) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'l':\n        case 'c':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    return tmp;\n  },\n  convertPolarPath: function convertPolarPath(coord, path) {\n    var tmp = [];\n    var pre;\n    var cur;\n    var transposed;\n    var equals;\n    Util.each(path, function (subPath, index) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'c':\n        case 'q':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'l':\n          pre = path[index - 1];\n          cur = subPath;\n          transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n          equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n          if (equals) {\n            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n          } else {\n            // y 不相等，所以直接转换\n            tmp.push(convertArr(subPath, coord));\n          }\n\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    filterFullCirleLine(tmp); // 过滤多余的直线\n\n    return tmp;\n  }\n};\nmodule.exports = PathUtil;"]}]}