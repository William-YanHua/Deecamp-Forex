{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\esm\\plots\\liquid\\geometry\\shape\\liquid.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\esm\\plots\\liquid\\geometry\\shape\\liquid.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { registerShape } from '../../../../dependents';\r\nimport { isArray, each, isNumber, mix } from '@antv/util';\r\nimport { getGlobalTheme } from '../../../../theme';\r\nimport { transform } from '../../../../util/g-util';\r\nvar globalTheme = getGlobalTheme();\r\nvar ShapeUtil = {\r\n    splitPoints: function (obj) {\r\n        var points = [];\r\n        var x = obj.x;\r\n        var y = obj.y;\r\n        y = isArray(y) ? y : [y];\r\n        each(y, function (yItem, index) {\r\n            var point = {\r\n                x: isArray(x) ? x[index] : x,\r\n                y: yItem,\r\n            };\r\n            points.push(point);\r\n        });\r\n        return points;\r\n    },\r\n    addFillAttrs: function (attrs, cfg) {\r\n        if (cfg.color && !attrs.fill) {\r\n            attrs.fill = cfg.color;\r\n        }\r\n        if (isNumber(cfg.opacity)) {\r\n            attrs.opacity = attrs.fillOpacity = cfg.opacity;\r\n        }\r\n    },\r\n    addStrokeAttrs: function (attrs, cfg) {\r\n        if (cfg.color && !attrs.stroke) {\r\n            attrs.stroke = cfg.color;\r\n        }\r\n        if (isNumber(cfg.opacity)) {\r\n            attrs.opacity = attrs.strokeOpacity = cfg.opacity;\r\n        }\r\n    },\r\n};\r\nvar ValueUtil = {\r\n    lerp: function (a, b, factor) {\r\n        return (1 - factor) * a + factor * b;\r\n    },\r\n};\r\nvar getFillAttrs = function (cfg) {\r\n    var defaultAttrs = {\r\n        lineWidth: 0,\r\n        fill: globalTheme.color,\r\n        fillOpacity: 0.85,\r\n    };\r\n    var attrs = mix({}, defaultAttrs, cfg.style);\r\n    ShapeUtil.addFillAttrs(attrs, cfg);\r\n    if (cfg.color && !attrs.stroke) {\r\n        attrs.stroke = attrs.stroke || cfg.color;\r\n    }\r\n    return attrs;\r\n};\r\nvar getLineAttrs = function (cfg) {\r\n    var defaultAttrs = {\r\n        fill: '#fff',\r\n        stroke: globalTheme.color,\r\n        fillOpacity: 0,\r\n        lineWidth: 2,\r\n    };\r\n    var attrs = mix({}, defaultAttrs, cfg.style);\r\n    ShapeUtil.addStrokeAttrs(attrs, cfg);\r\n    return attrs;\r\n};\r\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\r\n    if (stage === 0) {\r\n        return [\r\n            [x + ((1 / 2) * waveLength) / Math.PI / 2, amplitude / 2],\r\n            [x + ((1 / 2) * waveLength) / Math.PI, amplitude],\r\n            [x + waveLength / 4, amplitude],\r\n        ];\r\n    }\r\n    if (stage === 1) {\r\n        return [\r\n            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), amplitude],\r\n            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), amplitude / 2],\r\n            [x + waveLength / 4, 0],\r\n        ];\r\n    }\r\n    if (stage === 2) {\r\n        return [\r\n            [x + ((1 / 2) * waveLength) / Math.PI / 2, -amplitude / 2],\r\n            [x + ((1 / 2) * waveLength) / Math.PI, -amplitude],\r\n            [x + waveLength / 4, -amplitude],\r\n        ];\r\n    }\r\n    return [\r\n        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), -amplitude],\r\n        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), -amplitude / 2],\r\n        [x + waveLength / 4, 0],\r\n    ];\r\n}\r\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\r\n    var curves = Math.ceil(((2 * radius) / waveLength) * 4) * 2;\r\n    var path = [];\r\n    var _phase = phase;\r\n    while (_phase < -Math.PI * 2) {\r\n        _phase += Math.PI * 2;\r\n    }\r\n    while (_phase > 0) {\r\n        _phase -= Math.PI * 2;\r\n    }\r\n    _phase = (_phase / Math.PI / 2) * waveLength;\r\n    var left = cx - radius + _phase - radius * 2;\r\n    path.push(['M', left, waterLevel]);\r\n    var waveRight = 0;\r\n    for (var c = 0; c < curves; ++c) {\r\n        var stage = c % 4;\r\n        var pos = getWaterWavePositions((c * waveLength) / 4, stage, waveLength, amplitude);\r\n        path.push([\r\n            'C',\r\n            pos[0][0] + left,\r\n            -pos[0][1] + waterLevel,\r\n            pos[1][0] + left,\r\n            -pos[1][1] + waterLevel,\r\n            pos[2][0] + left,\r\n            -pos[2][1] + waterLevel,\r\n        ]);\r\n        if (c === curves - 1) {\r\n            waveRight = pos[2][0];\r\n        }\r\n    }\r\n    path.push(['L', waveRight + left, cy + radius]);\r\n    path.push(['L', left, cy + radius]);\r\n    path.push(['L', left, waterLevel]);\r\n    return path;\r\n}\r\nfunction addWaterWave(x, y, level, waveCount, color, group, clip, radius) {\r\n    var bbox = clip.getBBox();\r\n    var width = bbox.maxX - bbox.minX;\r\n    var height = bbox.maxY - bbox.minY;\r\n    var duration = 5000;\r\n    for (var i = 0; i < waveCount; i++) {\r\n        var factor = waveCount <= 1 ? 0 : i / (waveCount - 1);\r\n        var wave = group.addShape('path', {\r\n            attrs: {\r\n                path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / ValueUtil.lerp(56, 64, factor), x, y),\r\n                fill: color,\r\n                opacity: ValueUtil.lerp(0.6, 0.3, factor),\r\n            },\r\n        });\r\n        var matrix = transform([['t', width / 2, 0]]);\r\n        wave.animate({ matrix: matrix }, {\r\n            duration: ValueUtil.lerp(duration, 0.7 * duration, factor),\r\n            repeat: true,\r\n        });\r\n    }\r\n}\r\nregisterShape('interval', 'liquid-fill-gauge', {\r\n    draw: function (cfg, container) {\r\n        var cy = 0.5;\r\n        var minX = Infinity;\r\n        each(cfg.points, function (p) {\r\n            if (p.x < minX) {\r\n                minX = p.x;\r\n            }\r\n        });\r\n        var cx = 0.5;\r\n        var cp = this.parsePoint({ x: cx, y: cy });\r\n        var minP = this.parsePoint({ x: minX, y: 0.5 });\r\n        var xWidth = cp.x - minP.x;\r\n        var radius = Math.min(xWidth, minP.y);\r\n        var fill = getFillAttrs(cfg).fill;\r\n        var waves = container.addGroup({\r\n            name: 'waves',\r\n            attrs: {\r\n                x: cp.x,\r\n                y: cp.y,\r\n            },\r\n        });\r\n        waves.setClip({\r\n            type: 'circle',\r\n            attrs: {\r\n                x: cp.x,\r\n                y: cp.y,\r\n                r: radius,\r\n            },\r\n        });\r\n        var clipCircle = waves.get('clipShape');\r\n        addWaterWave(cp.x, cp.y, 1 - cfg.points[1].y, 3, fill, waves, clipCircle, radius * 4);\r\n        container.addShape('circle', {\r\n            name: 'wrap',\r\n            attrs: mix(getLineAttrs(cfg), {\r\n                x: cp.x,\r\n                y: cp.y,\r\n                r: radius,\r\n                fill: 'transparent',\r\n            }),\r\n        });\r\n        return waves[0];\r\n    },\r\n});\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\esm\\plots\\liquid\\geometry\\shape\\liquid.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\esm\\plots\\liquid\\geometry\\shape\\liquid.js"],"names":[],"mappings":"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","sourcesContent":["import { registerShape } from '../../../../dependents';\nimport { isArray, each, isNumber, mix } from '@antv/util';\nimport { getGlobalTheme } from '../../../../theme';\nimport { transform } from '../../../../util/g-util';\nvar globalTheme = getGlobalTheme();\nvar ShapeUtil = {\n    splitPoints: function (obj) {\n        var points = [];\n        var x = obj.x;\n        var y = obj.y;\n        y = isArray(y) ? y : [y];\n        each(y, function (yItem, index) {\n            var point = {\n                x: isArray(x) ? x[index] : x,\n                y: yItem,\n            };\n            points.push(point);\n        });\n        return points;\n    },\n    addFillAttrs: function (attrs, cfg) {\n        if (cfg.color && !attrs.fill) {\n            attrs.fill = cfg.color;\n        }\n        if (isNumber(cfg.opacity)) {\n            attrs.opacity = attrs.fillOpacity = cfg.opacity;\n        }\n    },\n    addStrokeAttrs: function (attrs, cfg) {\n        if (cfg.color && !attrs.stroke) {\n            attrs.stroke = cfg.color;\n        }\n        if (isNumber(cfg.opacity)) {\n            attrs.opacity = attrs.strokeOpacity = cfg.opacity;\n        }\n    },\n};\nvar ValueUtil = {\n    lerp: function (a, b, factor) {\n        return (1 - factor) * a + factor * b;\n    },\n};\nvar getFillAttrs = function (cfg) {\n    var defaultAttrs = {\n        lineWidth: 0,\n        fill: globalTheme.color,\n        fillOpacity: 0.85,\n    };\n    var attrs = mix({}, defaultAttrs, cfg.style);\n    ShapeUtil.addFillAttrs(attrs, cfg);\n    if (cfg.color && !attrs.stroke) {\n        attrs.stroke = attrs.stroke || cfg.color;\n    }\n    return attrs;\n};\nvar getLineAttrs = function (cfg) {\n    var defaultAttrs = {\n        fill: '#fff',\n        stroke: globalTheme.color,\n        fillOpacity: 0,\n        lineWidth: 2,\n    };\n    var attrs = mix({}, defaultAttrs, cfg.style);\n    ShapeUtil.addStrokeAttrs(attrs, cfg);\n    return attrs;\n};\n/**\n * 用贝塞尔曲线模拟正弦波\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n * @return {Array} 正弦片段曲线\n */\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\n    if (stage === 0) {\n        return [\n            [x + ((1 / 2) * waveLength) / Math.PI / 2, amplitude / 2],\n            [x + ((1 / 2) * waveLength) / Math.PI, amplitude],\n            [x + waveLength / 4, amplitude],\n        ];\n    }\n    if (stage === 1) {\n        return [\n            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), amplitude],\n            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), amplitude / 2],\n            [x + waveLength / 4, 0],\n        ];\n    }\n    if (stage === 2) {\n        return [\n            [x + ((1 / 2) * waveLength) / Math.PI / 2, -amplitude / 2],\n            [x + ((1 / 2) * waveLength) / Math.PI, -amplitude],\n            [x + waveLength / 4, -amplitude],\n        ];\n    }\n    return [\n        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), -amplitude],\n        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), -amplitude / 2],\n        [x + waveLength / 4, 0],\n    ];\n}\n/**\n * 获取水波路径\n * @param  {number} radius          半径\n * @param  {number} waterLevel      水位\n * @param  {number} waveLength      波长\n * @param  {number} phase           相位\n * @param  {number} amplitude       震幅\n * @param  {number} cx              圆心x\n * @param  {number} cy              圆心y\n * @return {Array}  path            路径\n * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135\n */\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\n    var curves = Math.ceil(((2 * radius) / waveLength) * 4) * 2;\n    var path = [];\n    var _phase = phase;\n    // map phase to [-Math.PI * 2, 0]\n    while (_phase < -Math.PI * 2) {\n        _phase += Math.PI * 2;\n    }\n    while (_phase > 0) {\n        _phase -= Math.PI * 2;\n    }\n    _phase = (_phase / Math.PI / 2) * waveLength;\n    var left = cx - radius + _phase - radius * 2;\n    /**\n     * top-left corner as start point\n     *\n     * draws this point\n     *  |\n     * \\|/\n     *  ~~~~~~~~\n     *  |      |\n     *  +------+\n     */\n    path.push(['M', left, waterLevel]);\n    /**\n     * top wave\n     *\n     * ~~~~~~~~ <- draws this sine wave\n     * |      |\n     * +------+\n     */\n    var waveRight = 0;\n    for (var c = 0; c < curves; ++c) {\n        var stage = c % 4;\n        var pos = getWaterWavePositions((c * waveLength) / 4, stage, waveLength, amplitude);\n        path.push([\n            'C',\n            pos[0][0] + left,\n            -pos[0][1] + waterLevel,\n            pos[1][0] + left,\n            -pos[1][1] + waterLevel,\n            pos[2][0] + left,\n            -pos[2][1] + waterLevel,\n        ]);\n        if (c === curves - 1) {\n            waveRight = pos[2][0];\n        }\n    }\n    /**\n     * top-right corner\n     *\n     *                       ~~~~~~~~\n     * 3. draws this line -> |      | <- 1. draws this line\n     *                       +------+\n     *                          ^\n     *                          |\n     *                  2. draws this line\n     */\n    path.push(['L', waveRight + left, cy + radius]);\n    path.push(['L', left, cy + radius]);\n    path.push(['L', left, waterLevel]);\n    return path;\n}\n/**\n * 添加水波\n * @param {number} x           中心x\n * @param {number} y           中心y\n * @param {number} level       水位等级 0～1\n * @param {number} waveCount   水波数\n * @param {number} colors      色值\n * @param {number} group       图组\n * @param {number} clip        用于剪切的图形\n * @param {number} radius      绘制图形的高度\n */\nfunction addWaterWave(x, y, level, waveCount, color, group, clip, radius) {\n    var bbox = clip.getBBox();\n    var width = bbox.maxX - bbox.minX;\n    var height = bbox.maxY - bbox.minY;\n    var duration = 5000;\n    for (var i = 0; i < waveCount; i++) {\n        var factor = waveCount <= 1 ? 0 : i / (waveCount - 1);\n        var wave = group.addShape('path', {\n            attrs: {\n                path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / ValueUtil.lerp(56, 64, factor), x, y),\n                fill: color,\n                opacity: ValueUtil.lerp(0.6, 0.3, factor),\n            },\n        });\n        /*wave.setClip({\n          type:'circle',\n          attrs: clip.attrs\n        })*/\n        // FIXME wave animation error in svg\n        // if (Global.renderer === 'canvas') {\n        var matrix = transform([['t', width / 2, 0]]);\n        wave.animate({ matrix: matrix }, {\n            duration: ValueUtil.lerp(duration, 0.7 * duration, factor),\n            repeat: true,\n        });\n        //}\n    }\n}\nregisterShape('interval', 'liquid-fill-gauge', {\n    draw: function (cfg, container) {\n        var cy = 0.5;\n        var minX = Infinity;\n        each(cfg.points, function (p) {\n            if (p.x < minX) {\n                minX = p.x;\n            }\n        });\n        var cx = 0.5;\n        var cp = this.parsePoint({ x: cx, y: cy });\n        var minP = this.parsePoint({ x: minX, y: 0.5 });\n        var xWidth = cp.x - minP.x;\n        var radius = Math.min(xWidth, minP.y);\n        var fill = getFillAttrs(cfg).fill;\n        var waves = container.addGroup({\n            name: 'waves',\n            attrs: {\n                x: cp.x,\n                y: cp.y,\n            },\n        });\n        waves.setClip({\n            type: 'circle',\n            attrs: {\n                x: cp.x,\n                y: cp.y,\n                r: radius,\n            },\n        });\n        var clipCircle = waves.get('clipShape');\n        addWaterWave(cp.x, cp.y, 1 - cfg.points[1].y, // cfg.y / (2 * cp.y),\n        3, fill, waves, clipCircle, radius * 4);\n        container.addShape('circle', {\n            name: 'wrap',\n            attrs: mix(getLineAttrs(cfg), {\n                x: cp.x,\n                y: cp.y,\n                r: radius,\n                fill: 'transparent',\n            }),\n        });\n        return waves[0];\n    },\n});\n//# sourceMappingURL=liquid.js.map"]}]}