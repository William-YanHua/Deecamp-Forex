{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\histogram.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\histogram.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar assign = require('@antv/util/lib/mix');\r\nvar forIn = require('@antv/util/lib/each');\r\nvar pick = require('@antv/util/lib/pick');\r\nvar partition = require('../../util/partition');\r\nvar registerTransform = require('../../data-set').registerTransform;\r\nvar getField = require('../../util/option-parser').getField;\r\nvar DEFAULT_OPTIONS = {\r\n    as: ['x', 'count'],\r\n    bins: 30,\r\n    offset: 0,\r\n    groupBy: []\r\n};\r\nfunction nearestBin(value, scale, offset) {\r\n    var temp = value - offset;\r\n    var div = Math.floor(temp / scale);\r\n    return [div * scale + offset, (div + 1) * scale + offset];\r\n}\r\nfunction transform(dataView, options) {\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var field = getField(options);\r\n    if (dataView.rows.length === 0) {\r\n        return;\r\n    }\r\n    var range = dataView.range(field);\r\n    var width = range[1] - range[0];\r\n    var binWidth = options.binWidth;\r\n    if (!binWidth) {\r\n        var bins = options.bins;\r\n        if (bins <= 0) {\r\n            throw new TypeError('Invalid bins: it must be a positive number!');\r\n        }\r\n        binWidth = width / bins;\r\n    }\r\n    var offset = options.offset % binWidth;\r\n    var rows = [];\r\n    var groupBy = options.groupBy;\r\n    var groups = partition(dataView.rows, groupBy);\r\n    forIn(groups, function (group) {\r\n        var bins = {};\r\n        var column = group.map(function (row) { return row[field]; });\r\n        column.forEach(function (value) {\r\n            var _a = __read(nearestBin(value, binWidth, offset), 2), x0 = _a[0], x1 = _a[1];\r\n            var binKey = x0 + \"-\" + x1;\r\n            bins[binKey] = bins[binKey] || {\r\n                x0: x0,\r\n                x1: x1,\r\n                count: 0\r\n            };\r\n            bins[binKey].count++;\r\n        });\r\n        var _a = __read(options.as, 2), asX = _a[0], asCount = _a[1];\r\n        if (!asX || !asCount) {\r\n            throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ \"x\", \"count\" ])!');\r\n        }\r\n        var meta = pick(group[0], groupBy);\r\n        forIn(bins, function (bin) {\r\n            var row = assign({}, meta);\r\n            row[asX] = [bin.x0, bin.x1];\r\n            row[asCount] = bin.count;\r\n            rows.push(row);\r\n        });\r\n    });\r\n    dataView.rows = rows;\r\n}\r\nregisterTransform('bin.histogram', transform);\r\nregisterTransform('bin.dot', transform);\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\histogram.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\histogram.js"],"names":[],"mappings":"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","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst pick = require('@antv/util/lib/pick');\nconst partition = require('../../util/partition');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getField\n} = require('../../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'count' ],\n  bins: 30,\n  offset: 0,\n  groupBy: []\n  // field: '', // required\n  // binWidth: 10, // override bins\n};\n\nfunction nearestBin(value, scale, offset) {\n  const temp = value - offset;\n  const div = Math.floor(temp / scale);\n  return [ div * scale + offset, (div + 1) * scale + offset ];\n}\n\nfunction transform(dataView, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const field = getField(options);\n  if (dataView.rows.length === 0) {\n    return;\n  }\n  const range = dataView.range(field);\n  const width = range[1] - range[0];\n  let binWidth = options.binWidth;\n  if (!binWidth) {\n    const bins = options.bins;\n    if (bins <= 0) {\n      throw new TypeError('Invalid bins: it must be a positive number!');\n    }\n    binWidth = width / bins;\n  }\n  const offset = options.offset % binWidth;\n\n  // grouping\n  const rows = [];\n  const groupBy = options.groupBy;\n  const groups = partition(dataView.rows, groupBy);\n  forIn(groups, group => {\n    const bins = {};\n    const column = group.map(row => row[field]);\n    column.forEach(value => {\n      const [ x0, x1 ] = nearestBin(value, binWidth, offset);\n      const binKey = `${x0}-${x1}`;\n      bins[binKey] = bins[binKey] || {\n        x0,\n        x1,\n        count: 0\n      };\n      bins[binKey].count ++;\n    });\n    const [ asX, asCount ] = options.as;\n    if (!asX || !asCount) {\n      throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ \"x\", \"count\" ])!');\n    }\n\n    const meta = pick(group[0], groupBy);\n    forIn(bins, bin => {\n      const row = assign({}, meta);\n      row[asX] = [ bin.x0, bin.x1 ];\n      row[asCount] = bin.count;\n      rows.push(row);\n    });\n  });\n  dataView.rows = rows;\n}\n\nregisterTransform('bin.histogram', transform);\nregisterTransform('bin.dot', transform);\n"]}]}