{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import treemapDice from \"./dice\";\r\nimport treemapSlice from \"./slice\";\r\nexport var phi = (1 + Math.sqrt(5)) / 2;\r\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\r\n    var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\r\n    while (i0 < n) {\r\n        dx = x1 - x0, dy = y1 - y0;\r\n        do\r\n            sumValue = nodes[i1++].value;\r\n        while (!sumValue && i1 < n);\r\n        minValue = maxValue = sumValue;\r\n        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\r\n        beta = sumValue * sumValue * alpha;\r\n        minRatio = Math.max(maxValue / beta, beta / minValue);\r\n        for (; i1 < n; ++i1) {\r\n            sumValue += nodeValue = nodes[i1].value;\r\n            if (nodeValue < minValue)\r\n                minValue = nodeValue;\r\n            if (nodeValue > maxValue)\r\n                maxValue = nodeValue;\r\n            beta = sumValue * sumValue * alpha;\r\n            newRatio = Math.max(maxValue / beta, beta / minValue);\r\n            if (newRatio > minRatio) {\r\n                sumValue -= nodeValue;\r\n                break;\r\n            }\r\n            minRatio = newRatio;\r\n        }\r\n        rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\r\n        if (row.dice)\r\n            treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\r\n        else\r\n            treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\r\n        value -= sumValue, i0 = i1;\r\n    }\r\n    return rows;\r\n}\r\nexport default (function custom(ratio) {\r\n    function squarify(parent, x0, y0, x1, y1) {\r\n        squarifyRatio(ratio, parent, x0, y0, x1, y1);\r\n    }\r\n    squarify.ratio = function (x) {\r\n        return custom((x = +x) > 1 ? x : 1);\r\n    };\r\n    return squarify;\r\n})(phi);\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js"],"names":[],"mappings":"AAAA,OAAO,WAAW,MAAM,QAAQ,CAAC;AACjC,OAAO,YAAY,MAAM,SAAS,CAAC;AAEnC,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAExC,MAAM,UAAU,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACzD,IAAI,IAAI,GAAG,EAAE,EACT,KAAK,GAAG,MAAM,CAAC,QAAQ,EACvB,GAAG,EACH,SAAS,EACT,EAAE,GAAG,CAAC,EACN,EAAE,GAAG,CAAC,EACN,CAAC,GAAG,KAAK,CAAC,MAAM,EAChB,EAAE,EAAE,EAAE,EACN,KAAK,GAAG,MAAM,CAAC,KAAK,EACpB,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,KAAK,EACL,IAAI,CAAC;IAET,OAAO,EAAE,GAAG,CAAC,EAAE;QACb,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;QAG3B;YAAG,QAAQ,GAAG,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;eAAQ,CAAC,QAAQ,IAAI,EAAE,GAAG,CAAC,EAAE;QAC7D,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC;QAC/B,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;QACrD,IAAI,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;QACnC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,CAAC;QAGtD,OAAO,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE;YACnB,QAAQ,IAAI,SAAS,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;YACxC,IAAI,SAAS,GAAG,QAAQ;gBAAE,QAAQ,GAAG,SAAS,CAAC;YAC/C,IAAI,SAAS,GAAG,QAAQ;gBAAE,QAAQ,GAAG,SAAS,CAAC;YAC/C,IAAI,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;YACnC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,CAAC;YACtD,IAAI,QAAQ,GAAG,QAAQ,EAAE;gBAAE,QAAQ,IAAI,SAAS,CAAC;gBAAC,MAAM;aAAE;YAC1D,QAAQ,GAAG,QAAQ,CAAC;SACrB;QAGD,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,EAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAC,CAAC,CAAC;QACjF,IAAI,GAAG,CAAC,IAAI;YAAE,WAAW,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;;YAChF,YAAY,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC7E,KAAK,IAAI,QAAQ,EAAE,EAAE,GAAG,EAAE,CAAC;KAC5B;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,eAAe,CAAC,SAAS,MAAM,CAAC,KAAK;IAEnC,SAAS,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACtC,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,CAAC;IAED,QAAQ,CAAC,KAAK,GAAG,UAAS,CAAC;QACzB,OAAO,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,CAAC,CAAC;IAEF,OAAO,QAAQ,CAAC;AAClB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC","sourcesContent":["import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n"]}]}