{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/position/bk.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/position/bk.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nvar _ = require(\"../lodash\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\nmodule.exports = {\n    positionX: positionX,\n    findType1Conflicts: findType1Conflicts,\n    findType2Conflicts: findType2Conflicts,\n    addConflict: addConflict,\n    hasConflict: hasConflict,\n    verticalAlignment: verticalAlignment,\n    horizontalCompaction: horizontalCompaction,\n    alignCoordinates: alignCoordinates,\n    findSmallestWidthAlignment: findSmallestWidthAlignment,\n    balance: balance\n};\nfunction findType1Conflicts(g, layering) {\n    var conflicts = {};\n    function visitLayer(prevLayer, layer) {\n        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _.last(layer);\n        _.forEach(layer, function (v, i) {\n            var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;\n            if (w || v === lastNode) {\n                _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n                    _.forEach(g.predecessors(scanNode), function (u) {\n                        var uLabel = g.node(u), uPos = uLabel.order;\n                        if ((uPos < k0 || k1 < uPos) &&\n                            !(uLabel.dummy && g.node(scanNode).dummy)) {\n                            addConflict(conflicts, u, scanNode);\n                        }\n                    });\n                });\n                scanPos = i + 1;\n                k0 = k1;\n            }\n        });\n        return layer;\n    }\n    _.reduce(layering, visitLayer);\n    return conflicts;\n}\nfunction findType2Conflicts(g, layering) {\n    var conflicts = {};\n    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n        var v;\n        _.forEach(_.range(southPos, southEnd), function (i) {\n            v = south[i];\n            if (g.node(v).dummy) {\n                _.forEach(g.predecessors(v), function (u) {\n                    var uNode = g.node(u);\n                    if (uNode.dummy &&\n                        (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n                        addConflict(conflicts, u, v);\n                    }\n                });\n            }\n        });\n    }\n    function visitLayer(north, south) {\n        var prevNorthPos = -1, nextNorthPos, southPos = 0;\n        _.forEach(south, function (v, southLookahead) {\n            if (g.node(v).dummy === \"border\") {\n                var predecessors = g.predecessors(v);\n                if (predecessors.length) {\n                    nextNorthPos = g.node(predecessors[0]).order;\n                    scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n                    southPos = southLookahead;\n                    prevNorthPos = nextNorthPos;\n                }\n            }\n            scan(south, southPos, south.length, nextNorthPos, north.length);\n        });\n        return south;\n    }\n    _.reduce(layering, visitLayer);\n    return conflicts;\n}\nfunction findOtherInnerSegmentNode(g, v) {\n    if (g.node(v).dummy) {\n        return _.find(g.predecessors(v), function (u) {\n            return g.node(u).dummy;\n        });\n    }\n}\nfunction addConflict(conflicts, v, w) {\n    if (v > w) {\n        var tmp = v;\n        v = w;\n        w = tmp;\n    }\n    var conflictsV = conflicts[v];\n    if (!conflictsV) {\n        conflicts[v] = conflictsV = {};\n    }\n    conflictsV[w] = true;\n}\nfunction hasConflict(conflicts, v, w) {\n    if (v > w) {\n        var tmp = v;\n        v = w;\n        w = tmp;\n    }\n    return _.has(conflicts[v], w);\n}\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n    var root = {}, align = {}, pos = {};\n    _.forEach(layering, function (layer) {\n        _.forEach(layer, function (v, order) {\n            root[v] = v;\n            align[v] = v;\n            pos[v] = order;\n        });\n    });\n    _.forEach(layering, function (layer) {\n        var prevIdx = -1;\n        _.forEach(layer, function (v) {\n            var ws = neighborFn(v);\n            if (ws.length) {\n                ws = _.sortBy(ws, function (w) { return pos[w]; });\n                var mp = (ws.length - 1) / 2;\n                for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n                    var w = ws[i];\n                    if (align[v] === v &&\n                        prevIdx < pos[w] &&\n                        !hasConflict(conflicts, v, w)) {\n                        align[w] = v;\n                        align[v] = root[v] = root[w];\n                        prevIdx = pos[w];\n                    }\n                }\n            }\n        });\n    });\n    return { root: root, align: align };\n}\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n    var xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n    function iterate(setXsFunc, nextNodesFunc) {\n        var stack = blockG.nodes();\n        var elem = stack.pop();\n        var visited = {};\n        while (elem) {\n            if (visited[elem]) {\n                setXsFunc(elem);\n            }\n            else {\n                visited[elem] = true;\n                stack.push(elem);\n                stack = stack.concat(nextNodesFunc(elem));\n            }\n            elem = stack.pop();\n        }\n    }\n    function pass1(elem) {\n        xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\n            return Math.max(acc, xs[e.v] + blockG.edge(e));\n        }, 0);\n    }\n    function pass2(elem) {\n        var min = blockG.outEdges(elem).reduce(function (acc, e) {\n            return Math.min(acc, xs[e.w] - blockG.edge(e));\n        }, Number.POSITIVE_INFINITY);\n        var node = g.node(elem);\n        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n            xs[elem] = Math.max(xs[elem], min);\n        }\n    }\n    iterate(pass1, blockG.predecessors.bind(blockG));\n    iterate(pass2, blockG.successors.bind(blockG));\n    _.forEach(align, function (v) {\n        xs[v] = xs[root[v]];\n    });\n    return xs;\n}\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n    var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n    _.forEach(layering, function (layer) {\n        var u;\n        _.forEach(layer, function (v) {\n            var vRoot = root[v];\n            blockGraph.setNode(vRoot);\n            if (u) {\n                var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);\n                blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n            }\n            u = v;\n        });\n    });\n    return blockGraph;\n}\nfunction findSmallestWidthAlignment(g, xss) {\n    return _.minBy(_.values(xss), function (xs) {\n        var max = Number.NEGATIVE_INFINITY;\n        var min = Number.POSITIVE_INFINITY;\n        _.forIn(xs, function (x, v) {\n            var halfWidth = width(g, v) / 2;\n            max = Math.max(x + halfWidth, max);\n            min = Math.min(x - halfWidth, min);\n        });\n        return max - min;\n    });\n}\nfunction alignCoordinates(xss, alignTo) {\n    var alignToVals = _.values(alignTo), alignToMin = _.min(alignToVals), alignToMax = _.max(alignToVals);\n    _.forEach([\"u\", \"d\"], function (vert) {\n        _.forEach([\"l\", \"r\"], function (horiz) {\n            var alignment = vert + horiz, xs = xss[alignment], delta;\n            if (xs === alignTo)\n                return;\n            var xsVals = _.values(xs);\n            delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n            if (delta) {\n                xss[alignment] = _.mapValues(xs, function (x) { return x + delta; });\n            }\n        });\n    });\n}\nfunction balance(xss, align) {\n    return _.mapValues(xss.ul, function (ignore, v) {\n        if (align) {\n            return xss[align.toLowerCase()][v];\n        }\n        else {\n            var xs = _.sortBy(_.map(xss, v));\n            return (xs[1] + xs[2]) / 2;\n        }\n    });\n}\nfunction positionX(g) {\n    var layering = util.buildLayerMatrix(g);\n    var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\n    var xss = {};\n    var adjustedLayering;\n    _.forEach([\"u\", \"d\"], function (vert) {\n        adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n        _.forEach([\"l\", \"r\"], function (horiz) {\n            if (horiz === \"r\") {\n                adjustedLayering = _.map(adjustedLayering, function (inner) {\n                    return _.values(inner).reverse();\n                });\n            }\n            var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n            var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n            var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n            if (horiz === \"r\") {\n                xs = _.mapValues(xs, function (x) { return -x; });\n            }\n            xss[vert + horiz] = xs;\n        });\n    });\n    var smallestWidth = findSmallestWidthAlignment(g, xss);\n    alignCoordinates(xss, smallestWidth);\n    return balance(xss, g.graph().align);\n}\nfunction sep(nodeSep, edgeSep, reverseSep) {\n    return function (g, v, w) {\n        var vLabel = g.node(v);\n        var wLabel = g.node(w);\n        var sum = 0;\n        var delta;\n        sum += vLabel.width / 2;\n        if (_.has(vLabel, \"labelpos\")) {\n            switch (vLabel.labelpos.toLowerCase()) {\n                case \"l\":\n                    delta = -vLabel.width / 2;\n                    break;\n                case \"r\":\n                    delta = vLabel.width / 2;\n                    break;\n            }\n        }\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n        sum += wLabel.width / 2;\n        if (_.has(wLabel, \"labelpos\")) {\n            switch (wLabel.labelpos.toLowerCase()) {\n                case \"l\":\n                    delta = wLabel.width / 2;\n                    break;\n                case \"r\":\n                    delta = -wLabel.width / 2;\n                    break;\n            }\n        }\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        return sum;\n    };\n}\nfunction width(g, v) {\n    return g.node(v).width;\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/position/bk.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/position/bk.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\n\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var\n      // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function(v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\n          _.forEach(g.predecessors(scanNode), function(u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) &&\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function(i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function(u) {\n          var uNode = g.node(u);\n          if (uNode.dummy &&\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function(v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function(u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function(layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function(v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v &&\n              prevIdx < pos[w] &&\n              !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function(v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function(layer) {\n    var u;\n    _.forEach(layer, function(v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function(vert) {\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function(ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach([\"u\", \"d\"], function(vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function(x) { return -x; });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function(g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = -vLabel.width / 2; break;\n      case \"r\": delta = vLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = wLabel.width / 2; break;\n      case \"r\": delta = -wLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n"]}]}