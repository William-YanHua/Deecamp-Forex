{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\chamberlin.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\chamberlin.js","mtime":1467686363000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { geoCentroid as centroid, geoProjection as projection, geoRotation as rotation } from \"d3-geo\";\r\nimport { abs, acos, asin, atan2, cos, epsilon, floor, pi, radians, sin, sqrt } from \"./math\";\r\nfunction distance(dPhi, c1, s1, c2, s2, dLambda) {\r\n    var cosdLambda = cos(dLambda), r;\r\n    if (abs(dPhi) > 1 || abs(dLambda) > 1) {\r\n        r = acos(s1 * s2 + c1 * c2 * cosdLambda);\r\n    }\r\n    else {\r\n        var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);\r\n        r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));\r\n    }\r\n    return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];\r\n}\r\nfunction angle(b, c, a) {\r\n    return acos((b * b + c * c - a * a) / (2 * b * c));\r\n}\r\nfunction longitude(lambda) {\r\n    return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));\r\n}\r\nexport function chamberlinRaw(p0, p1, p2) {\r\n    var points = [\r\n        [p0[0], p0[1], sin(p0[1]), cos(p0[1])],\r\n        [p1[0], p1[1], sin(p1[1]), cos(p1[1])],\r\n        [p2[0], p2[1], sin(p2[1]), cos(p2[1])]\r\n    ];\r\n    for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {\r\n        b = points[i];\r\n        a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);\r\n        a.point = [0, 0];\r\n    }\r\n    var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]), beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]), beta2 = pi - beta0;\r\n    points[2].point[1] = 0;\r\n    points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);\r\n    var mean = [\r\n        points[2].point[0] = points[0].point[0] + points[2].v[0] * cos(beta0),\r\n        2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * sin(beta0))\r\n    ];\r\n    function forward(lambda, phi) {\r\n        var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i;\r\n        for (i = 0; i < 3; ++i) {\r\n            var p = points[i];\r\n            v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);\r\n            if (!v[i][0])\r\n                return p.point;\r\n            v[i][1] = longitude(v[i][1] - p.v[1]);\r\n        }\r\n        var point = mean.slice();\r\n        for (i = 0; i < 3; ++i) {\r\n            var j = i == 2 ? 0 : i + 1;\r\n            var a = angle(points[i].v[0], v[i][0], v[j][0]);\r\n            if (v[i][1] < 0)\r\n                a = -a;\r\n            if (!i) {\r\n                point[0] += v[i][0] * cos(a);\r\n                point[1] -= v[i][0] * sin(a);\r\n            }\r\n            else if (i == 1) {\r\n                a = beta1 - a;\r\n                point[0] -= v[i][0] * cos(a);\r\n                point[1] -= v[i][0] * sin(a);\r\n            }\r\n            else {\r\n                a = beta2 - a;\r\n                point[0] += v[i][0] * cos(a);\r\n                point[1] += v[i][0] * sin(a);\r\n            }\r\n        }\r\n        point[0] /= 3, point[1] /= 3;\r\n        return point;\r\n    }\r\n    return forward;\r\n}\r\nfunction pointRadians(p) {\r\n    return p[0] *= radians, p[1] *= radians, p;\r\n}\r\nexport function chamberlinAfrica() {\r\n    return chamberlin([0, 22], [45, 22], [22.5, -22])\r\n        .scale(380)\r\n        .center([22.5, 2]);\r\n}\r\nexport default function chamberlin(p0, p1, p2) {\r\n    var c = centroid({ type: \"MultiPoint\", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = rotation(R), p = projection(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R), center = p.center;\r\n    delete p.rotate;\r\n    p.center = function (_) {\r\n        return arguments.length ? center(r(_)) : r.invert(center());\r\n    };\r\n    return p\r\n        .clipAngle(90);\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\chamberlin.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\chamberlin.js"],"names":[],"mappings":"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","sourcesContent":["import {geoCentroid as centroid, geoProjection as projection, geoRotation as rotation} from \"d3-geo\";\nimport {abs, acos, asin, atan2, cos, epsilon, floor, pi, radians, sin, sqrt} from \"./math\";\n\n// Azimuthal distance.\nfunction distance(dPhi, c1, s1, c2, s2, dLambda) {\n  var cosdLambda = cos(dLambda), r;\n  if (abs(dPhi) > 1 || abs(dLambda) > 1) {\n    r = acos(s1 * s2 + c1 * c2 * cosdLambda);\n  } else {\n    var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);\n    r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));\n  }\n  return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];\n}\n\n// Angle opposite a, and contained between sides of lengths b and c.\nfunction angle(b, c, a) {\n  return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n// Normalize longitude.\nfunction longitude(lambda) {\n  return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));\n}\n\nexport function chamberlinRaw(p0, p1, p2) {\n  var points = [\n    [p0[0], p0[1], sin(p0[1]), cos(p0[1])],\n    [p1[0], p1[1], sin(p1[1]), cos(p1[1])],\n    [p2[0], p2[1], sin(p2[1]), cos(p2[1])]\n  ];\n\n  for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {\n    b = points[i];\n    a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);\n    a.point = [0, 0];\n  }\n\n  var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]),\n      beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]),\n      beta2 = pi - beta0;\n\n  points[2].point[1] = 0;\n  points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);\n\n  var mean = [\n    points[2].point[0] = points[0].point[0] + points[2].v[0] * cos(beta0),\n    2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * sin(beta0))\n  ];\n\n  function forward(lambda, phi) {\n    var sinPhi = sin(phi),\n        cosPhi = cos(phi),\n        v = new Array(3), i;\n\n    // Compute distance and azimuth from control points.\n    for (i = 0; i < 3; ++i) {\n      var p = points[i];\n      v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);\n      if (!v[i][0]) return p.point;\n      v[i][1] = longitude(v[i][1] - p.v[1]);\n    }\n\n    // Arithmetic mean of interception points.\n    var point = mean.slice();\n    for (i = 0; i < 3; ++i) {\n      var j = i == 2 ? 0 : i + 1;\n      var a = angle(points[i].v[0], v[i][0], v[j][0]);\n      if (v[i][1] < 0) a = -a;\n\n      if (!i) {\n        point[0] += v[i][0] * cos(a);\n        point[1] -= v[i][0] * sin(a);\n      } else if (i == 1) {\n        a = beta1 - a;\n        point[0] -= v[i][0] * cos(a);\n        point[1] -= v[i][0] * sin(a);\n      } else {\n        a = beta2 - a;\n        point[0] += v[i][0] * cos(a);\n        point[1] += v[i][0] * sin(a);\n      }\n    }\n\n    point[0] /= 3, point[1] /= 3;\n    return point;\n  }\n\n  return forward;\n}\n\nfunction pointRadians(p) {\n  return p[0] *= radians, p[1] *= radians, p;\n}\n\nexport function chamberlinAfrica() {\n  return chamberlin([0, 22], [45, 22], [22.5, -22])\n      .scale(380)\n      .center([22.5, 2]);\n}\n\nexport default function chamberlin(p0, p1, p2) { // TODO order matters!\n  var c = centroid({type: \"MultiPoint\", coordinates: [p0, p1, p2]}),\n      R = [-c[0], -c[1]],\n      r = rotation(R),\n      p = projection(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R),\n      center = p.center;\n\n  delete p.rotate;\n\n  p.center = function(_) {\n    return arguments.length ? center(r(_)) : r.invert(center());\n  };\n\n  return p\n      .clipAngle(90);\n}\n"]}]}