{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unist-util-is\\index.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unist-util-is\\index.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["'use strict';\r\nmodule.exports = is;\r\nfunction is(test, node, index, parent, context) {\r\n    var hasParent = parent !== null && parent !== undefined;\r\n    var hasIndex = index !== null && index !== undefined;\r\n    var check = convert(test);\r\n    if (hasIndex &&\r\n        (typeof index !== 'number' || index < 0 || index === Infinity)) {\r\n        throw new Error('Expected positive finite index or child node');\r\n    }\r\n    if (hasParent && (!is(null, parent) || !parent.children)) {\r\n        throw new Error('Expected parent node');\r\n    }\r\n    if (!node || !node.type || typeof node.type !== 'string') {\r\n        return false;\r\n    }\r\n    if (hasParent !== hasIndex) {\r\n        throw new Error('Expected both parent and index');\r\n    }\r\n    return Boolean(check.call(context, node, index, parent));\r\n}\r\nfunction convert(test) {\r\n    if (typeof test === 'string') {\r\n        return typeFactory(test);\r\n    }\r\n    if (test === null || test === undefined) {\r\n        return ok;\r\n    }\r\n    if (typeof test === 'object') {\r\n        return ('length' in test ? anyFactory : matchesFactory)(test);\r\n    }\r\n    if (typeof test === 'function') {\r\n        return test;\r\n    }\r\n    throw new Error('Expected function, string, or object as test');\r\n}\r\nfunction convertAll(tests) {\r\n    var results = [];\r\n    var length = tests.length;\r\n    var index = -1;\r\n    while (++index < length) {\r\n        results[index] = convert(tests[index]);\r\n    }\r\n    return results;\r\n}\r\nfunction matchesFactory(test) {\r\n    return matches;\r\n    function matches(node) {\r\n        var key;\r\n        for (key in test) {\r\n            if (node[key] !== test[key]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction anyFactory(tests) {\r\n    var checks = convertAll(tests);\r\n    var length = checks.length;\r\n    return matches;\r\n    function matches() {\r\n        var index = -1;\r\n        while (++index < length) {\r\n            if (checks[index].apply(this, arguments)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction typeFactory(test) {\r\n    return type;\r\n    function type(node) {\r\n        return Boolean(node && node.type === test);\r\n    }\r\n}\r\nfunction ok() {\r\n    return true;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unist-util-is\\index.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unist-util-is\\index.js"],"names":[],"mappings":"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","sourcesContent":["'use strict'\n\n/* eslint-disable max-params */\n\n/* Expose. */\nmodule.exports = is\n\n/* Assert if `test` passes for `node`.\n * When a `parent` node is known the `index` of node */\nfunction is(test, node, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined\n  var hasIndex = index !== null && index !== undefined\n  var check = convert(test)\n\n  if (\n    hasIndex &&\n    (typeof index !== 'number' || index < 0 || index === Infinity)\n  ) {\n    throw new Error('Expected positive finite index or child node')\n  }\n\n  if (hasParent && (!is(null, parent) || !parent.children)) {\n    throw new Error('Expected parent node')\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index')\n  }\n\n  return Boolean(check.call(context, node, index, parent))\n}\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return ok\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\nfunction convertAll(tests) {\n  var results = []\n  var length = tests.length\n  var index = -1\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\n/* Utility assert each property in `test` is represented\n * in `node`, and each values are strictly equal. */\nfunction matchesFactory(test) {\n  return matches\n\n  function matches(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/* Utility to convert a string into a function which checks\n * a given nodeâ€™s type for said string. */\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n/* Utility to return true. */\nfunction ok() {\n  return true\n}\n"]}]}