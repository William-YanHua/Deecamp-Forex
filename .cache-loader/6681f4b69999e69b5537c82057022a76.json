{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo-projection/src/gilbert.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo-projection/src/gilbert.js","mtime":1467599198000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { geoEquirectangular, geoOrthographic } from \"d3-geo\";\nimport { asin, atan, degrees, radians, sin, tan } from \"./math\";\nfunction gilbertForward(point) {\n    return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\nfunction gilbertInvert(point) {\n    return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\nexport default function (projectionType) {\n    if (projectionType == null)\n        projectionType = geoOrthographic;\n    var projection = projectionType(), equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]);\n    function gilbert(point) {\n        return projection(gilbertForward(point));\n    }\n    if (projection.invert)\n        gilbert.invert = function (point) {\n            return gilbertInvert(projection.invert(point));\n        };\n    gilbert.stream = function (stream) {\n        var s1 = projection.stream(stream), s0 = equirectangular.stream({\n            point: function (lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n            lineStart: function () { s1.lineStart(); },\n            lineEnd: function () { s1.lineEnd(); },\n            polygonStart: function () { s1.polygonStart(); },\n            polygonEnd: function () { s1.polygonEnd(); }\n        });\n        s0.sphere = s1.sphere;\n        return s0;\n    };\n    function property(name) {\n        gilbert[name] = function (_) {\n            return arguments.length ? (projection[name](_), gilbert) : projection[name]();\n        };\n    }\n    gilbert.rotate = function (_) {\n        return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n    };\n    gilbert.center = function (_) {\n        return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n    };\n    property(\"clipAngle\");\n    property(\"clipExtent\");\n    property(\"scale\");\n    property(\"translate\");\n    property(\"precision\");\n    return gilbert\n        .scale(249.5);\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo-projection/src/gilbert.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo-projection/src/gilbert.js"],"names":[],"mappings":"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","sourcesContent":["import {geoEquirectangular, geoOrthographic} from \"d3-geo\";\nimport {asin, atan, degrees, radians, sin, tan} from \"./math\";\n\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\n\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\n\nexport default function(projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n      equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n\n  if (projection.invert) gilbert.invert = function(point) {\n    return gilbertInvert(projection.invert(point));\n  };\n\n  gilbert.stream = function(stream) {\n    var s1 = projection.stream(stream), s0 = equirectangular.stream({\n      point: function(lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n      lineStart: function() { s1.lineStart(); },\n      lineEnd: function() { s1.lineEnd(); },\n      polygonStart: function() { s1.polygonStart(); },\n      polygonEnd: function() { s1.polygonEnd(); }\n    });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n\n  function property(name) {\n    gilbert[name] = function(_) {\n      return arguments.length ? (projection[name](_), gilbert) : projection[name]();\n    };\n  }\n\n  gilbert.rotate = function(_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n\n  gilbert.center = function(_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n\n  return gilbert\n      .scale(249.5);\n}\n"]}]}