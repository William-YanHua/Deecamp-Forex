{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\regression.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\regression.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar assign = require('@antv/util/lib/mix');\r\nvar isArray = require('@antv/util/lib/type/is-array');\r\nvar isFunction = require('@antv/util/lib/type/is-function');\r\nvar isNil = require('@antv/util/lib/type/is-nil');\r\nvar isNumber = require('@antv/util/lib/type/is-number');\r\nvar isString = require('@antv/util/lib/type/is-string');\r\nvar keys = require('@antv/util/lib/object/keys');\r\nvar sum = require('simple-statistics').sum;\r\nvar getSeriesValues = require('../../util/get-series-values');\r\nvar kernel = require('../../util/kernel');\r\nvar registerTransform = require('../../data-set').registerTransform;\r\nvar getFields = require('../../util/option-parser').getFields;\r\nvar silverman = require('../../util/bandwidth').silverman;\r\nvar DEFAULT_OPTIONS = {\r\n    as: ['x', 'y'],\r\n    method: 'gaussian'\r\n};\r\nvar KERNEL_METHODS = keys(kernel);\r\nfunction weight(kernel, bandwidth, x_0, x_i) {\r\n    var arg = (x_i - x_0) / bandwidth;\r\n    return kernel(arg);\r\n}\r\nfunction vectorize(fun) {\r\n    return function (x) {\r\n        if (!isArray(x)) {\r\n            return fun(x);\r\n        }\r\n        return x.map(function (x) {\r\n            return fun(x);\r\n        });\r\n    };\r\n}\r\nfunction transform(dv, options) {\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var fields = getFields(options);\r\n    if (!isArray(fields) || (fields.length !== 1 && fields.length !== 2)) {\r\n        throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\r\n    }\r\n    var _a = __read(options.as, 2), asX = _a[0], asY = _a[1];\r\n    if (!isString(asX) || !isString(asY)) {\r\n        throw new TypeError('invalid as: must be an array of 2 strings!');\r\n    }\r\n    var method = options.method;\r\n    if (isString(method)) {\r\n        if (KERNEL_METHODS.indexOf(method) === -1) {\r\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\r\n        }\r\n        method = kernel[method];\r\n    }\r\n    if (!isFunction(method)) {\r\n        throw new TypeError('invalid method: kernel method must be a function!');\r\n    }\r\n    var _b = __read(fields, 2), xField = _b[0], yField = _b[1];\r\n    var xs = dv.getColumn(xField);\r\n    var extent = options.extent;\r\n    if (!isArray(extent)) {\r\n        extent = dv.range(xField);\r\n    }\r\n    var bandwidth = options.bandwidth;\r\n    if (!isNumber(bandwidth) || bandwidth <= 0) {\r\n        bandwidth = silverman(xs);\r\n    }\r\n    var seriesValues = getSeriesValues(extent, bandwidth);\r\n    var xCount = xs.length;\r\n    var weightFunc = weight.bind(null, method, bandwidth);\r\n    var kernelSmoother;\r\n    if (isNil(yField)) {\r\n        kernelSmoother = vectorize(function (x) {\r\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\r\n            var num = sum(weights);\r\n            var denom = xCount * bandwidth;\r\n            if (!num || !denom)\r\n                return 0;\r\n            return num / denom;\r\n        });\r\n    }\r\n    else {\r\n        var ys_1 = dv.getColumn(yField);\r\n        kernelSmoother = vectorize(function (x) {\r\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\r\n            var num = sum(weights.map(function (w, i) { return w * ys_1[i]; }));\r\n            var denom = sum(weights);\r\n            if (!num || !denom)\r\n                return 0;\r\n            return num / denom;\r\n        });\r\n    }\r\n    var result = seriesValues.map(function (x) {\r\n        var row = {};\r\n        row[asX] = x;\r\n        row[asY] = kernelSmoother(x);\r\n        return row;\r\n    });\r\n    dv.rows = result;\r\n}\r\nregisterTransform('kernel-smooth.regression', transform);\r\nregisterTransform('kernel.regression', transform);\r\nmodule.exports = {\r\n    KERNEL_METHODS: KERNEL_METHODS\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\regression.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\regression.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nconst assign = require('@antv/util/lib/mix');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNil = require('@antv/util/lib/type/is-nil');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\n// const regression = require('regression');\nconst {\n  sum\n} = require('simple-statistics');\nconst getSeriesValues = require('../../util/get-series-values');\n// const enclideanDistance = require('../../util/euclidean-distance');\nconst kernel = require('../../util/kernel');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\nconst {\n  silverman\n} = require('../../util/bandwidth');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y' ],\n  // fields: [ 'x', 'y' ], // required, one or two fields\n  method: 'gaussian' // kernel method: should be one of keys(kernel)\n  // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]\n  // bandwidth: 0.5 // bandWidth to execute kernel function\n};\n\nconst KERNEL_METHODS = keys(kernel);\n\n// calculates weight for i-th obs\nfunction weight(kernel, bandwidth, x_0, x_i) {\n  const arg = (x_i - x_0) / bandwidth;\n  return kernel(arg);\n}\n// calculates weight for i-th obs when p > 1\n// function weight_vectors(kernel, bandwidth, x_0, x_i) {\n//   const arg = enclideanDistance(x_i, x_0) / bandwidth;\n//   return kernel(arg);\n// }\nfunction vectorize(fun) {\n  return function(x) {\n    if (!isArray(x)) {\n      return fun(x);\n    }\n    return x.map(function(x) {\n      return fun(x);\n    });\n  };\n}\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || (fields.length !== 1 && fields.length !== 2)) {\n    throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\n  }\n  const [ asX, asY ] = options.as;\n  if (!isString(asX) || !isString(asY)) {\n    throw new TypeError('invalid as: must be an array of 2 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  const [ xField, yField ] = fields;\n  const xs = dv.getColumn(xField);\n\n  let extent = options.extent;\n  if (!isArray(extent)) {\n    extent = dv.range(xField);\n  }\n  let bandwidth = options.bandwidth;\n  if (!isNumber(bandwidth) || bandwidth <= 0) {\n    bandwidth = silverman(xs);\n  }\n  const seriesValues = getSeriesValues(extent, bandwidth);\n  const xCount = xs.length;\n  const weightFunc = weight.bind(null, method, bandwidth);\n  let kernelSmoother;\n\n  if (isNil(yField)) {\n    // KDE\n    kernelSmoother = vectorize(x => {\n      const weights = xs.map(x_i => weightFunc(x, x_i));\n      const num = sum(weights);\n      const denom = xCount * bandwidth;\n      if (!num || !denom) return 0;\n      return num / denom;\n    });\n  } else {\n    // kernel regression smoothing\n    const ys = dv.getColumn(yField);\n    kernelSmoother = vectorize(x => {\n      const weights = xs.map(x_i => weightFunc(x, x_i));\n      const num = sum(weights.map((w, i) => w * ys[i]));\n      const denom = sum(weights);\n      if (!num || !denom) return 0;\n      return num / denom;\n    });\n  }\n\n  const result = seriesValues.map(x => {\n    const row = {};\n    row[asX] = x;\n    row[asY] = kernelSmoother(x);\n    return row;\n  });\n  dv.rows = result;\n}\n\nregisterTransform('kernel-smooth.regression', transform);\nregisterTransform('kernel.regression', transform);\n\nmodule.exports = {\n  KERNEL_METHODS\n};\n"]}]}