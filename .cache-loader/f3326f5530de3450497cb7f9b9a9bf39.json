{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/tooltip.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/tooltip.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTooltipItems = exports.findDataByPoint = void 0;\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar constant_1 = require(\"../constant\");\nvar scale_1 = require(\"./scale\");\nfunction snapEqual(v1, v2, scale) {\n    var value1 = scale.translate(v1);\n    var value2 = scale.translate(v2);\n    return util_1.isNumberEqual(value1, value2);\n}\nfunction getXValueByPoint(point, geometry) {\n    var coordinate = geometry.coordinate;\n    var xScale = geometry.getXScale();\n    var range = xScale.range;\n    var rangeMax = range[range.length - 1];\n    var rangeMin = range[0];\n    var invertPoint = coordinate.invert(point);\n    var xValue = invertPoint.x;\n    if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n        xValue = rangeMin;\n    }\n    return xScale.translate(xScale.invert(xValue));\n}\nfunction filterYValue(data, point, geometry) {\n    var coordinate = geometry.coordinate;\n    var yScale = geometry.getYScale();\n    var yField = yScale.field;\n    var invertPoint = coordinate.invert(point);\n    var yValue = yScale.invert(invertPoint.y);\n    var result = util_1.find(data, function (obj) {\n        var originData = obj[constant_1.FIELD_ORIGIN];\n        return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n    });\n    return result || data[data.length - 1];\n}\nvar getXDistance = util_1.memoize(function (scale) {\n    if (scale.isCategory) {\n        return 1;\n    }\n    var scaleValues = scale.values;\n    var length = scaleValues.length;\n    var min = scale.translate(scaleValues[0]);\n    var max = min;\n    for (var index = 0; index < length; index++) {\n        var value = scaleValues[index];\n        var numericValue = scale.translate(value);\n        if (numericValue < min) {\n            min = numericValue;\n        }\n        if (numericValue > max) {\n            max = numericValue;\n        }\n    }\n    return (max - min) / (length - 1);\n});\nfunction getTooltipTitle(originData, geometry, title) {\n    var titleField = title;\n    if (!title) {\n        var positionAttr = geometry.getAttribute('position');\n        var fields = positionAttr.getFields();\n        titleField = fields[0];\n    }\n    var scales = geometry.scales;\n    if (scales[titleField]) {\n        return scales[titleField].getText(originData[titleField]);\n    }\n    return util_1.hasKey(originData, titleField) ? originData[titleField] : titleField;\n}\nfunction getAttributesForLegend(geometry) {\n    var attributes = util_1.values(geometry.attributes);\n    return util_1.filter(attributes, function (attribute) { return util_1.contains(constant_1.GROUP_ATTRS, attribute.type); });\n}\nfunction getTooltipValueScale(geometry) {\n    var attributes = getAttributesForLegend(geometry);\n    var scale;\n    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n        var attribute = attributes_1[_i];\n        var tmpScale = attribute.getScale(attribute.type);\n        if (tmpScale && tmpScale.isLinear) {\n            scale = tmpScale;\n            break;\n        }\n    }\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    return scale || yScale || xScale;\n}\nfunction getTooltipValue(originData, valueScale) {\n    var field = valueScale.field;\n    var value = originData[field];\n    if (util_1.isArray(value)) {\n        var texts = value.map(function (eachValue) {\n            return valueScale.getText(eachValue);\n        });\n        return texts.join('-');\n    }\n    return valueScale.getText(value);\n}\nfunction getTooltipName(originData, geometry) {\n    var nameScale;\n    var groupScales = geometry.getGroupScales();\n    if (groupScales.length) {\n        nameScale = groupScales[0];\n    }\n    if (nameScale) {\n        var field = nameScale.field;\n        return nameScale.getText(originData[field]);\n    }\n    var valueScale = getTooltipValueScale(geometry);\n    return scale_1.getName(valueScale);\n}\nfunction findDataByPoint(point, data, geometry) {\n    if (data.length === 0) {\n        return null;\n    }\n    var geometryType = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var xField = xScale.field;\n    var yField = yScale.field;\n    var rst = null;\n    if (geometryType === 'heatmap' || geometryType === 'point') {\n        var coordinate = geometry.coordinate;\n        var invertPoint = coordinate.invert(point);\n        var x = xScale.invert(invertPoint.x);\n        var y = yScale.invert(invertPoint.y);\n        var min = Infinity;\n        for (var index = 0; index < data.length; index++) {\n            var obj = data[index];\n            var originData = obj[constant_1.FIELD_ORIGIN];\n            var range = Math.pow((originData[xField] - x), 2) + Math.pow((originData[yField] - y), 2);\n            if (range < min) {\n                min = range;\n                rst = obj;\n            }\n        }\n        return rst;\n    }\n    var first = data[0];\n    var last = data[data.length - 1];\n    var xValue = getXValueByPoint(point, geometry);\n    var firstXValue = first[constant_1.FIELD_ORIGIN][xField];\n    var firstYValue = first[constant_1.FIELD_ORIGIN][yField];\n    var lastXValue = last[constant_1.FIELD_ORIGIN][xField];\n    var isYArray = yScale.isLinear && util_1.isArray(firstYValue);\n    if (util_1.isArray(firstXValue)) {\n        for (var index = 0; index < data.length; index++) {\n            var record = data[index];\n            var originData = record[constant_1.FIELD_ORIGIN];\n            if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n                if (isYArray) {\n                    if (!util_1.isArray(rst)) {\n                        rst = [];\n                    }\n                    rst.push(record);\n                }\n                else {\n                    rst = record;\n                    break;\n                }\n            }\n        }\n        if (util_1.isArray(rst)) {\n            rst = filterYValue(rst, point, geometry);\n        }\n    }\n    else {\n        var next = void 0;\n        if (!xScale.isLinear && xScale.type !== 'timeCat') {\n            for (var index = 0; index < data.length; index++) {\n                var record = data[index];\n                var originData = record[constant_1.FIELD_ORIGIN];\n                if (snapEqual(originData[xField], xValue, xScale)) {\n                    if (isYArray) {\n                        if (!util_1.isArray(rst)) {\n                            rst = [];\n                        }\n                        rst.push(record);\n                    }\n                    else {\n                        rst = record;\n                        break;\n                    }\n                }\n                else if (xScale.translate(originData[xField]) <= xValue) {\n                    last = record;\n                    next = data[index + 1];\n                }\n            }\n            if (util_1.isArray(rst)) {\n                rst = filterYValue(rst, point, geometry);\n            }\n        }\n        else {\n            if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n                (xValue > xScale.max || xValue < xScale.min)) {\n                return null;\n            }\n            var firstIdx = 0;\n            var lastIdx = data.length - 1;\n            var middleIdx = void 0;\n            while (firstIdx <= lastIdx) {\n                middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n                var item = data[middleIdx][constant_1.FIELD_ORIGIN][xField];\n                if (snapEqual(item, xValue, xScale)) {\n                    return data[middleIdx];\n                }\n                if (xScale.translate(item) <= xScale.translate(xValue)) {\n                    firstIdx = middleIdx + 1;\n                    last = data[middleIdx];\n                    next = data[middleIdx + 1];\n                }\n                else {\n                    if (lastIdx === 0) {\n                        last = data[0];\n                    }\n                    lastIdx = middleIdx - 1;\n                }\n            }\n        }\n        if (last && next) {\n            if (Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) >\n                Math.abs(xScale.translate(next[constant_1.FIELD_ORIGIN][xField]) - xValue)) {\n                last = next;\n            }\n        }\n    }\n    var distance = getXDistance(geometry.getXScale());\n    if (!rst && Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n        rst = last;\n    }\n    return rst;\n}\nexports.findDataByPoint = findDataByPoint;\nfunction getTooltipItems(data, geometry, title) {\n    if (title === void 0) {\n        title = '';\n    }\n    var originData = data[constant_1.FIELD_ORIGIN];\n    var tooltipTitle = getTooltipTitle(originData, geometry, title);\n    var tooltipOption = geometry.tooltipOption;\n    var defaultColor = geometry.theme.defaultColor;\n    var items = [];\n    var name;\n    var value;\n    function addItem(itemName, itemValue) {\n        if (!util_1.isNil(itemValue) && itemValue !== '') {\n            var item = {\n                title: tooltipTitle,\n                data: originData,\n                mappingData: data,\n                name: itemName,\n                value: itemValue,\n                color: data.color || defaultColor,\n                marker: true,\n            };\n            items.push(item);\n        }\n    }\n    if (util_1.isObject(tooltipOption)) {\n        var fields = tooltipOption.fields, callback = tooltipOption.callback;\n        if (callback) {\n            var callbackParams = fields.map(function (field) {\n                return data[constant_1.FIELD_ORIGIN][field];\n            });\n            var cfg = callback.apply(void 0, callbackParams);\n            var itemCfg = tslib_1.__assign({ data: data[constant_1.FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);\n            items.push(itemCfg);\n        }\n        else {\n            var scales = geometry.scales;\n            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n                var field = fields_1[_i];\n                if (!util_1.isNil(originData[field])) {\n                    var scale = scales[field];\n                    name = scale_1.getName(scale);\n                    value = scale.getText(originData[field]);\n                    addItem(name, value);\n                }\n            }\n        }\n    }\n    else {\n        var valueScale = getTooltipValueScale(geometry);\n        if (!util_1.isNil(originData[valueScale.field])) {\n            value = getTooltipValue(originData, valueScale);\n            name = getTooltipName(originData, geometry);\n            addItem(name, value);\n        }\n    }\n    return items;\n}\nexports.getTooltipItems = getTooltipItems;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/tooltip.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/tooltip.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;AACb,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AAC9D,OAAO,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;AAC3D,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;AAC/B,IAAI,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AACnC,IAAI,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AACxC,IAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AACjC,SAAS,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK;IAC5B,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACjC,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACjC,OAAO,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAChD,CAAC;AACD,SAAS,gBAAgB,CAAC,KAAK,EAAE,QAAQ;IACrC,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;IACrC,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IACzB,IAAI,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvC,IAAI,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACxB,IAAI,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC3C,IAAI,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC;IAC3B,IAAI,UAAU,CAAC,OAAO,IAAI,MAAM,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,EAAE;QACnD,MAAM,GAAG,QAAQ,CAAC;KACrB;IACD,OAAO,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AACnD,CAAC;AACD,SAAS,YAAY,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ;IACvC,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;IACrC,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC;IAC1B,IAAI,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC3C,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IAC1C,IAAI,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,GAAG;QACxC,IAAI,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;QAC9C,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC;IAC9E,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC3C,CAAC;AACD,IAAI,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,KAAK;IAC7C,IAAI,KAAK,CAAC,UAAU,EAAE;QAClB,OAAO,CAAC,CAAC;KACZ;IACD,IAAI,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC;IAC/B,IAAI,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;IAChC,IAAI,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,IAAI,GAAG,GAAG,GAAG,CAAC;IACd,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,EAAE,KAAK,EAAE,EAAE;QACzC,IAAI,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;QAE/B,IAAI,YAAY,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC1C,IAAI,YAAY,GAAG,GAAG,EAAE;YACpB,GAAG,GAAG,YAAY,CAAC;SACtB;QACD,IAAI,YAAY,GAAG,GAAG,EAAE;YACpB,GAAG,GAAG,YAAY,CAAC;SACtB;KACJ;IACD,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC;AACH,SAAS,eAAe,CAAC,UAAU,EAAE,QAAQ,EAAE,KAAK;IAChD,IAAI,UAAU,GAAG,KAAK,CAAC;IACvB,IAAI,CAAC,KAAK,EAAE;QACR,IAAI,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;QACrD,IAAI,MAAM,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;QACtC,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;KAC1B;IACD,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;IAC7B,IAAI,MAAM,CAAC,UAAU,CAAC,EAAE;QAEpB,OAAO,MAAM,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;KAC7D;IAED,OAAO,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;AACvF,CAAC;AACD,SAAS,sBAAsB,CAAC,QAAQ;IACpC,IAAI,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IACpD,OAAO,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,SAAS,IAAI,OAAO,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/H,CAAC;AACD,SAAS,oBAAoB,CAAC,QAAQ;IAClC,IAAI,UAAU,GAAG,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAClD,IAAI,KAAK,CAAC;IACV,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,YAAY,GAAG,UAAU,EAAE,EAAE,GAAG,YAAY,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;QACxE,IAAI,SAAS,GAAG,YAAY,CAAC,EAAE,CAAC,CAAC;QACjC,IAAI,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,QAAQ,IAAI,QAAQ,CAAC,QAAQ,EAAE;YAE/B,KAAK,GAAG,QAAQ,CAAC;YACjB,MAAM;SACT;KACJ;IACD,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,OAAO,KAAK,IAAI,MAAM,IAAI,MAAM,CAAC;AACrC,CAAC;AACD,SAAS,eAAe,CAAC,UAAU,EAAE,UAAU;IAC3C,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;IAC7B,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;IAC9B,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACvB,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,SAAS;YACrC,OAAO,UAAU,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QACH,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAC1B;IACD,OAAO,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACrC,CAAC;AAED,SAAS,cAAc,CAAC,UAAU,EAAE,QAAQ;IACxC,IAAI,SAAS,CAAC;IACd,IAAI,WAAW,GAAG,QAAQ,CAAC,cAAc,EAAE,CAAC;IAC5C,IAAI,WAAW,CAAC,MAAM,EAAE;QAEpB,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;KAC9B;IACD,IAAI,SAAS,EAAE;QACX,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;QAC5B,OAAO,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;KAC/C;IACD,IAAI,UAAU,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC;IAChD,OAAO,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;AACvC,CAAC;AASD,SAAS,eAAe,CAAC,KAAK,EAAE,IAAI,EAAE,QAAQ;IAC1C,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACnB,OAAO,IAAI,CAAC;KACf;IACD,IAAI,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACjC,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,IAAI,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;IAClC,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC;IAC1B,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC;IAC1B,IAAI,GAAG,GAAG,IAAI,CAAC;IAEf,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,KAAK,OAAO,EAAE;QAExD,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;QACrC,IAAI,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3C,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACrC,IAAI,GAAG,GAAG,QAAQ,CAAC;QACnB,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAC9C,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YACtB,IAAI,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;YAC9C,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1F,IAAI,KAAK,GAAG,GAAG,EAAE;gBACb,GAAG,GAAG,KAAK,CAAC;gBACZ,GAAG,GAAG,GAAG,CAAC;aACb;SACJ;QACD,OAAO,GAAG,CAAC;KACd;IAED,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACjC,IAAI,MAAM,GAAG,gBAAgB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC/C,IAAI,WAAW,GAAG,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC;IACzD,IAAI,WAAW,GAAG,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC;IACzD,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC;IACvD,IAAI,QAAQ,GAAG,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAE9D,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;QAC7B,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAC9C,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,IAAI,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;YAEjD,IAAI,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,EAAE;gBACxG,IAAI,QAAQ,EAAE;oBAEV,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;wBACtB,GAAG,GAAG,EAAE,CAAC;qBACZ;oBACD,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBACpB;qBACI;oBACD,GAAG,GAAG,MAAM,CAAC;oBACb,MAAM;iBACT;aACJ;SACJ;QACD,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACrB,GAAG,GAAG,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SAC5C;KACJ;SACI;QACD,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC;QAClB,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE;YAE/C,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;gBAC9C,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;gBACzB,IAAI,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;gBACjD,IAAI,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE;oBAC/C,IAAI,QAAQ,EAAE;wBACV,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;4BACtB,GAAG,GAAG,EAAE,CAAC;yBACZ;wBACD,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;qBACpB;yBACI;wBACD,GAAG,GAAG,MAAM,CAAC;wBACb,MAAM;qBACT;iBACJ;qBACI,IAAI,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,MAAM,EAAE;oBACrD,IAAI,GAAG,MAAM,CAAC;oBACd,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;iBAC1B;aACJ;YACD,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBACrB,GAAG,GAAG,YAAY,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;aAC5C;SACJ;aACI;YAED,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;gBACjF,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,EAAE;gBAE9C,OAAO,IAAI,CAAC;aACf;YACD,IAAI,QAAQ,GAAG,CAAC,CAAC;YACjB,IAAI,OAAO,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAC9B,IAAI,SAAS,GAAG,KAAK,CAAC,CAAC;YACvB,OAAO,QAAQ,IAAI,OAAO,EAAE;gBACxB,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;gBACjD,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC;gBAC5D,IAAI,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,EAAE;oBACjC,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC;iBAC1B;gBACD,IAAI,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;oBACpD,QAAQ,GAAG,SAAS,GAAG,CAAC,CAAC;oBACzB,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;oBACvB,IAAI,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;iBAC9B;qBACI;oBACD,IAAI,OAAO,KAAK,CAAC,EAAE;wBACf,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;qBAClB;oBACD,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC;iBAC3B;aACJ;SACJ;QACD,IAAI,IAAI,IAAI,IAAI,EAAE;YAEd,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC;gBAC1E,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE;gBAC5E,IAAI,GAAG,IAAI,CAAC;aACf;SACJ;KACJ;IACD,IAAI,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC,CAAC;IAClD,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,QAAQ,GAAG,CAAC,EAAE;QACpG,GAAG,GAAG,IAAI,CAAC;KACd;IACD,OAAO,GAAG,CAAC;AACf,CAAC;AACD,OAAO,CAAC,eAAe,GAAG,eAAe,CAAC;AAS1C,SAAS,eAAe,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK;IAC1C,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;QAAE,KAAK,GAAG,EAAE,CAAC;KAAE;IACrC,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;IAC/C,IAAI,YAAY,GAAG,eAAe,CAAC,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IAChE,IAAI,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC;IAC3C,IAAI,YAAY,GAAG,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC;IAC/C,IAAI,KAAK,GAAG,EAAE,CAAC;IACf,IAAI,IAAI,CAAC;IACT,IAAI,KAAK,CAAC;IACV,SAAS,OAAO,CAAC,QAAQ,EAAE,SAAS;QAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,SAAS,KAAK,EAAE,EAAE;YAE9C,IAAI,IAAI,GAAG;gBACP,KAAK,EAAE,YAAY;gBACnB,IAAI,EAAE,UAAU;gBAChB,WAAW,EAAE,IAAI;gBACjB,IAAI,EAAE,QAAQ;gBACd,KAAK,EAAE,SAAS;gBAChB,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,YAAY;gBACjC,MAAM,EAAE,IAAI;aACf,CAAC;YACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACpB;IACL,CAAC;IACD,IAAI,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;QAChC,IAAI,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,QAAQ,GAAG,aAAa,CAAC,QAAQ,CAAC;QACrE,IAAI,QAAQ,EAAE;YAEV,IAAI,cAAc,GAAG,MAAM,CAAC,GAAG,CAAC,UAAU,KAAK;gBAC3C,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;YACH,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,cAAc,CAAC,CAAC;YACjD,IAAI,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC;YACtK,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACvB;aACI;YACD,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;YAC7B,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,QAAQ,GAAG,MAAM,EAAE,EAAE,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;gBAC5D,IAAI,KAAK,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;gBACzB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;oBAElC,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;oBAC1B,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;oBAC9B,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;oBACzC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;iBACxB;aACJ;SACJ;KACJ;SACI;QACD,IAAI,UAAU,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC;QAChD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;YAE7C,KAAK,GAAG,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YAChD,IAAI,GAAG,cAAc,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YAC5C,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACxB;KACJ;IACD,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,OAAO,CAAC,eAAe,GAAG,eAAe,CAAC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTooltipItems = exports.findDataByPoint = void 0;\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar constant_1 = require(\"../constant\");\nvar scale_1 = require(\"./scale\");\nfunction snapEqual(v1, v2, scale) {\n    var value1 = scale.translate(v1);\n    var value2 = scale.translate(v2);\n    return util_1.isNumberEqual(value1, value2);\n}\nfunction getXValueByPoint(point, geometry) {\n    var coordinate = geometry.coordinate;\n    var xScale = geometry.getXScale();\n    var range = xScale.range;\n    var rangeMax = range[range.length - 1];\n    var rangeMin = range[0];\n    var invertPoint = coordinate.invert(point);\n    var xValue = invertPoint.x;\n    if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n        xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n    }\n    return xScale.translate(xScale.invert(xValue));\n}\nfunction filterYValue(data, point, geometry) {\n    var coordinate = geometry.coordinate;\n    var yScale = geometry.getYScale();\n    var yField = yScale.field;\n    var invertPoint = coordinate.invert(point);\n    var yValue = yScale.invert(invertPoint.y);\n    var result = util_1.find(data, function (obj) {\n        var originData = obj[constant_1.FIELD_ORIGIN];\n        return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n    });\n    return result || data[data.length - 1];\n}\nvar getXDistance = util_1.memoize(function (scale) {\n    if (scale.isCategory) {\n        return 1;\n    }\n    var scaleValues = scale.values; // values 是无序的\n    var length = scaleValues.length;\n    var min = scale.translate(scaleValues[0]);\n    var max = min;\n    for (var index = 0; index < length; index++) {\n        var value = scaleValues[index];\n        // 时间类型需要 translate\n        var numericValue = scale.translate(value);\n        if (numericValue < min) {\n            min = numericValue;\n        }\n        if (numericValue > max) {\n            max = numericValue;\n        }\n    }\n    return (max - min) / (length - 1);\n});\nfunction getTooltipTitle(originData, geometry, title) {\n    var titleField = title;\n    if (!title) {\n        var positionAttr = geometry.getAttribute('position');\n        var fields = positionAttr.getFields();\n        titleField = fields[0];\n    }\n    var scales = geometry.scales;\n    if (scales[titleField]) {\n        // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n        return scales[titleField].getText(originData[titleField]);\n    }\n    // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n    return util_1.hasKey(originData, titleField) ? originData[titleField] : titleField;\n}\nfunction getAttributesForLegend(geometry) {\n    var attributes = util_1.values(geometry.attributes);\n    return util_1.filter(attributes, function (attribute) { return util_1.contains(constant_1.GROUP_ATTRS, attribute.type); });\n}\nfunction getTooltipValueScale(geometry) {\n    var attributes = getAttributesForLegend(geometry);\n    var scale;\n    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n        var attribute = attributes_1[_i];\n        var tmpScale = attribute.getScale(attribute.type);\n        if (tmpScale && tmpScale.isLinear) {\n            // 如果指定字段是非 position 的，同时是连续的\n            scale = tmpScale;\n            break;\n        }\n    }\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    return scale || yScale || xScale;\n}\nfunction getTooltipValue(originData, valueScale) {\n    var field = valueScale.field;\n    var value = originData[field];\n    if (util_1.isArray(value)) {\n        var texts = value.map(function (eachValue) {\n            return valueScale.getText(eachValue);\n        });\n        return texts.join('-');\n    }\n    return valueScale.getText(value);\n}\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData, geometry) {\n    var nameScale;\n    var groupScales = geometry.getGroupScales();\n    if (groupScales.length) {\n        // 如果存在分组类型，取第一个分组类型\n        nameScale = groupScales[0];\n    }\n    if (nameScale) {\n        var field = nameScale.field;\n        return nameScale.getText(originData[field]);\n    }\n    var valueScale = getTooltipValueScale(geometry);\n    return scale_1.getName(valueScale);\n}\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nfunction findDataByPoint(point, data, geometry) {\n    if (data.length === 0) {\n        return null;\n    }\n    var geometryType = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var xField = xScale.field;\n    var yField = yScale.field;\n    var rst = null;\n    // 热力图采用最小逼近策略查找 point 击中的数据\n    if (geometryType === 'heatmap' || geometryType === 'point') {\n        // 将 point 画布坐标转换为原始数据值\n        var coordinate = geometry.coordinate;\n        var invertPoint = coordinate.invert(point); // 转换成归一化的数据\n        var x = xScale.invert(invertPoint.x); // 转换为原始值\n        var y = yScale.invert(invertPoint.y); // 转换为原始值\n        var min = Infinity;\n        for (var index = 0; index < data.length; index++) {\n            var obj = data[index];\n            var originData = obj[constant_1.FIELD_ORIGIN];\n            var range = Math.pow((originData[xField] - x), 2) + Math.pow((originData[yField] - y), 2);\n            if (range < min) {\n                min = range;\n                rst = obj;\n            }\n        }\n        return rst;\n    }\n    // 其他 Geometry 类型按照 x 字段数据进行查找\n    var first = data[0];\n    var last = data[data.length - 1];\n    var xValue = getXValueByPoint(point, geometry);\n    var firstXValue = first[constant_1.FIELD_ORIGIN][xField];\n    var firstYValue = first[constant_1.FIELD_ORIGIN][yField];\n    var lastXValue = last[constant_1.FIELD_ORIGIN][xField];\n    var isYArray = yScale.isLinear && util_1.isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n    // 如果 x 的值是数组\n    if (util_1.isArray(firstXValue)) {\n        for (var index = 0; index < data.length; index++) {\n            var record = data[index];\n            var originData = record[constant_1.FIELD_ORIGIN];\n            // xValue 在 originData[xField] 的数值区间内\n            if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n                if (isYArray) {\n                    // 层叠直方图场景，x 和 y 都是数组区间\n                    if (!util_1.isArray(rst)) {\n                        rst = [];\n                    }\n                    rst.push(record);\n                }\n                else {\n                    rst = record;\n                    break;\n                }\n            }\n        }\n        if (util_1.isArray(rst)) {\n            rst = filterYValue(rst, point, geometry);\n        }\n    }\n    else {\n        var next = void 0;\n        if (!xScale.isLinear && xScale.type !== 'timeCat') {\n            // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n            for (var index = 0; index < data.length; index++) {\n                var record = data[index];\n                var originData = record[constant_1.FIELD_ORIGIN];\n                if (snapEqual(originData[xField], xValue, xScale)) {\n                    if (isYArray) {\n                        if (!util_1.isArray(rst)) {\n                            rst = [];\n                        }\n                        rst.push(record);\n                    }\n                    else {\n                        rst = record;\n                        break;\n                    }\n                }\n                else if (xScale.translate(originData[xField]) <= xValue) {\n                    last = record;\n                    next = data[index + 1];\n                }\n            }\n            if (util_1.isArray(rst)) {\n                rst = filterYValue(rst, point, geometry);\n            }\n        }\n        else {\n            // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n            if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n                (xValue > xScale.max || xValue < xScale.min)) {\n                // 不在数据范围内\n                return null;\n            }\n            var firstIdx = 0;\n            var lastIdx = data.length - 1;\n            var middleIdx = void 0;\n            while (firstIdx <= lastIdx) {\n                middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n                var item = data[middleIdx][constant_1.FIELD_ORIGIN][xField];\n                if (snapEqual(item, xValue, xScale)) {\n                    return data[middleIdx];\n                }\n                if (xScale.translate(item) <= xScale.translate(xValue)) {\n                    firstIdx = middleIdx + 1;\n                    last = data[middleIdx];\n                    next = data[middleIdx + 1];\n                }\n                else {\n                    if (lastIdx === 0) {\n                        last = data[0];\n                    }\n                    lastIdx = middleIdx - 1;\n                }\n            }\n        }\n        if (last && next) {\n            // 计算最逼近的\n            if (Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) >\n                Math.abs(xScale.translate(next[constant_1.FIELD_ORIGIN][xField]) - xValue)) {\n                last = next;\n            }\n        }\n    }\n    var distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n    if (!rst && Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n        rst = last;\n    }\n    return rst;\n}\nexports.findDataByPoint = findDataByPoint;\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nfunction getTooltipItems(data, geometry, title) {\n    if (title === void 0) { title = ''; }\n    var originData = data[constant_1.FIELD_ORIGIN];\n    var tooltipTitle = getTooltipTitle(originData, geometry, title);\n    var tooltipOption = geometry.tooltipOption;\n    var defaultColor = geometry.theme.defaultColor;\n    var items = [];\n    var name;\n    var value;\n    function addItem(itemName, itemValue) {\n        if (!util_1.isNil(itemValue) && itemValue !== '') {\n            // 值为 null的时候，忽视\n            var item = {\n                title: tooltipTitle,\n                data: originData,\n                mappingData: data,\n                name: itemName,\n                value: itemValue,\n                color: data.color || defaultColor,\n                marker: true,\n            };\n            items.push(item);\n        }\n    }\n    if (util_1.isObject(tooltipOption)) {\n        var fields = tooltipOption.fields, callback = tooltipOption.callback;\n        if (callback) {\n            // 用户定义了回调函数\n            var callbackParams = fields.map(function (field) {\n                return data[constant_1.FIELD_ORIGIN][field];\n            });\n            var cfg = callback.apply(void 0, callbackParams);\n            var itemCfg = tslib_1.__assign({ data: data[constant_1.FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);\n            items.push(itemCfg);\n        }\n        else {\n            var scales = geometry.scales;\n            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n                var field = fields_1[_i];\n                if (!util_1.isNil(originData[field])) {\n                    // 字段数据为null, undefined 时不显示\n                    var scale = scales[field];\n                    name = scale_1.getName(scale);\n                    value = scale.getText(originData[field]);\n                    addItem(name, value);\n                }\n            }\n        }\n    }\n    else {\n        var valueScale = getTooltipValueScale(geometry);\n        if (!util_1.isNil(originData[valueScale.field])) {\n            // 字段数据为null ,undefined时不显示\n            value = getTooltipValue(originData, valueScale);\n            name = getTooltipName(originData, geometry);\n            addItem(name, value);\n        }\n    }\n    return items;\n}\nexports.getTooltipItems = getTooltipItems;\n//# sourceMappingURL=tooltip.js.map"]}]}