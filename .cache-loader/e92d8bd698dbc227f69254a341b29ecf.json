{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/core/shape.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/core/shape.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var Util = require('../util/index');\nvar isPointInPath = require('./mixin/isPointInPath');\nvar Element = require('./element');\nvar Inside = require('../shapes/util/inside');\nvar Shape = function Shape(cfg) {\n    Shape.superclass.constructor.call(this, cfg);\n};\nShape.ATTRS = {};\nUtil.extend(Shape, Element);\nvar ARRAY_ATTRS = {\n    matrix: 'matrix',\n    path: 'path',\n    points: 'points',\n    lineDash: 'lineDash'\n};\nfunction _cloneArrayAttr(arr) {\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (Util.isArray(arr[i])) {\n            result.push([].concat(arr[i]));\n        }\n        else {\n            result.push(arr[i]);\n        }\n    }\n    return result;\n}\nUtil.augment(Shape, isPointInPath, {\n    isShape: true,\n    drawInner: function drawInner(context) {\n        var self = this;\n        var attrs = self._attrs;\n        self.createPath(context);\n        var originOpacity = context.globalAlpha;\n        if (self.hasFill()) {\n            var fillOpacity = attrs.fillOpacity;\n            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                context.fill();\n                context.globalAlpha = originOpacity;\n            }\n            else {\n                context.fill();\n            }\n        }\n        if (self.hasStroke()) {\n            var lineWidth = self._attrs.lineWidth;\n            if (lineWidth > 0) {\n                var strokeOpacity = attrs.strokeOpacity;\n                if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = strokeOpacity;\n                }\n                context.stroke();\n            }\n        }\n        self.afterPath(context);\n    },\n    afterPath: function afterPath() { },\n    isHitBox: function isHitBox() {\n        return true;\n    },\n    isHit: function isHit(x, y) {\n        var self = this;\n        var v = [x, y, 1];\n        self.invert(v);\n        if (self.isHitBox()) {\n            var box = self.getBBox();\n            if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {\n                return false;\n            }\n        }\n        var clip = self._attrs.clip;\n        if (clip) {\n            clip.invert(v, self.get('canvas'));\n            if (clip.isPointInPath(v[0], v[1])) {\n                return self.isPointInPath(v[0], v[1]);\n            }\n        }\n        else {\n            return self.isPointInPath(v[0], v[1]);\n        }\n        return false;\n    },\n    calculateBox: function calculateBox() {\n        return null;\n    },\n    getHitLineWidth: function getHitLineWidth() {\n        var attrs = this._attrs;\n        var lineAppendWidth = attrs.lineAppendWidth || 0;\n        var lineWidth = attrs.lineWidth || 0;\n        return lineWidth + lineAppendWidth;\n    },\n    clearTotalMatrix: function clearTotalMatrix() {\n        this._cfg.totalMatrix = null;\n        this._cfg.region = null;\n    },\n    clearBBox: function clearBBox() {\n        this._cfg.box = null;\n        this._cfg.region = null;\n    },\n    getBBox: function getBBox() {\n        var box = this._cfg.box;\n        if (!box) {\n            box = this.calculateBox();\n            if (box) {\n                box.x = box.minX;\n                box.y = box.minY;\n                box.width = box.maxX - box.minX;\n                box.height = box.maxY - box.minY;\n            }\n            this._cfg.box = box;\n        }\n        return box;\n    },\n    clone: function clone() {\n        var self = this;\n        var clone = null;\n        var _attrs = self._attrs;\n        var attrs = {};\n        Util.each(_attrs, function (i, k) {\n            if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {\n                attrs[k] = _cloneArrayAttr(_attrs[k]);\n            }\n            else {\n                attrs[k] = _attrs[k];\n            }\n        });\n        clone = new self.constructor({\n            attrs: attrs\n        });\n        clone._cfg.zIndex = self._cfg.zIndex;\n        return clone;\n    }\n});\nmodule.exports = Shape;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/core/shape.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/g/lib/core/shape.js"],"names":[],"mappings":"AAAA,IAAI,IAAI,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AAEpC,IAAI,aAAa,GAAG,OAAO,CAAC,uBAAuB,CAAC,CAAC;AAErD,IAAI,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC;AAEnC,IAAI,MAAM,GAAG,OAAO,CAAC,uBAAuB,CAAC,CAAC;AAE9C,IAAI,KAAK,GAAG,SAAS,KAAK,CAAC,GAAG;IAC5B,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AAC/C,CAAC,CAAC;AAEF,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC;AACjB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AAC5B,IAAI,WAAW,GAAG;IAChB,MAAM,EAAE,QAAQ;IAChB,IAAI,EAAE,MAAM;IACZ,MAAM,EAAE,QAAQ;IAChB,QAAQ,EAAE,UAAU;CACrB,CAAC;AAEF,SAAS,eAAe,CAAC,GAAG;IAC1B,IAAI,MAAM,GAAG,EAAE,CAAC;IAEhB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;YACxB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAChC;aAAM;YACL,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SACrB;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,aAAa,EAAE;IACjC,OAAO,EAAE,IAAI;IACb,SAAS,EAAE,SAAS,SAAS,CAAC,OAAO;QACnC,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QACzB,IAAI,aAAa,GAAG,OAAO,CAAC,WAAW,CAAC;QAExC,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;YAClB,IAAI,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;YAEpC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,WAAW,KAAK,CAAC,EAAE;gBACjD,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC;gBAClC,OAAO,CAAC,IAAI,EAAE,CAAC;gBACf,OAAO,CAAC,WAAW,GAAG,aAAa,CAAC;aACrC;iBAAM;gBACL,OAAO,CAAC,IAAI,EAAE,CAAC;aAChB;SACF;QAED,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE;YACpB,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;YAEtC,IAAI,SAAS,GAAG,CAAC,EAAE;gBACjB,IAAI,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;gBAExC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,aAAa,KAAK,CAAC,EAAE;oBACrD,OAAO,CAAC,WAAW,GAAG,aAAa,CAAC;iBACrC;gBAED,OAAO,CAAC,MAAM,EAAE,CAAC;aAClB;SACF;QAED,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC1B,CAAC;IACD,SAAS,EAAE,SAAS,SAAS,KAAI,CAAC;IAMlC,QAAQ,EAAE,SAAS,QAAQ;QACzB,OAAO,IAAI,CAAC;IACd,CAAC;IAQD,KAAK,EAAE,SAAS,KAAK,CAAC,CAAC,EAAE,CAAC;QACxB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAClB,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAEf,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAE;YACnB,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAEzB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC1E,OAAO,KAAK,CAAC;aACd;SACF;QAED,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAE5B,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEnC,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACvC;SACF;aAAM;YACL,OAAO,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACvC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAOD,YAAY,EAAE,SAAS,YAAY;QACjC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,eAAe,EAAE,SAAS,eAAe;QACvC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;QAIxB,IAAI,eAAe,GAAG,KAAK,CAAC,eAAe,IAAI,CAAC,CAAC;QACjD,IAAI,SAAS,GAAG,KAAK,CAAC,SAAS,IAAI,CAAC,CAAC;QACrC,OAAO,SAAS,GAAG,eAAe,CAAC;IACrC,CAAC;IAED,gBAAgB,EAAE,SAAS,gBAAgB;QACzC,IAAI,CAAC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QAC7B,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;IAC1B,CAAC;IACD,SAAS,EAAE,SAAS,SAAS;QAC3B,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;IAC1B,CAAC;IACD,OAAO,EAAE,SAAS,OAAO;QACvB,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;QAExB,IAAI,CAAC,GAAG,EAAE;YACR,GAAG,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YAE1B,IAAI,GAAG,EAAE;gBACP,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;gBACjB,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;gBACjB,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;gBAChC,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;aAClC;YAED,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SACrB;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IACD,KAAK,EAAE,SAAS,KAAK;QACnB,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACzB,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,CAAC;YAC9B,IAAI,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC7C,KAAK,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;aACvC;iBAAM;gBACL,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;aACtB;QACH,CAAC,CAAC,CAAC;QACH,KAAK,GAAG,IAAI,IAAI,CAAC,WAAW,CAAC;YAC3B,KAAK,EAAE,KAAK;SACb,CAAC,CAAC;QAEH,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QACrC,OAAO,KAAK,CAAC;IACf,CAAC;CACF,CAAC,CAAC;AACH,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC","sourcesContent":["var Util = require('../util/index');\n\nvar isPointInPath = require('./mixin/isPointInPath');\n\nvar Element = require('./element');\n\nvar Inside = require('../shapes/util/inside');\n\nvar Shape = function Shape(cfg) {\n  Shape.superclass.constructor.call(this, cfg);\n};\n\nShape.ATTRS = {};\nUtil.extend(Shape, Element);\nvar ARRAY_ATTRS = {\n  matrix: 'matrix',\n  path: 'path',\n  points: 'points',\n  lineDash: 'lineDash'\n};\n\nfunction _cloneArrayAttr(arr) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (Util.isArray(arr[i])) {\n      result.push([].concat(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nUtil.augment(Shape, isPointInPath, {\n  isShape: true,\n  drawInner: function drawInner(context) {\n    var self = this;\n    var attrs = self._attrs;\n    self.createPath(context);\n    var originOpacity = context.globalAlpha;\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        context.fill();\n        context.globalAlpha = originOpacity;\n      } else {\n        context.fill();\n      }\n    }\n\n    if (self.hasStroke()) {\n      var lineWidth = self._attrs.lineWidth;\n\n      if (lineWidth > 0) {\n        var strokeOpacity = attrs.strokeOpacity;\n\n        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n\n        context.stroke();\n      }\n    }\n\n    self.afterPath(context);\n  },\n  afterPath: function afterPath() {},\n\n  /**\n   * 击中图形时是否进行包围盒判断\n   * @return {Boolean} [description]\n   */\n  isHitBox: function isHitBox() {\n    return true;\n  },\n\n  /**\n   * 节点是否能够被击中\n   * @param {Number} x x坐标\n   * @param {Number} y y坐标\n   * @return {Boolean} 是否在图形中\n   */\n  isHit: function isHit(x, y) {\n    var self = this;\n    var v = [x, y, 1];\n    self.invert(v); // canvas\n\n    if (self.isHitBox()) {\n      var box = self.getBBox();\n\n      if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {\n        return false;\n      }\n    }\n\n    var clip = self._attrs.clip;\n\n    if (clip) {\n      clip.invert(v, self.get('canvas'));\n\n      if (clip.isPointInPath(v[0], v[1])) {\n        return self.isPointInPath(v[0], v[1]);\n      }\n    } else {\n      return self.isPointInPath(v[0], v[1]);\n    }\n\n    return false;\n  },\n\n  /**\n   * @protected\n   * 计算包围盒\n   * @return {Object} 包围盒\n   */\n  calculateBox: function calculateBox() {\n    return null;\n  },\n  // 获取拾取时线的宽度，需要考虑附加的线的宽度\n  getHitLineWidth: function getHitLineWidth() {\n    var attrs = this._attrs; // if (!attrs.stroke) {\n    //   return 0;\n    // }\n\n    var lineAppendWidth = attrs.lineAppendWidth || 0;\n    var lineWidth = attrs.lineWidth || 0;\n    return lineWidth + lineAppendWidth;\n  },\n  // 清除当前的矩阵\n  clearTotalMatrix: function clearTotalMatrix() {\n    this._cfg.totalMatrix = null;\n    this._cfg.region = null;\n  },\n  clearBBox: function clearBBox() {\n    this._cfg.box = null;\n    this._cfg.region = null;\n  },\n  getBBox: function getBBox() {\n    var box = this._cfg.box; // 延迟计算\n\n    if (!box) {\n      box = this.calculateBox();\n\n      if (box) {\n        box.x = box.minX;\n        box.y = box.minY;\n        box.width = box.maxX - box.minX;\n        box.height = box.maxY - box.minY;\n      }\n\n      this._cfg.box = box;\n    }\n\n    return box;\n  },\n  clone: function clone() {\n    var self = this;\n    var clone = null;\n    var _attrs = self._attrs;\n    var attrs = {};\n    Util.each(_attrs, function (i, k) {\n      if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {\n        attrs[k] = _cloneArrayAttr(_attrs[k]);\n      } else {\n        attrs[k] = _attrs[k];\n      }\n    });\n    clone = new self.constructor({\n      attrs: attrs\n    }); // zIndex也是绘图属性，但是在cfg中，特殊处理\n\n    clone._cfg.zIndex = self._cfg.zIndex;\n    return clone;\n  }\n});\nmodule.exports = Shape;"]}]}