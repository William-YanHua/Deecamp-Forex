{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/components/label/point.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/components/label/point.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __assign, __extends } from \"tslib\";\nimport { get, map, isArray, last, each } from '@antv/util';\nimport { _ORIGIN } from '../../dependents';\nimport BaseLabel, { registerLabelComponent } from '../../components/label/base';\nimport { isBBoxIntersect } from '../../util/common';\nvar PointLabel = (function (_super) {\n    __extends(PointLabel, _super);\n    function PointLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PointLabel.prototype.getDefaultOptions = function () {\n        var theme = this.layer.theme;\n        var _a = theme.label, label = _a === void 0 ? {} : _a;\n        return __assign({ offsetX: 0, offsetY: 0 }, label);\n    };\n    PointLabel.prototype.getLabelOffset = function () {\n        return this.getLabelOffsetByDimAndFactor('y', -1);\n    };\n    PointLabel.prototype.getLabelItemAttrs = function (element, index) {\n        var _this = this;\n        var _a = this.options, style = _a.style, formatter = _a.formatter;\n        var mappingData = get(element, 'model.mappingData', []);\n        return map(mappingData, function (datum, datumIndex) {\n            var _a;\n            var value = _this.getValue(datum);\n            return __assign(__assign(__assign({}, _this.getPosition(datum)), { text: formatter\n                    ? formatter(value, (_a = {},\n                        _a[_ORIGIN] = datum._origin,\n                        _a.mappingDatum = datum,\n                        _a.mappingDatumIndex = datumIndex,\n                        _a.element = element,\n                        _a.elementIndex = index,\n                        _a), index)\n                    : value, textAlign: 'center', textBaseline: 'middle' }), style);\n        });\n    };\n    PointLabel.prototype.getValue = function (datum) {\n        return get(datum._origin, this.layer.options.yField);\n    };\n    PointLabel.prototype.getPosition = function (datum) {\n        var pos = {\n            x: isArray(datum.x) ? last(datum.x) : datum.x,\n            y: isArray(datum.y) ? last(datum.y) : datum.y,\n        };\n        return pos;\n    };\n    PointLabel.prototype.layoutLabels = function (geometry, labels) {\n        var _this = this;\n        if (!this.options.adjustPosition) {\n            return;\n        }\n        var overlap = this.isOverlapped(labels);\n        if (overlap) {\n            var tolerance_1 = this.getGlobalTolerance(labels);\n            each(labels, function (label, index) {\n                if (index > 1) {\n                    _this.labelResamplingByChange(label, labels, index, tolerance_1);\n                }\n            });\n        }\n        overlap = this.isOverlapped(labels);\n        if (overlap) {\n            each(labels, function (label, index) {\n                if (label.get('visible')) {\n                    _this.clearOverlapping(label, labels, index);\n                }\n            });\n        }\n    };\n    PointLabel.prototype.adjustLabel = function () {\n        return;\n    };\n    PointLabel.prototype.labelResamplingByChange = function (label, labels, index, tolerance) {\n        var previous = this.findPrevious(index, labels);\n        var currentCenter = this.getCenter(label);\n        var previousCenter = this.getCenter(previous);\n        var distX = previousCenter.x - currentCenter.x;\n        var distY = previousCenter.y - currentCenter.y;\n        var dist = Math.sqrt(distX * distX + distY * distY);\n        if (dist < tolerance) {\n            label.set('visible', false);\n        }\n    };\n    PointLabel.prototype.clearOverlapping = function (label, labels, index) {\n        var overlapped = [];\n        for (var i = 0; i < labels.length; i++) {\n            var current = labels[i];\n            if (i !== index && current.get('visible')) {\n                var isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());\n                if (isOverlap) {\n                    overlapped.push(current);\n                }\n            }\n        }\n        if (overlapped.length > 0) {\n            overlapped.push(label);\n            overlapped.sort(function (a, b) {\n                return b.minY - a.minY;\n            });\n            each(overlapped, function (label, index) {\n                if (index > 0) {\n                    label.set('visible', false);\n                }\n            });\n        }\n    };\n    PointLabel.prototype.isOverlapped = function (labels) {\n        for (var i = 0; i < labels.length; i++) {\n            if (labels[i].get('visible')) {\n                var labelABBox = labels[i].getBBox();\n                for (var j = 0; j < labels.length; j++) {\n                    if (j !== i && labels[j].get('visible')) {\n                        var labelBBBox = labels[j].getBBox();\n                        var intersection = isBBoxIntersect(labelABBox, labelBBBox);\n                        if (intersection) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    PointLabel.prototype.getGlobalTolerance = function (labels) {\n        var labelsClone = labels.slice();\n        labelsClone.sort(function (a, b) {\n            return b.getBBox().width - a.getBBox().width;\n        });\n        return Math.round(labelsClone[0].getBBox().width);\n    };\n    PointLabel.prototype.findPrevious = function (index, labels) {\n        for (var i = index - 1; i > 0; i--) {\n            if (labels[i].get('visible')) {\n                return labels[i];\n            }\n        }\n    };\n    PointLabel.prototype.getCenter = function (label) {\n        var _a = label.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;\n        return { x: minX + (maxX - minX) / 2, y: minY + (maxY - minY) / 2 };\n    };\n    return PointLabel;\n}(BaseLabel));\nexport default PointLabel;\nregisterLabelComponent('point', PointLabel);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/components/label/point.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/esm/components/label/point.js"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAC5C,OAAO,EAAE,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,YAAY,CAAC;AAC3D,OAAO,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAC;AAC3C,OAAO,SAAS,EAAE,EAAE,sBAAsB,EAAE,MAAM,6BAA6B,CAAC;AAChF,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAKpD,IAAI,UAAU,GAAiB,CAAC,UAAU,MAAM;IAC5C,SAAS,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IAC9B,SAAS,UAAU;QACf,OAAO,MAAM,KAAK,IAAI,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,IAAI,CAAC;IACpE,CAAC;IACD,UAAU,CAAC,SAAS,CAAC,iBAAiB,GAAG;QACrC,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;QAC7B,IAAI,EAAE,GAAG,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,EAAE,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QACtD,OAAO,QAAQ,CAAC,EAAE,OAAO,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;IACvD,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,cAAc,GAAG;QAClC,OAAO,IAAI,CAAC,4BAA4B,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,iBAAiB,GAAG,UAAU,OAAO,EAAE,KAAK;QAC7D,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,GAAG,EAAE,CAAC,KAAK,EAAE,SAAS,GAAG,EAAE,CAAC,SAAS,CAAC;QAClE,IAAI,WAAW,GAAG,GAAG,CAAC,OAAO,EAAE,mBAAmB,EAAE,EAAE,CAAC,CAAC;QACxD,OAAO,GAAG,CAAC,WAAW,EAAE,UAAU,KAAK,EAAE,UAAU;YAC/C,IAAI,EAAE,CAAC;YACP,IAAI,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAClC,OAAO,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,SAAS;oBAC1E,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE;wBACvB,EAAE,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO;wBAC3B,EAAE,CAAC,YAAY,GAAG,KAAK;wBACvB,EAAE,CAAC,iBAAiB,GAAG,UAAU;wBACjC,EAAE,CAAC,OAAO,GAAG,OAAO;wBACpB,EAAE,CAAC,YAAY,GAAG,KAAK;wBACvB,EAAE,CAAC,EAAE,KAAK,CAAC;oBACf,CAAC,CAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,QAAQ,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;QAC5E,CAAC,CAAC,CAAC;IACP,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAU,KAAK;QAC3C,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACzD,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,WAAW,GAAG,UAAU,KAAK;QAC9C,IAAI,GAAG,GAAG;YACN,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAC7C,CAAC,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;SAChD,CAAC;QACF,OAAO,GAAG,CAAC;IACf,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,UAAU,QAAQ,EAAE,MAAM;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;YAC9B,OAAO;SACV;QACD,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAExC,IAAI,OAAO,EAAE;YACT,IAAI,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;YAClD,IAAI,CAAC,MAAM,EAAE,UAAU,KAAK,EAAE,KAAK;gBAC/B,IAAI,KAAK,GAAG,CAAC,EAAE;oBACX,KAAK,CAAC,uBAAuB,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,CAAC,CAAC;iBACpE;YACL,CAAC,CAAC,CAAC;SACN;QACD,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAEpC,IAAI,OAAO,EAAE;YACT,IAAI,CAAC,MAAM,EAAE,UAAU,KAAK,EAAE,KAAK;gBAC/B,IAAI,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;oBACtB,KAAK,CAAC,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;iBAChD;YACL,CAAC,CAAC,CAAC;SACN;IACL,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,WAAW,GAAG;QAC/B,OAAO;IACX,CAAC,CAAC;IAEF,UAAU,CAAC,SAAS,CAAC,uBAAuB,GAAG,UAAU,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS;QACpF,IAAI,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAChD,IAAI,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC1C,IAAI,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAI,KAAK,GAAG,cAAc,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;QAC/C,IAAI,KAAK,GAAG,cAAc,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;QAC/C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,CAAC;QACpD,IAAI,IAAI,GAAG,SAAS,EAAE;YAClB,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;SAC/B;IACL,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,gBAAgB,GAAG,UAAU,KAAK,EAAE,MAAM,EAAE,KAAK;QAElE,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpC,IAAI,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,KAAK,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBACvC,IAAI,SAAS,GAAG,eAAe,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;gBACpE,IAAI,SAAS,EAAE;oBACX,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBAC5B;aACJ;SACJ;QAED,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YACvB,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACvB,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC1B,OAAO,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;YAC3B,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,UAAU,EAAE,UAAU,KAAK,EAAE,KAAK;gBACnC,IAAI,KAAK,GAAG,CAAC,EAAE;oBACX,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;iBAC/B;YACL,CAAC,CAAC,CAAC;SACN;IACL,CAAC,CAAC;IAEF,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,UAAU,MAAM;QAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC1B,IAAI,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;gBACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACpC,IAAI,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;wBACrC,IAAI,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;wBACrC,IAAI,YAAY,GAAG,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;wBAC3D,IAAI,YAAY,EAAE;4BACd,OAAO,IAAI,CAAC;yBACf;qBACJ;iBACJ;aACJ;SACJ;QACD,OAAO,KAAK,CAAC;IACjB,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,kBAAkB,GAAG,UAAU,MAAM;QACtD,IAAI,WAAW,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QACjC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YAC3B,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC;QACjD,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;IACtD,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,UAAU,KAAK,EAAE,MAAM;QACvD,KAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YAChC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC1B,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;aACpB;SACJ;IACL,CAAC,CAAC;IACF,UAAU,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,KAAK;QAC5C,IAAI,EAAE,GAAG,KAAK,CAAC,OAAO,EAAE,EAAE,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC;QACzF,OAAO,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;IACxE,CAAC,CAAC;IACF,OAAO,UAAU,CAAC;AACtB,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;AACd,eAAe,UAAU,CAAC;AAC1B,sBAAsB,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { get, map, isArray, last, each } from '@antv/util';\nimport { _ORIGIN } from '../../dependents';\nimport BaseLabel, { registerLabelComponent } from '../../components/label/base';\nimport { isBBoxIntersect } from '../../util/common';\n/**\n * 说明:\n * 适用于展示面积图和折线图上数据点的label\n * */\nvar PointLabel = /** @class */ (function (_super) {\n    __extends(PointLabel, _super);\n    function PointLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PointLabel.prototype.getDefaultOptions = function () {\n        var theme = this.layer.theme;\n        var _a = theme.label, label = _a === void 0 ? {} : _a;\n        return __assign({ offsetX: 0, offsetY: 0 }, label);\n    };\n    PointLabel.prototype.getLabelOffset = function () {\n        return this.getLabelOffsetByDimAndFactor('y', -1);\n    };\n    PointLabel.prototype.getLabelItemAttrs = function (element, index) {\n        var _this = this;\n        var _a = this.options, style = _a.style, formatter = _a.formatter;\n        var mappingData = get(element, 'model.mappingData', []);\n        return map(mappingData, function (datum, datumIndex) {\n            var _a;\n            var value = _this.getValue(datum);\n            return __assign(__assign(__assign({}, _this.getPosition(datum)), { text: formatter\n                    ? formatter(value, (_a = {},\n                        _a[_ORIGIN] = datum._origin,\n                        _a.mappingDatum = datum,\n                        _a.mappingDatumIndex = datumIndex,\n                        _a.element = element,\n                        _a.elementIndex = index,\n                        _a), index)\n                    : value, textAlign: 'center', textBaseline: 'middle' }), style);\n        });\n    };\n    PointLabel.prototype.getValue = function (datum) {\n        return get(datum._origin, this.layer.options.yField);\n    };\n    PointLabel.prototype.getPosition = function (datum) {\n        var pos = {\n            x: isArray(datum.x) ? last(datum.x) : datum.x,\n            y: isArray(datum.y) ? last(datum.y) : datum.y,\n        };\n        return pos;\n    };\n    PointLabel.prototype.layoutLabels = function (geometry, labels) {\n        var _this = this;\n        if (!this.options.adjustPosition) {\n            return;\n        }\n        var overlap = this.isOverlapped(labels);\n        // 规则1：先横向，优先显示横向上变化趋势大的label\n        if (overlap) {\n            var tolerance_1 = this.getGlobalTolerance(labels);\n            each(labels, function (label, index) {\n                if (index > 1) {\n                    _this.labelResamplingByChange(label, labels, index, tolerance_1);\n                }\n            });\n        }\n        overlap = this.isOverlapped(labels);\n        // 规则2： 后纵向，优先保留纵向最高点label\n        if (overlap) {\n            each(labels, function (label, index) {\n                if (label.get('visible')) {\n                    _this.clearOverlapping(label, labels, index);\n                }\n            });\n        }\n    };\n    PointLabel.prototype.adjustLabel = function () {\n        return;\n    };\n    /** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */\n    PointLabel.prototype.labelResamplingByChange = function (label, labels, index, tolerance) {\n        var previous = this.findPrevious(index, labels);\n        var currentCenter = this.getCenter(label);\n        var previousCenter = this.getCenter(previous);\n        var distX = previousCenter.x - currentCenter.x;\n        var distY = previousCenter.y - currentCenter.y;\n        var dist = Math.sqrt(distX * distX + distY * distY);\n        if (dist < tolerance) {\n            label.set('visible', false);\n        }\n    };\n    PointLabel.prototype.clearOverlapping = function (label, labels, index) {\n        // 找到所有与当前点overlap的node\n        var overlapped = [];\n        for (var i = 0; i < labels.length; i++) {\n            var current = labels[i];\n            if (i !== index && current.get('visible')) {\n                var isOverlap = isBBoxIntersect(label.getBBox(), current.getBBox());\n                if (isOverlap) {\n                    overlapped.push(current);\n                }\n            }\n        }\n        // 对overapped label进行处理\n        if (overlapped.length > 0) {\n            overlapped.push(label);\n            overlapped.sort(function (a, b) {\n                return b.minY - a.minY;\n            });\n            // 隐藏除最高点以外的label\n            each(overlapped, function (label, index) {\n                if (index > 0) {\n                    label.set('visible', false);\n                }\n            });\n        }\n    };\n    /** 检测一组label中是否存在重叠 **/\n    PointLabel.prototype.isOverlapped = function (labels) {\n        for (var i = 0; i < labels.length; i++) {\n            if (labels[i].get('visible')) {\n                var labelABBox = labels[i].getBBox();\n                for (var j = 0; j < labels.length; j++) {\n                    if (j !== i && labels[j].get('visible')) {\n                        var labelBBBox = labels[j].getBBox();\n                        var intersection = isBBoxIntersect(labelABBox, labelBBBox);\n                        if (intersection) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    PointLabel.prototype.getGlobalTolerance = function (labels) {\n        var labelsClone = labels.slice();\n        labelsClone.sort(function (a, b) {\n            return b.getBBox().width - a.getBBox().width;\n        });\n        return Math.round(labelsClone[0].getBBox().width);\n    };\n    PointLabel.prototype.findPrevious = function (index, labels) {\n        for (var i = index - 1; i > 0; i--) {\n            if (labels[i].get('visible')) {\n                return labels[i];\n            }\n        }\n    };\n    PointLabel.prototype.getCenter = function (label) {\n        var _a = label.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;\n        return { x: minX + (maxX - minX) / 2, y: minY + (maxY - minY) / 2 };\n    };\n    return PointLabel;\n}(BaseLabel));\nexport default PointLabel;\nregisterLabelComponent('point', PointLabel);\n//# sourceMappingURL=point.js.map"]}]}