{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\component\\lib\\axis\\circle.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\component\\lib\\axis\\circle.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\r\nvar Util = require('../util');\r\nvar Base = require('./base');\r\nvar vec2 = Util.MatrixUtil.vec2;\r\nvar Circle = function (_Base) {\r\n    _inheritsLoose(Circle, _Base);\r\n    function Circle() {\r\n        return _Base.apply(this, arguments) || this;\r\n    }\r\n    var _proto = Circle.prototype;\r\n    _proto.getDefaultCfg = function getDefaultCfg() {\r\n        var cfg = _Base.prototype.getDefaultCfg.call(this);\r\n        return Util.mix({}, cfg, {\r\n            type: 'circle',\r\n            tickInterval: null,\r\n            startAngle: -Math.PI / 2,\r\n            endAngle: Math.PI * 3 / 2,\r\n            line: {\r\n                lineWidth: 1,\r\n                stroke: '#C0D0E0'\r\n            },\r\n            tickLine: {\r\n                lineWidth: 1,\r\n                stroke: '#C0D0E0',\r\n                length: 5\r\n            },\r\n            _labelOffset: 5\r\n        });\r\n    };\r\n    _proto.parseTick = function parseTick(tick, index, length) {\r\n        return {\r\n            text: tick,\r\n            value: index / length\r\n        };\r\n    };\r\n    _proto._getCirclePoint = function _getCirclePoint(angle, radius) {\r\n        var self = this;\r\n        var center = self.get('center');\r\n        radius = radius || self.get('radius');\r\n        return {\r\n            x: center.x + Math.cos(angle) * radius,\r\n            y: center.y + Math.sin(angle) * radius\r\n        };\r\n    };\r\n    _proto.getTickPoint = function getTickPoint(value) {\r\n        var self = this;\r\n        var startAngle = self.get('startAngle');\r\n        var endAngle = self.get('endAngle');\r\n        var angle = startAngle + (endAngle - startAngle) * value;\r\n        return self._getCirclePoint(angle);\r\n    };\r\n    _proto.getSideVector = function getSideVector(offset, point) {\r\n        var self = this;\r\n        var center = self.get('center');\r\n        var vector = [point.x - center.x, point.y - center.y];\r\n        if (!Util.isNil(offset)) {\r\n            var vecLen = vec2.length(vector);\r\n            vec2.scale(vector, vector, offset / vecLen);\r\n        }\r\n        return vector;\r\n    };\r\n    _proto.getSidePoint = function getSidePoint(point, offset) {\r\n        var self = this;\r\n        var vector = self.getSideVector(offset, point);\r\n        return {\r\n            x: point.x + vector[0],\r\n            y: point.y + vector[1]\r\n        };\r\n    };\r\n    _proto.getTickEnd = function getTickEnd(start, length) {\r\n        var self = this;\r\n        var tickLine = self.get('tickLine');\r\n        length = length ? length : tickLine.length;\r\n        return self.getSidePoint(start, length);\r\n    };\r\n    _proto.getTextAnchor = function getTextAnchor(vector) {\r\n        var align;\r\n        if (Util.snapEqual(vector[0], 0)) {\r\n            align = 'center';\r\n        }\r\n        else if (vector[0] > 0) {\r\n            align = 'left';\r\n        }\r\n        else if (vector[0] < 0) {\r\n            align = 'right';\r\n        }\r\n        return align;\r\n    };\r\n    _proto.getLinePath = function getLinePath() {\r\n        var self = this;\r\n        var center = self.get('center');\r\n        var x = center.x;\r\n        var y = center.y;\r\n        var rx = self.get('radius');\r\n        var ry = rx;\r\n        var startAngle = self.get('startAngle');\r\n        var endAngle = self.get('endAngle');\r\n        var inner = self.get('inner');\r\n        var path = [];\r\n        if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\r\n            path = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\r\n        }\r\n        else {\r\n            var startPoint = self._getCirclePoint(startAngle);\r\n            var endPoint = self._getCirclePoint(endAngle);\r\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\r\n            var sweep = startAngle > endAngle ? 0 : 1;\r\n            if (!inner) {\r\n                path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];\r\n            }\r\n            else {\r\n                var innerStartVector = self.getSideVector(inner * rx, startPoint);\r\n                var innerEndVector = self.getSideVector(inner * rx, endPoint);\r\n                var innerStartPoint = {\r\n                    x: innerStartVector[0] + x,\r\n                    y: innerStartVector[1] + y\r\n                };\r\n                var innerEndPoint = {\r\n                    x: innerEndVector[0] + x,\r\n                    y: innerEndVector[1] + y\r\n                };\r\n                path = [['M', innerStartPoint.x, innerStartPoint.y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', innerEndPoint.x, innerEndPoint.y], ['A', rx * inner, ry * inner, 0, large, Math.abs(sweep - 1), innerStartPoint.x, innerStartPoint.y]];\r\n            }\r\n        }\r\n        return path;\r\n    };\r\n    _proto.addLabel = function addLabel(tick, point, index) {\r\n        var self = this;\r\n        var offset = self.get('label').offset || self.get('_labelOffset') || 0.001;\r\n        point = self.getSidePoint(point, offset);\r\n        _Base.prototype.addLabel.call(this, tick, point, index);\r\n    };\r\n    _proto.autoRotateLabels = function autoRotateLabels() {\r\n        var self = this;\r\n        var ticks = self.get('ticks');\r\n        var labelRenderer = self.get('labelRenderer');\r\n        if (labelRenderer && ticks.length > 12) {\r\n            var radius = self.get('radius');\r\n            var startAngle = self.get('startAngle');\r\n            var endAngle = self.get('endAngle');\r\n            var totalAngle = endAngle - startAngle;\r\n            var avgAngle = totalAngle / (ticks.length - 1);\r\n            var avgWidth = Math.sin(avgAngle / 2) * radius * 2;\r\n            var maxLength = self.getMaxLabelWidth(labelRenderer);\r\n            Util.each(labelRenderer.get('group').get('children'), function (label, index) {\r\n                var tick = ticks[index];\r\n                var angle = tick.value * totalAngle + startAngle;\r\n                var mode = angle % (Math.PI * 2);\r\n                if (maxLength < avgWidth) {\r\n                    if (mode <= 0) {\r\n                        angle = angle + Math.PI;\r\n                    }\r\n                    if (mode > Math.PI) {\r\n                        angle = angle - Math.PI;\r\n                    }\r\n                    angle = angle - Math.PI / 2;\r\n                    label.attr('textAlign', 'center');\r\n                }\r\n                else {\r\n                    if (mode > Math.PI / 2) {\r\n                        angle = angle - Math.PI;\r\n                    }\r\n                    else if (mode < Math.PI / 2 * -1) {\r\n                        angle = angle + Math.PI;\r\n                    }\r\n                }\r\n                label.rotateAtStart(angle);\r\n            });\r\n        }\r\n    };\r\n    return Circle;\r\n}(Base);\r\nmodule.exports = Circle;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\component\\lib\\axis\\circle.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\node_modules\\@antv\\component\\lib\\axis\\circle.js"],"names":[],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = require('../util');\n\nvar Base = require('./base');\n\nvar vec2 = Util.MatrixUtil.vec2;\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Circle, _Base);\n\n  function Circle() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Circle.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 坐标轴的类型\n       * @type {String}\n       */\n      type: 'circle',\n\n      /**\n       * 指定刻度之间的间距\n       * @type {Number}\n       */\n      tickInterval: null,\n\n      /**\n       * 开始弧度\n       * @type {Number}\n       */\n      startAngle: -Math.PI / 2,\n\n      /**\n       * 结束弧度\n       * @type {Number}\n       */\n      endAngle: Math.PI * 3 / 2,\n      line: {\n        // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n        lineWidth: 1,\n        stroke: '#C0D0E0'\n      },\n      tickLine: {\n        // @type {Attrs} 标注坐标线的图形属性\n        lineWidth: 1,\n        stroke: '#C0D0E0',\n        length: 5\n      },\n\n      /**\n       * 默认文本距离轴线的距离\n       * @type {Number}\n       */\n      _labelOffset: 5\n    });\n  };\n\n  _proto.parseTick = function parseTick(tick, index, length) {\n    return {\n      text: tick,\n      value: index / length\n    };\n  };\n\n  _proto._getCirclePoint = function _getCirclePoint(angle, radius) {\n    var self = this;\n    var center = self.get('center');\n    radius = radius || self.get('radius');\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  _proto.getTickPoint = function getTickPoint(value) {\n    var self = this;\n    var startAngle = self.get('startAngle');\n    var endAngle = self.get('endAngle');\n    var angle = startAngle + (endAngle - startAngle) * value;\n    return self._getCirclePoint(angle);\n  };\n\n  _proto.getSideVector = function getSideVector(offset, point) {\n    var self = this;\n    var center = self.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n\n    if (!Util.isNil(offset)) {\n      var vecLen = vec2.length(vector);\n      vec2.scale(vector, vector, offset / vecLen);\n    }\n\n    return vector;\n  };\n\n  _proto.getSidePoint = function getSidePoint(point, offset) {\n    var self = this;\n    var vector = self.getSideVector(offset, point);\n    return {\n      x: point.x + vector[0],\n      y: point.y + vector[1]\n    };\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, length) {\n    var self = this;\n    var tickLine = self.get('tickLine');\n    length = length ? length : tickLine.length;\n    return self.getSidePoint(start, length);\n  };\n\n  _proto.getTextAnchor = function getTextAnchor(vector) {\n    var align;\n\n    if (Util.snapEqual(vector[0], 0)) {\n      align = 'center';\n    } else if (vector[0] > 0) {\n      align = 'left';\n    } else if (vector[0] < 0) {\n      align = 'right';\n    }\n\n    return align;\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var center = self.get('center');\n    var x = center.x;\n    var y = center.y;\n    var rx = self.get('radius');\n    var ry = rx;\n    var startAngle = self.get('startAngle');\n    var endAngle = self.get('endAngle');\n    var inner = self.get('inner');\n    var path = [];\n\n    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n      path = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\n    } else {\n      var startPoint = self._getCirclePoint(startAngle);\n\n      var endPoint = self._getCirclePoint(endAngle);\n\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n\n      if (!inner) {\n        path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];\n      } else {\n        var innerStartVector = self.getSideVector(inner * rx, startPoint);\n        var innerEndVector = self.getSideVector(inner * rx, endPoint);\n        var innerStartPoint = {\n          x: innerStartVector[0] + x,\n          y: innerStartVector[1] + y\n        };\n        var innerEndPoint = {\n          x: innerEndVector[0] + x,\n          y: innerEndVector[1] + y\n        };\n        path = [['M', innerStartPoint.x, innerStartPoint.y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', innerEndPoint.x, innerEndPoint.y], ['A', rx * inner, ry * inner, 0, large, Math.abs(sweep - 1), innerStartPoint.x, innerStartPoint.y]];\n      }\n    }\n\n    return path;\n  };\n\n  _proto.addLabel = function addLabel(tick, point, index) {\n    var self = this;\n    var offset = self.get('label').offset || self.get('_labelOffset') || 0.001;\n    point = self.getSidePoint(point, offset);\n\n    _Base.prototype.addLabel.call(this, tick, point, index);\n  };\n\n  _proto.autoRotateLabels = function autoRotateLabels() {\n    var self = this;\n    var ticks = self.get('ticks');\n    var labelRenderer = self.get('labelRenderer');\n\n    if (labelRenderer && ticks.length > 12) {\n      // 小于12个文本时文本不旋转\n      var radius = self.get('radius');\n      var startAngle = self.get('startAngle');\n      var endAngle = self.get('endAngle');\n      var totalAngle = endAngle - startAngle;\n      var avgAngle = totalAngle / (ticks.length - 1);\n      var avgWidth = Math.sin(avgAngle / 2) * radius * 2;\n      var maxLength = self.getMaxLabelWidth(labelRenderer);\n      Util.each(labelRenderer.get('group').get('children'), function (label, index) {\n        var tick = ticks[index];\n        var angle = tick.value * totalAngle + startAngle;\n        var mode = angle % (Math.PI * 2);\n\n        if (maxLength < avgWidth) {\n          // 文本的最大宽度大于\n          if (mode <= 0) {\n            angle = angle + Math.PI;\n          }\n\n          if (mode > Math.PI) {\n            angle = angle - Math.PI;\n          }\n\n          angle = angle - Math.PI / 2;\n          label.attr('textAlign', 'center');\n        } else {\n          if (mode > Math.PI / 2) {\n            angle = angle - Math.PI;\n          } else if (mode < Math.PI / 2 * -1) {\n            angle = angle + Math.PI;\n          }\n        }\n\n        label.rotateAtStart(angle);\n      });\n    }\n  };\n\n  return Circle;\n}(Base);\n\nmodule.exports = Circle;"]}]}