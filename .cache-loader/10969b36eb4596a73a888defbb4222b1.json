{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\trend\\path.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\trend\\path.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { __spreadArrays } from \"tslib\";\r\nimport { catmullRom2Bezier } from '@antv/path-util';\r\nimport { Category, Linear } from '@antv/scale';\r\nimport { each, head, isEqual, map } from '@antv/util';\r\nfunction pointsToPath(points) {\r\n    return map(points, function (p, idx) {\r\n        var command = idx === 0 ? 'M' : 'L';\r\n        var x = p[0], y = p[1];\r\n        return [command, x, y];\r\n    });\r\n}\r\nexport function getLinePath(points) {\r\n    return pointsToPath(points);\r\n}\r\nexport function getSmoothLinePath(points) {\r\n    if (points.length <= 2) {\r\n        return getLinePath(points);\r\n    }\r\n    var data = [];\r\n    each(points, function (p) {\r\n        if (!isEqual(p, data.slice(data.length - 2))) {\r\n            data.push(p[0], p[1]);\r\n        }\r\n    });\r\n    var path = catmullRom2Bezier(data, false);\r\n    var _a = head(points), x = _a[0], y = _a[1];\r\n    path.unshift(['M', x, y]);\r\n    return path;\r\n}\r\nexport function dataToPath(data, width, height, smooth) {\r\n    if (smooth === void 0) {\r\n        smooth = true;\r\n    }\r\n    var y = new Linear({\r\n        values: data,\r\n    });\r\n    var x = new Category({\r\n        values: map(data, function (v, idx) { return idx; }),\r\n    });\r\n    var points = map(data, function (v, idx) {\r\n        return [x.scale(idx) * width, height - y.scale(v) * height];\r\n    });\r\n    return smooth ? getSmoothLinePath(points) : getLinePath(points);\r\n}\r\nexport function linePathToAreaPath(path, width, height) {\r\n    var areaPath = __spreadArrays(path);\r\n    areaPath.push(['L', width, 0]);\r\n    areaPath.push(['L', 0, height]);\r\n    areaPath.push(['Z']);\r\n    return areaPath;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\trend\\path.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\component\\esm\\trend\\path.js"],"names":[],"mappings":"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","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport { catmullRom2Bezier } from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { each, head, isEqual, map } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\nfunction pointsToPath(points) {\n    return map(points, function (p, idx) {\n        var command = idx === 0 ? 'M' : 'L';\n        var x = p[0], y = p[1];\n        return [command, x, y];\n    });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\nexport function getLinePath(points) {\n    return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\nexport function getSmoothLinePath(points) {\n    if (points.length <= 2) {\n        // 两点以内直接绘制成路径\n        return getLinePath(points);\n    }\n    var data = [];\n    each(points, function (p) {\n        // 当前点和上一个点一样的时候，忽略掉\n        if (!isEqual(p, data.slice(data.length - 2))) {\n            data.push(p[0], p[1]);\n        }\n    });\n    // const constraint = [ // 范围\n    //   [ 0, 0 ],\n    //   [ 1, 1 ],\n    // ];\n    var path = catmullRom2Bezier(data, false);\n    var _a = head(points), x = _a[0], y = _a[1];\n    path.unshift(['M', x, y]);\n    return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\nexport function dataToPath(data, width, height, smooth) {\n    if (smooth === void 0) { smooth = true; }\n    // 利用 scale 来获取 y 上的映射\n    var y = new Linear({\n        values: data,\n    });\n    var x = new Category({\n        values: map(data, function (v, idx) { return idx; }),\n    });\n    var points = map(data, function (v, idx) {\n        return [x.scale(idx) * width, height - y.scale(v) * height];\n    });\n    return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\nexport function linePathToAreaPath(path, width, height) {\n    var areaPath = __spreadArrays(path);\n    areaPath.push(['L', width, 0]);\n    areaPath.push(['L', 0, height]);\n    areaPath.push(['Z']);\n    return areaPath;\n}\n//# sourceMappingURL=path.js.map"]}]}