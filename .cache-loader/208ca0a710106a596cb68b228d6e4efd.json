{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["function WrappedTree(w, h, y, c) {\n    if (c === void 0) {\n        c = [];\n    }\n    var me = this;\n    me.w = w || 0;\n    me.h = h || 0;\n    me.y = y || 0;\n    me.x = 0;\n    me.c = c || [];\n    me.cs = c.length;\n    me.prelim = 0;\n    me.mod = 0;\n    me.shift = 0;\n    me.change = 0;\n    me.tl = null;\n    me.tr = null;\n    me.el = null;\n    me.er = null;\n    me.msel = 0;\n    me.mser = 0;\n}\nWrappedTree.fromNode = function (root, isHorizontal) {\n    if (!root)\n        return null;\n    var children = [];\n    root.children.forEach(function (child) {\n        children.push(WrappedTree.fromNode(child, isHorizontal));\n    });\n    if (isHorizontal)\n        return new WrappedTree(root.height, root.width, root.x, children);\n    return new WrappedTree(root.width, root.height, root.y, children);\n};\nfunction moveRight(node, move, isHorizontal) {\n    if (isHorizontal) {\n        node.y += move;\n    }\n    else {\n        node.x += move;\n    }\n    node.children.forEach(function (child) {\n        moveRight(child, move, isHorizontal);\n    });\n}\nfunction getMin(node, isHorizontal) {\n    var res = isHorizontal ? node.y : node.x;\n    node.children.forEach(function (child) {\n        res = Math.min(getMin(child, isHorizontal), res);\n    });\n    return res;\n}\nfunction normalize(node, isHorizontal) {\n    var min = getMin(node, isHorizontal);\n    moveRight(node, -min, isHorizontal);\n}\nfunction convertBack(converted, root, isHorizontal) {\n    if (isHorizontal) {\n        root.y = converted.x;\n    }\n    else {\n        root.x = converted.x;\n    }\n    converted.c.forEach(function (child, i) {\n        convertBack(child, root.children[i], isHorizontal);\n    });\n}\nfunction layer(node, isHorizontal, d) {\n    if (d === void 0) {\n        d = 0;\n    }\n    if (isHorizontal) {\n        node.x = d;\n        d += node.width;\n    }\n    else {\n        node.y = d;\n        d += node.height;\n    }\n    node.children.forEach(function (child) {\n        layer(child, isHorizontal, d);\n    });\n}\nmodule.exports = function (root, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var isHorizontal = options.isHorizontal;\n    function firstWalk(t) {\n        if (t.cs === 0) {\n            setExtremes(t);\n            return;\n        }\n        firstWalk(t.c[0]);\n        var ih = updateIYL(bottom(t.c[0].el), 0, null);\n        for (var i = 1; i < t.cs; ++i) {\n            firstWalk(t.c[i]);\n            var min = bottom(t.c[i].er);\n            separate(t, i, ih);\n            ih = updateIYL(min, i, ih);\n        }\n        positionRoot(t);\n        setExtremes(t);\n    }\n    function setExtremes(t) {\n        if (t.cs === 0) {\n            t.el = t;\n            t.er = t;\n            t.msel = t.mser = 0;\n        }\n        else {\n            t.el = t.c[0].el;\n            t.msel = t.c[0].msel;\n            t.er = t.c[t.cs - 1].er;\n            t.mser = t.c[t.cs - 1].mser;\n        }\n    }\n    function separate(t, i, ih) {\n        var sr = t.c[i - 1];\n        var mssr = sr.mod;\n        var cl = t.c[i];\n        var mscl = cl.mod;\n        while (sr !== null && cl !== null) {\n            if (bottom(sr) > ih.low)\n                ih = ih.nxt;\n            var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n            if (dist > 0) {\n                mscl += dist;\n                moveSubtree(t, i, ih.index, dist);\n            }\n            var sy = bottom(sr);\n            var cy = bottom(cl);\n            if (sy <= cy) {\n                sr = nextRightContour(sr);\n                if (sr !== null)\n                    mssr += sr.mod;\n            }\n            if (sy >= cy) {\n                cl = nextLeftContour(cl);\n                if (cl !== null)\n                    mscl += cl.mod;\n            }\n        }\n        if (!sr && !!cl) {\n            setLeftThread(t, i, cl, mscl);\n        }\n        else if (!!sr && !cl) {\n            setRightThread(t, i, sr, mssr);\n        }\n    }\n    function moveSubtree(t, i, si, dist) {\n        t.c[i].mod += dist;\n        t.c[i].msel += dist;\n        t.c[i].mser += dist;\n        distributeExtra(t, i, si, dist);\n    }\n    function nextLeftContour(t) {\n        return t.cs === 0 ? t.tl : t.c[0];\n    }\n    function nextRightContour(t) {\n        return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n    }\n    function bottom(t) {\n        return t.y + t.h;\n    }\n    function setLeftThread(t, i, cl, modsumcl) {\n        var li = t.c[0].el;\n        li.tl = cl;\n        var diff = modsumcl - cl.mod - t.c[0].msel;\n        li.mod += diff;\n        li.prelim -= diff;\n        t.c[0].el = t.c[i].el;\n        t.c[0].msel = t.c[i].msel;\n    }\n    function setRightThread(t, i, sr, modsumsr) {\n        var ri = t.c[i].er;\n        ri.tr = sr;\n        var diff = modsumsr - sr.mod - t.c[i].mser;\n        ri.mod += diff;\n        ri.prelim -= diff;\n        t.c[i].er = t.c[i - 1].er;\n        t.c[i].mser = t.c[i - 1].mser;\n    }\n    function positionRoot(t) {\n        t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n    }\n    function secondWalk(t, modsum) {\n        modsum += t.mod;\n        t.x = t.prelim + modsum;\n        addChildSpacing(t);\n        for (var i = 0; i < t.cs; i++) {\n            secondWalk(t.c[i], modsum);\n        }\n    }\n    function distributeExtra(t, i, si, dist) {\n        if (si !== i - 1) {\n            var nr = i - si;\n            t.c[si + 1].shift += dist / nr;\n            t.c[i].shift -= dist / nr;\n            t.c[i].change -= dist - dist / nr;\n        }\n    }\n    function addChildSpacing(t) {\n        var d = 0;\n        var modsumdelta = 0;\n        for (var i = 0; i < t.cs; i++) {\n            d += t.c[i].shift;\n            modsumdelta += d + t.c[i].change;\n            t.c[i].mod += modsumdelta;\n        }\n    }\n    function updateIYL(low, index, ih) {\n        while (ih !== null && low >= ih.low) {\n            ih = ih.nxt;\n        }\n        return {\n            low: low,\n            index: index,\n            nxt: ih\n        };\n    }\n    layer(root, isHorizontal);\n    var wt = WrappedTree.fromNode(root, isHorizontal);\n    firstWalk(wt);\n    secondWalk(wt, 0);\n    convertBack(wt, root, isHorizontal);\n    normalize(root, isHorizontal);\n    return root;\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js"],"names":[],"mappings":"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","sourcesContent":["// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};"]}]}