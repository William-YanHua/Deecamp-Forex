{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/hierarchy/partition.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/hierarchy/partition.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var assign = require('@antv/util/lib/mix');\nvar d3Hierarchy = require('d3-hierarchy');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar _a = require('../../data-set'), HIERARCHY = _a.HIERARCHY, registerTransform = _a.registerTransform;\nvar getField = require('../../util/option-parser').getField;\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    round: false,\n    padding: 0,\n    sort: true,\n    as: ['x', 'y']\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var partitionLayout = d3Hierarchy.partition();\n    partitionLayout\n        .size(options.size)\n        .round(options.round)\n        .padding(options.padding);\n    partitionLayout(root);\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = [node.x0, node.x1, node.x1, node.x0];\n        node[y] = [node.y1, node.y1, node.y0, node.y0];\n        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n            if (as.indexOf(prop) === -1) {\n                delete node[prop];\n            }\n        });\n    });\n}\nregisterTransform('hierarchy.partition', transform);\nregisterTransform('adjacency', transform);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/hierarchy/partition.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/hierarchy/partition.js"],"names":[],"mappings":"AAAA,IAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAC7C,IAAM,WAAW,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AAC5C,IAAM,OAAO,GAAG,OAAO,CAAC,8BAA8B,CAAC,CAAC;AAClD,IAAA,KAGF,OAAO,CAAC,gBAAgB,CAAC,EAF3B,SAAS,eAAA,EACT,iBAAiB,uBACU,CAAC;AAE5B,IAAA,QAAQ,GACN,OAAO,CAAC,0BAA0B,CAAC,SAD7B,CAC8B;AAExC,IAAM,eAAe,GAAG;IACtB,KAAK,EAAE,OAAO;IACd,IAAI,EAAE,CAAE,CAAC,EAAE,CAAC,CAAE;IACd,KAAK,EAAE,KAAK;IAEZ,OAAO,EAAE,CAAC;IACV,IAAI,EAAE,IAAI;IACV,EAAE,EAAE,CAAE,GAAG,EAAE,GAAG,CAAE;CACjB,CAAC;AAEF,SAAS,SAAS,CAAC,QAAQ,EAAE,OAAO;IAClC,IAAI,QAAQ,CAAC,QAAQ,KAAK,SAAS,EAAE;QACnC,MAAM,IAAI,SAAS,CAAC,8DAA8D,CAAC,CAAC;KACrF;IACD,IAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;IAC3B,OAAO,GAAG,MAAM,CAAC,EAAE,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;IAE/C,IAAM,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;IACtB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;QACnC,MAAM,IAAI,SAAS,CAAC,qEAAqE,CAAC,CAAC;KAC5F;IAED,IAAI,KAAK,CAAC;IACV,IAAI;QACF,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;KAC3B;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;IACD,IAAI,KAAK,EAAE;QACT,IAAI,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,KAAK,CAAC,EAAR,CAAQ,CAAC,CAAC;KACzB;IAED,IAAM,eAAe,GAAG,WAAW,CAAC,SAAS,EAAE,CAAC;IAChD,eAAe;SACZ,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;SAClB,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;SACpB,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAC5B,eAAe,CAAC,IAAI,CAAC,CAAC;IAOtB,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAChB,IAAI,CAAC,IAAI,CAAC,UAAA,IAAI;QACZ,IAAI,CAAC,CAAC,CAAC,GAAG,CAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAE,CAAC;QACjD,IAAI,CAAC,CAAC,CAAC,GAAG,CAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAE,CAAC;QACjD,CAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAE,CAAC,OAAO,CAAC,UAAA,IAAI;YACrC,IAAI,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,iBAAiB,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;AACpD,iBAAiB,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst d3Hierarchy = require('d3-hierarchy');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst {\n  HIERARCHY,\n  registerTransform\n} = require('../../data-set');\nconst {\n  getField\n} = require('../../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  field: 'value',\n  size: [ 1, 1 ], // width, height\n  round: false,\n  // ratio: 1.618033988749895, // golden ratio\n  padding: 0,\n  sort: true,\n  as: [ 'x', 'y' ]\n};\n\nfunction transform(dataView, options) {\n  if (dataView.dataType !== HIERARCHY) {\n    throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n  }\n  const root = dataView.root;\n  options = assign({}, DEFAULT_OPTIONS, options);\n\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n  if (field) {\n    root.sum(d => d[field]);\n  }\n\n  const partitionLayout = d3Hierarchy.partition();\n  partitionLayout\n    .size(options.size)\n    .round(options.round)\n    .padding(options.padding);\n  partitionLayout(root);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n  root.each(node => {\n    node[x] = [ node.x0, node.x1, node.x1, node.x0 ];\n    node[y] = [ node.y1, node.y1, node.y0, node.y0 ];\n    [ 'x0', 'x1', 'y0', 'y1' ].forEach(prop => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n}\n\nregisterTransform('hierarchy.partition', transform);\nregisterTransform('adjacency', transform);\n"]}]}