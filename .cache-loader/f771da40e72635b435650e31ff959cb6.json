{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\coord\\esm\\coord\\helix.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\coord\\esm\\coord\\helix.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { ext, vec2 } from '@antv/matrix-util';\r\nimport { isNumberEqual } from '@antv/util';\r\nimport Coordinate from './base';\r\nvar Helix = (function (_super) {\r\n    __extends(Helix, _super);\r\n    function Helix(cfg) {\r\n        var _this = _super.call(this, cfg) || this;\r\n        _this.isHelix = true;\r\n        _this.type = 'helix';\r\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\r\n        _this.startAngle = startAngle;\r\n        _this.endAngle = endAngle;\r\n        _this.innerRadius = innerRadius;\r\n        _this.radius = radius;\r\n        _this.initial();\r\n        return _this;\r\n    }\r\n    Helix.prototype.initial = function () {\r\n        _super.prototype.initial.call(this);\r\n        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;\r\n        var maxRadius = Math.min(this.width, this.height) / 2;\r\n        if (this.radius && this.radius >= 0 && this.radius <= 1) {\r\n            maxRadius = maxRadius * this.radius;\r\n        }\r\n        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);\r\n        this.a = this.d / (Math.PI * 2);\r\n        this.x = {\r\n            start: this.startAngle,\r\n            end: this.endAngle,\r\n        };\r\n        this.y = {\r\n            start: this.innerRadius * maxRadius,\r\n            end: this.innerRadius * maxRadius + this.d * 0.99,\r\n        };\r\n    };\r\n    Helix.prototype.convertPoint = function (point) {\r\n        var _a;\r\n        var x = point.x, y = point.y;\r\n        if (this.isTransposed) {\r\n            _a = [y, x], x = _a[0], y = _a[1];\r\n        }\r\n        var thi = this.convertDim(x, 'x');\r\n        var r = this.a * thi;\r\n        var newY = this.convertDim(y, 'y');\r\n        return {\r\n            x: this.center.x + Math.cos(thi) * (r + newY),\r\n            y: this.center.y + Math.sin(thi) * (r + newY),\r\n        };\r\n    };\r\n    Helix.prototype.invertPoint = function (point) {\r\n        var _a;\r\n        var d = this.d + this.y.start;\r\n        var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\r\n        var thi = ext.angleTo(v, [1, 0], true);\r\n        var rMin = thi * this.a;\r\n        if (vec2.length(v) < rMin) {\r\n            rMin = vec2.length(v);\r\n        }\r\n        var index = Math.floor((vec2.length(v) - rMin) / d);\r\n        thi = 2 * index * Math.PI + thi;\r\n        var r = this.a * thi;\r\n        var newY = vec2.length(v) - r;\r\n        newY = isNumberEqual(newY, 0) ? 0 : newY;\r\n        var x = this.invertDim(thi, 'x');\r\n        var y = this.invertDim(newY, 'y');\r\n        x = isNumberEqual(x, 0) ? 0 : x;\r\n        y = isNumberEqual(y, 0) ? 0 : y;\r\n        if (this.isTransposed) {\r\n            _a = [y, x], x = _a[0], y = _a[1];\r\n        }\r\n        return { x: x, y: y };\r\n    };\r\n    return Helix;\r\n}(Coordinate));\r\nexport default Helix;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\coord\\esm\\coord\\helix.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2plot\\node_modules\\@antv\\coord\\esm\\coord\\helix.js"],"names":[],"mappings":"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","sourcesContent":["import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */ (function (_super) {\n    __extends(Helix, _super);\n    function Helix(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isHelix = true;\n        _this.type = 'helix';\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\n        _this.startAngle = startAngle;\n        _this.endAngle = endAngle;\n        _this.innerRadius = innerRadius;\n        _this.radius = radius;\n        _this.initial();\n        return _this;\n    }\n    Helix.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n        var maxRadius = Math.min(this.width, this.height) / 2;\n        if (this.radius && this.radius >= 0 && this.radius <= 1) {\n            maxRadius = maxRadius * this.radius;\n        }\n        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);\n        this.a = this.d / (Math.PI * 2); // 螺线系数\n        this.x = {\n            start: this.startAngle,\n            end: this.endAngle,\n        };\n        this.y = {\n            start: this.innerRadius * maxRadius,\n            end: this.innerRadius * maxRadius + this.d * 0.99,\n        };\n    };\n    /**\n     * 将百分比数据变成屏幕坐标\n     * @param point 归一化的点坐标\n     * @return      返回对应的屏幕坐标\n     */\n    Helix.prototype.convertPoint = function (point) {\n        var _a;\n        var x = point.x, y = point.y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        var thi = this.convertDim(x, 'x');\n        var r = this.a * thi;\n        var newY = this.convertDim(y, 'y');\n        return {\n            x: this.center.x + Math.cos(thi) * (r + newY),\n            y: this.center.y + Math.sin(thi) * (r + newY),\n        };\n    };\n    /**\n     * 将屏幕坐标点还原成百分比数据\n     * @param point 屏幕坐标\n     * @return      返回对应的归一化后的数据\n     */\n    Helix.prototype.invertPoint = function (point) {\n        var _a;\n        var d = this.d + this.y.start;\n        var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n        var thi = ext.angleTo(v, [1, 0], true);\n        var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n        if (vec2.length(v) < rMin) {\n            // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n            rMin = vec2.length(v);\n        }\n        var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n        thi = 2 * index * Math.PI + thi;\n        var r = this.a * thi;\n        var newY = vec2.length(v) - r;\n        newY = isNumberEqual(newY, 0) ? 0 : newY;\n        var x = this.invertDim(thi, 'x');\n        var y = this.invertDim(newY, 'y');\n        x = isNumberEqual(x, 0) ? 0 : x;\n        y = isNumberEqual(y, 0) ? 0 : y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return { x: x, y: y };\n    };\n    return Helix;\n}(Coordinate));\nexport default Helix;\n//# sourceMappingURL=helix.js.map"]}]}