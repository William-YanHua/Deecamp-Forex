{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/regression.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/regression.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar assign = require('@antv/util/lib/mix');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar isFunction = require('@antv/util/lib/type/is-function');\nvar isNil = require('@antv/util/lib/type/is-nil');\nvar isNumber = require('@antv/util/lib/type/is-number');\nvar isString = require('@antv/util/lib/type/is-string');\nvar keys = require('@antv/util/lib/object/keys');\nvar sum = require('simple-statistics').sum;\nvar getSeriesValues = require('../../util/get-series-values');\nvar kernel = require('../../util/kernel');\nvar registerTransform = require('../../data-set').registerTransform;\nvar getFields = require('../../util/option-parser').getFields;\nvar silverman = require('../../util/bandwidth').silverman;\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    method: 'gaussian'\n};\nvar KERNEL_METHODS = keys(kernel);\nfunction weight(kernel, bandwidth, x_0, x_i) {\n    var arg = (x_i - x_0) / bandwidth;\n    return kernel(arg);\n}\nfunction vectorize(fun) {\n    return function (x) {\n        if (!isArray(x)) {\n            return fun(x);\n        }\n        return x.map(function (x) {\n            return fun(x);\n        });\n    };\n}\nfunction transform(dv, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var fields = getFields(options);\n    if (!isArray(fields) || (fields.length !== 1 && fields.length !== 2)) {\n        throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\n    }\n    var _a = __read(options.as, 2), asX = _a[0], asY = _a[1];\n    if (!isString(asX) || !isString(asY)) {\n        throw new TypeError('invalid as: must be an array of 2 strings!');\n    }\n    var method = options.method;\n    if (isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel[method];\n    }\n    if (!isFunction(method)) {\n        throw new TypeError('invalid method: kernel method must be a function!');\n    }\n    var _b = __read(fields, 2), xField = _b[0], yField = _b[1];\n    var xs = dv.getColumn(xField);\n    var extent = options.extent;\n    if (!isArray(extent)) {\n        extent = dv.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = silverman(xs);\n    }\n    var seriesValues = getSeriesValues(extent, bandwidth);\n    var xCount = xs.length;\n    var weightFunc = weight.bind(null, method, bandwidth);\n    var kernelSmoother;\n    if (isNil(yField)) {\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = sum(weights);\n            var denom = xCount * bandwidth;\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    else {\n        var ys_1 = dv.getColumn(yField);\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = sum(weights.map(function (w, i) { return w * ys_1[i]; }));\n            var denom = sum(weights);\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    var result = seriesValues.map(function (x) {\n        var row = {};\n        row[asX] = x;\n        row[asY] = kernelSmoother(x);\n        return row;\n    });\n    dv.rows = result;\n}\nregisterTransform('kernel-smooth.regression', transform);\nregisterTransform('kernel.regression', transform);\nmodule.exports = {\n    KERNEL_METHODS: KERNEL_METHODS\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/regression.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/regression.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAGA,IAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAC7C,IAAM,OAAO,GAAG,OAAO,CAAC,8BAA8B,CAAC,CAAC;AACxD,IAAM,UAAU,GAAG,OAAO,CAAC,iCAAiC,CAAC,CAAC;AAC9D,IAAM,KAAK,GAAG,OAAO,CAAC,4BAA4B,CAAC,CAAC;AACpD,IAAM,QAAQ,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC1D,IAAM,QAAQ,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC1D,IAAM,IAAI,GAAG,OAAO,CAAC,4BAA4B,CAAC,CAAC;AAGjD,IAAA,GAAG,GACD,OAAO,CAAC,mBAAmB,CAAC,IAD3B,CAC4B;AACjC,IAAM,eAAe,GAAG,OAAO,CAAC,8BAA8B,CAAC,CAAC;AAEhE,IAAM,MAAM,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAE1C,IAAA,iBAAiB,GACf,OAAO,CAAC,gBAAgB,CAAC,kBADV,CACW;AAE5B,IAAA,SAAS,GACP,OAAO,CAAC,0BAA0B,CAAC,UAD5B,CAC6B;AAEtC,IAAA,SAAS,GACP,OAAO,CAAC,sBAAsB,CAAC,UADxB,CACyB;AAEpC,IAAM,eAAe,GAAG;IACtB,EAAE,EAAE,CAAE,GAAG,EAAE,GAAG,CAAE;IAEhB,MAAM,EAAE,UAAU;CAGnB,CAAC;AAEF,IAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;AAGpC,SAAS,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,GAAG,EAAE,GAAG;IACzC,IAAM,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,SAAS,CAAC;IACpC,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;AACrB,CAAC;AAMD,SAAS,SAAS,CAAC,GAAG;IACpB,OAAO,UAAS,CAAC;QACf,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACf,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;SACf;QACD,OAAO,CAAC,CAAC,GAAG,CAAC,UAAS,CAAC;YACrB,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,SAAS,CAAC,EAAE,EAAE,OAAO;IAC5B,OAAO,GAAG,MAAM,CAAC,EAAE,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;IAC/C,IAAM,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;IAClC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE;QACpE,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;KAC5E;IACK,IAAA,KAAA,OAAe,OAAO,CAAC,EAAE,IAAA,EAAvB,GAAG,QAAA,EAAE,GAAG,QAAe,CAAC;IAChC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACpC,MAAM,IAAI,SAAS,CAAC,4CAA4C,CAAC,CAAC;KACnE;IACD,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5B,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;QACpB,IAAI,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;YACzC,MAAM,IAAI,SAAS,CAAC,qBAAmB,MAAM,yBAAoB,cAAc,CAAC,IAAI,CAAC,IAAI,CAAG,CAAC,CAAC;SAC/F;QACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;KACzB;IACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;QACvB,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC,CAAC;KAC1E;IAEK,IAAA,KAAA,OAAqB,MAAM,IAAA,EAAzB,MAAM,QAAA,EAAE,MAAM,QAAW,CAAC;IAClC,IAAM,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAEhC,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACpB,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;KAC3B;IACD,IAAI,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IAClC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,SAAS,IAAI,CAAC,EAAE;QAC1C,SAAS,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC;KAC3B;IACD,IAAM,YAAY,GAAG,eAAe,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACxD,IAAM,MAAM,GAAG,EAAE,CAAC,MAAM,CAAC;IACzB,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;IACxD,IAAI,cAAc,CAAC;IAEnB,IAAI,KAAK,CAAC,MAAM,CAAC,EAAE;QAEjB,cAAc,GAAG,SAAS,CAAC,UAAA,CAAC;YAC1B,IAAM,OAAO,GAAG,EAAE,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,UAAU,CAAC,CAAC,EAAE,GAAG,CAAC,EAAlB,CAAkB,CAAC,CAAC;YAClD,IAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC;YACzB,IAAM,KAAK,GAAG,MAAM,GAAG,SAAS,CAAC;YACjC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK;gBAAE,OAAO,CAAC,CAAC;YAC7B,OAAO,GAAG,GAAG,KAAK,CAAC;QACrB,CAAC,CAAC,CAAC;KACJ;SAAM;QAEL,IAAM,IAAE,GAAG,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QAChC,cAAc,GAAG,SAAS,CAAC,UAAA,CAAC;YAC1B,IAAM,OAAO,GAAG,EAAE,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,UAAU,CAAC,CAAC,EAAE,GAAG,CAAC,EAAlB,CAAkB,CAAC,CAAC;YAClD,IAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,IAAE,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC,CAAC;YAClD,IAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC;YAC3B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK;gBAAE,OAAO,CAAC,CAAC;YAC7B,OAAO,GAAG,GAAG,KAAK,CAAC;QACrB,CAAC,CAAC,CAAC;KACJ;IAED,IAAM,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,UAAA,CAAC;QAC/B,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACb,GAAG,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;QAC7B,OAAO,GAAG,CAAC;IACb,CAAC,CAAC,CAAC;IACH,EAAE,CAAC,IAAI,GAAG,MAAM,CAAC;AACnB,CAAC;AAED,iBAAiB,CAAC,0BAA0B,EAAE,SAAS,CAAC,CAAC;AACzD,iBAAiB,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC;AAElD,MAAM,CAAC,OAAO,GAAG;IACf,cAAc,gBAAA;CACf,CAAC","sourcesContent":["/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nconst assign = require('@antv/util/lib/mix');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNil = require('@antv/util/lib/type/is-nil');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\n// const regression = require('regression');\nconst {\n  sum\n} = require('simple-statistics');\nconst getSeriesValues = require('../../util/get-series-values');\n// const enclideanDistance = require('../../util/euclidean-distance');\nconst kernel = require('../../util/kernel');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\nconst {\n  silverman\n} = require('../../util/bandwidth');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y' ],\n  // fields: [ 'x', 'y' ], // required, one or two fields\n  method: 'gaussian' // kernel method: should be one of keys(kernel)\n  // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]\n  // bandwidth: 0.5 // bandWidth to execute kernel function\n};\n\nconst KERNEL_METHODS = keys(kernel);\n\n// calculates weight for i-th obs\nfunction weight(kernel, bandwidth, x_0, x_i) {\n  const arg = (x_i - x_0) / bandwidth;\n  return kernel(arg);\n}\n// calculates weight for i-th obs when p > 1\n// function weight_vectors(kernel, bandwidth, x_0, x_i) {\n//   const arg = enclideanDistance(x_i, x_0) / bandwidth;\n//   return kernel(arg);\n// }\nfunction vectorize(fun) {\n  return function(x) {\n    if (!isArray(x)) {\n      return fun(x);\n    }\n    return x.map(function(x) {\n      return fun(x);\n    });\n  };\n}\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || (fields.length !== 1 && fields.length !== 2)) {\n    throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\n  }\n  const [ asX, asY ] = options.as;\n  if (!isString(asX) || !isString(asY)) {\n    throw new TypeError('invalid as: must be an array of 2 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  const [ xField, yField ] = fields;\n  const xs = dv.getColumn(xField);\n\n  let extent = options.extent;\n  if (!isArray(extent)) {\n    extent = dv.range(xField);\n  }\n  let bandwidth = options.bandwidth;\n  if (!isNumber(bandwidth) || bandwidth <= 0) {\n    bandwidth = silverman(xs);\n  }\n  const seriesValues = getSeriesValues(extent, bandwidth);\n  const xCount = xs.length;\n  const weightFunc = weight.bind(null, method, bandwidth);\n  let kernelSmoother;\n\n  if (isNil(yField)) {\n    // KDE\n    kernelSmoother = vectorize(x => {\n      const weights = xs.map(x_i => weightFunc(x, x_i));\n      const num = sum(weights);\n      const denom = xCount * bandwidth;\n      if (!num || !denom) return 0;\n      return num / denom;\n    });\n  } else {\n    // kernel regression smoothing\n    const ys = dv.getColumn(yField);\n    kernelSmoother = vectorize(x => {\n      const weights = xs.map(x_i => weightFunc(x, x_i));\n      const num = sum(weights.map((w, i) => w * ys[i]));\n      const denom = sum(weights);\n      if (!num || !denom) return 0;\n      return num / denom;\n    });\n  }\n\n  const result = seriesValues.map(x => {\n    const row = {};\n    row[asX] = x;\n    row[asY] = kernelSmoother(x);\n    return row;\n  });\n  dv.rows = result;\n}\n\nregisterTransform('kernel-smooth.regression', transform);\nregisterTransform('kernel.regression', transform);\n\nmodule.exports = {\n  KERNEL_METHODS\n};\n"]}]}