{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/base.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/base.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __assign } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\nfunction avg(arr) {\n    var sum = 0;\n    each(arr, function (value) {\n        sum += value;\n    });\n    return sum / arr.length;\n}\nvar GeometryLabel = (function () {\n    function GeometryLabel(geometry) {\n        this.geometry = geometry;\n    }\n    GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n        var _this = this;\n        var items = [];\n        var labelCfgs = this.getLabelCfgs(mapppingArray);\n        each(mapppingArray, function (mappingData, index) {\n            var labelCfg = labelCfgs[index];\n            if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n                items.push(null);\n                return;\n            }\n            var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n            labelCfg.content = labelContent;\n            var total = labelContent.length;\n            each(labelContent, function (content, subIndex) {\n                if (isNil(content) || content === '') {\n                    items.push(null);\n                    return;\n                }\n                var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n                if (!item.textAlign) {\n                    item.textAlign = _this.getLabelAlign(item, subIndex, total);\n                }\n                if (item.offset <= 0) {\n                    item.labelLine = null;\n                }\n                items.push(item);\n            });\n        });\n        return items;\n    };\n    GeometryLabel.prototype.render = function (mapppingArray, isUpdate) {\n        if (isUpdate === void 0) {\n            isUpdate = false;\n        }\n        var labelItems = this.getLabelItems(mapppingArray);\n        var labelsRenderer = this.getLabelsRenderer();\n        var shapes = this.getGeometryShapes();\n        labelsRenderer.render(labelItems, shapes, isUpdate);\n    };\n    GeometryLabel.prototype.clear = function () {\n        var labelsRenderer = this.labelsRenderer;\n        if (labelsRenderer) {\n            labelsRenderer.clear();\n        }\n    };\n    GeometryLabel.prototype.destroy = function () {\n        var labelsRenderer = this.labelsRenderer;\n        if (labelsRenderer) {\n            labelsRenderer.destroy();\n        }\n        this.labelsRenderer = null;\n    };\n    GeometryLabel.prototype.getCoordinate = function () {\n        return this.geometry.coordinate;\n    };\n    GeometryLabel.prototype.getDefaultLabelCfg = function () {\n        return get(this.geometry.theme, 'labels', {});\n    };\n    GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) { };\n    GeometryLabel.prototype.getDefaultOffset = function (offset) {\n        var coordinate = this.getCoordinate();\n        var vector = this.getOffsetVector(offset);\n        return coordinate.isTransposed ? vector[0] : vector[1];\n    };\n    GeometryLabel.prototype.getLabelOffset = function (labelCfg, index, total) {\n        var offset = this.getDefaultOffset(labelCfg.offset);\n        var coordinate = this.getCoordinate();\n        var transposed = coordinate.isTransposed;\n        var dim = transposed ? 'x' : 'y';\n        var factor = transposed ? 1 : -1;\n        var offsetPoint = {\n            x: 0,\n            y: 0,\n        };\n        if (index > 0 || total === 1) {\n            offsetPoint[dim] = offset * factor;\n        }\n        else {\n            offsetPoint[dim] = offset * factor * -1;\n        }\n        return offsetPoint;\n    };\n    GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n        var coordinate = this.getCoordinate();\n        var total = labelCfg.content.length;\n        function getDimValue(value, idx) {\n            var v = value;\n            if (isArray(v)) {\n                if (labelCfg.content.length === 1) {\n                    if (v.length <= 2) {\n                        v = v[value.length - 1];\n                    }\n                    else {\n                        v = avg(v);\n                    }\n                }\n                else {\n                    v = v[idx];\n                }\n            }\n            return v;\n        }\n        var label = {\n            content: labelCfg.content[index],\n            x: 0,\n            y: 0,\n            start: { x: 0, y: 0 },\n            color: '#fff',\n        };\n        if (mappingData && this.geometry.type === 'polygon') {\n            var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n            label.x = centroid[0];\n            label.y = centroid[1];\n        }\n        else {\n            label.x = getDimValue(mappingData.x, index);\n            label.y = getDimValue(mappingData.y, index);\n        }\n        var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n        if (shape === 'funnel' || shape === 'pyramid') {\n            var nextPoints = get(mappingData, 'nextPoints');\n            var points = get(mappingData, 'points');\n            if (nextPoints) {\n                var point1 = coordinate.convert(points[1]);\n                var point2 = coordinate.convert(nextPoints[1]);\n                label.x = (point1.x + point2.x) / 2;\n                label.y = (point1.y + point2.y) / 2;\n            }\n            else if (shape === 'pyramid') {\n                var point1 = coordinate.convert(points[1]);\n                var point2 = coordinate.convert(points[2]);\n                label.x = (point1.x + point2.x) / 2;\n                label.y = (point1.y + point2.y) / 2;\n            }\n        }\n        if (labelCfg.position) {\n            this.setLabelPosition(label, mappingData, index, labelCfg.position);\n        }\n        var offsetPoint = this.getLabelOffset(labelCfg, index, total);\n        label.start = { x: label.x, y: label.y };\n        label.x += offsetPoint.x;\n        label.y += offsetPoint.y;\n        label.color = mappingData.color;\n        return label;\n    };\n    GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n        var align = 'center';\n        var coordinate = this.getCoordinate();\n        if (coordinate.isTransposed) {\n            var offset = this.getDefaultOffset(item.offset);\n            if (offset < 0) {\n                align = 'right';\n            }\n            else if (offset === 0) {\n                align = 'center';\n            }\n            else {\n                align = 'left';\n            }\n            if (total > 1 && index === 0) {\n                if (align === 'right') {\n                    align = 'left';\n                }\n                else if (align === 'left') {\n                    align = 'right';\n                }\n            }\n        }\n        return align;\n    };\n    GeometryLabel.prototype.getLabelId = function (mappingData) {\n        var geometry = this.geometry;\n        var type = geometry.type;\n        var xScale = geometry.getXScale();\n        var yScale = geometry.getYScale();\n        var origin = mappingData[FIELD_ORIGIN];\n        var labelId = geometry.getElementId(mappingData);\n        if (type === 'line' || type === 'area') {\n            labelId += \" \" + origin[xScale.field];\n        }\n        else if (type === 'path') {\n            labelId += \" \" + origin[xScale.field] + \"-\" + origin[yScale.field];\n        }\n        return labelId;\n    };\n    GeometryLabel.prototype.getLabelsRenderer = function () {\n        var _a = this.geometry, labelsContainer = _a.labelsContainer, labelOption = _a.labelOption, canvasRegion = _a.canvasRegion, animateOption = _a.animateOption;\n        var coordinate = this.geometry.coordinate;\n        var labelsRenderer = this.labelsRenderer;\n        if (!labelsRenderer) {\n            labelsRenderer = new Labels({\n                container: labelsContainer,\n                layout: get(labelOption, ['cfg', 'layout'], {\n                    type: this.defaultLayout,\n                }),\n            });\n            this.labelsRenderer = labelsRenderer;\n        }\n        labelsRenderer.region = canvasRegion;\n        labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n        return labelsRenderer;\n    };\n    GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n        var _this = this;\n        var geometry = this.geometry;\n        var defaultLabelCfg = this.getDefaultLabelCfg();\n        var type = geometry.type, theme = geometry.theme, labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;\n        var _a = labelOption, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;\n        var labelScales = fields.map(function (field) {\n            return scales[field];\n        });\n        var labelCfgs = [];\n        each(mapppingArray, function (mappingData, index) {\n            var origin = mappingData[FIELD_ORIGIN];\n            var originText = _this.getLabelText(origin, labelScales);\n            var callbackCfg;\n            if (callback) {\n                var originValues = fields.map(function (field) { return origin[field]; });\n                callbackCfg = callback.apply(void 0, originValues);\n                if (isNil(callbackCfg)) {\n                    labelCfgs.push(null);\n                    return;\n                }\n            }\n            var labelCfg = __assign(__assign({ id: _this.getLabelId(mappingData), data: origin,\n                mappingData: mappingData,\n                coordinate: coordinate }, cfg), callbackCfg);\n            var content = labelCfg.content;\n            if (isFunction(content)) {\n                labelCfg.content = content(origin, mappingData, index);\n            }\n            else if (isUndefined(content)) {\n                labelCfg.content = originText[0];\n            }\n            if (isFunction(labelCfg.position)) {\n                labelCfg.position = labelCfg.position(origin, mappingData, index);\n            }\n            if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n                labelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n            }\n            else {\n                labelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n            }\n            labelCfgs.push(labelCfg);\n        });\n        return labelCfgs;\n    };\n    GeometryLabel.prototype.getLabelText = function (origin, scales) {\n        var labelTexts = [];\n        each(scales, function (scale) {\n            var value = origin[scale.field];\n            if (isArray(value)) {\n                value = value.map(function (subVal) {\n                    return scale.getText(subVal);\n                });\n            }\n            else {\n                value = scale.getText(value);\n            }\n            if (isNil(value) || value === '') {\n                labelTexts.push(null);\n            }\n            else {\n                labelTexts.push(value);\n            }\n        });\n        return labelTexts;\n    };\n    GeometryLabel.prototype.getOffsetVector = function (offset) {\n        if (offset === void 0) {\n            offset = 0;\n        }\n        var coordinate = this.getCoordinate();\n        return coordinate.isTransposed ? coordinate.applyMatrix(offset, 0) : coordinate.applyMatrix(0, offset);\n    };\n    GeometryLabel.prototype.getGeometryShapes = function () {\n        var geometry = this.geometry;\n        var shapes = {};\n        each(geometry.elementsMap, function (element, id) {\n            shapes[id] = element.shape;\n        });\n        each(geometry.getOffscreenGroup().getChildren(), function (child) {\n            var id = geometry.getElementId(child.get('origin').mappingData);\n            shapes[id] = child;\n        });\n        return shapes;\n    };\n    return GeometryLabel;\n}());\nexport default GeometryLabel;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/base.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/base.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\nfunction avg(arr) {\n    var sum = 0;\n    each(arr, function (value) {\n        sum += value;\n    });\n    return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nvar GeometryLabel = /** @class */ (function () {\n    function GeometryLabel(geometry) {\n        this.geometry = geometry;\n    }\n    GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n        var _this = this;\n        var items = [];\n        var labelCfgs = this.getLabelCfgs(mapppingArray);\n        // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n        each(mapppingArray, function (mappingData, index) {\n            var labelCfg = labelCfgs[index];\n            if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n                items.push(null);\n                return;\n            }\n            var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n            labelCfg.content = labelContent;\n            var total = labelContent.length;\n            each(labelContent, function (content, subIndex) {\n                if (isNil(content) || content === '') {\n                    items.push(null);\n                    return;\n                }\n                var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n                if (!item.textAlign) {\n                    item.textAlign = _this.getLabelAlign(item, subIndex, total);\n                }\n                if (item.offset <= 0) {\n                    item.labelLine = null;\n                }\n                items.push(item);\n            });\n        });\n        return items;\n    };\n    GeometryLabel.prototype.render = function (mapppingArray, isUpdate) {\n        if (isUpdate === void 0) { isUpdate = false; }\n        var labelItems = this.getLabelItems(mapppingArray);\n        var labelsRenderer = this.getLabelsRenderer();\n        var shapes = this.getGeometryShapes();\n        // 渲染文本\n        labelsRenderer.render(labelItems, shapes, isUpdate);\n    };\n    GeometryLabel.prototype.clear = function () {\n        var labelsRenderer = this.labelsRenderer;\n        if (labelsRenderer) {\n            labelsRenderer.clear();\n        }\n    };\n    GeometryLabel.prototype.destroy = function () {\n        var labelsRenderer = this.labelsRenderer;\n        if (labelsRenderer) {\n            labelsRenderer.destroy();\n        }\n        this.labelsRenderer = null;\n    };\n    // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n    GeometryLabel.prototype.getCoordinate = function () {\n        return this.geometry.coordinate;\n    };\n    /**\n     * 获取 label 的默认配置\n     */\n    GeometryLabel.prototype.getDefaultLabelCfg = function () {\n        return get(this.geometry.theme, 'labels', {});\n    };\n    /**\n     * 设置 label 位置\n     * @param labelPointCfg\n     * @param mappingData\n     * @param index\n     * @param position\n     */\n    GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) { };\n    /**\n     * 获取文本默认偏移量\n     * @param offset\n     * @returns\n     */\n    GeometryLabel.prototype.getDefaultOffset = function (offset) {\n        var coordinate = this.getCoordinate();\n        var vector = this.getOffsetVector(offset);\n        return coordinate.isTransposed ? vector[0] : vector[1];\n    };\n    /**\n     * 获取每个 label 的偏移量\n     * @param labelCfg\n     * @param index\n     * @param total\n     * @returns\n     */\n    GeometryLabel.prototype.getLabelOffset = function (labelCfg, index, total) {\n        var offset = this.getDefaultOffset(labelCfg.offset);\n        var coordinate = this.getCoordinate();\n        var transposed = coordinate.isTransposed;\n        var dim = transposed ? 'x' : 'y';\n        var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n        var offsetPoint = {\n            x: 0,\n            y: 0,\n        };\n        if (index > 0 || total === 1) {\n            // 判断是否小于0\n            offsetPoint[dim] = offset * factor;\n        }\n        else {\n            offsetPoint[dim] = offset * factor * -1;\n        }\n        return offsetPoint;\n    };\n    /**\n     * 获取每个 label 的位置\n     * @param labelCfg\n     * @param mappingData\n     * @param index\n     * @returns label point\n     */\n    GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n        var coordinate = this.getCoordinate();\n        var total = labelCfg.content.length;\n        function getDimValue(value, idx) {\n            var v = value;\n            if (isArray(v)) {\n                if (labelCfg.content.length === 1) {\n                    // 如果仅一个 label，多个 y, 取最后一个 y\n                    if (v.length <= 2) {\n                        v = v[value.length - 1];\n                    }\n                    else {\n                        v = avg(v);\n                    }\n                }\n                else {\n                    v = v[idx];\n                }\n            }\n            return v;\n        }\n        var label = {\n            content: labelCfg.content[index],\n            x: 0,\n            y: 0,\n            start: { x: 0, y: 0 },\n            color: '#fff',\n        };\n        // 多边形场景，多用于地图\n        if (mappingData && this.geometry.type === 'polygon') {\n            var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n            label.x = centroid[0];\n            label.y = centroid[1];\n        }\n        else {\n            label.x = getDimValue(mappingData.x, index);\n            label.y = getDimValue(mappingData.y, index);\n        }\n        // 处理漏斗图文本位置\n        var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n        if (shape === 'funnel' || shape === 'pyramid') {\n            var nextPoints = get(mappingData, 'nextPoints');\n            var points = get(mappingData, 'points');\n            if (nextPoints) {\n                // 非漏斗图底部\n                var point1 = coordinate.convert(points[1]);\n                var point2 = coordinate.convert(nextPoints[1]);\n                label.x = (point1.x + point2.x) / 2;\n                label.y = (point1.y + point2.y) / 2;\n            }\n            else if (shape === 'pyramid') {\n                var point1 = coordinate.convert(points[1]);\n                var point2 = coordinate.convert(points[2]);\n                label.x = (point1.x + point2.x) / 2;\n                label.y = (point1.y + point2.y) / 2;\n            }\n        }\n        if (labelCfg.position) {\n            // 如果 label 支持 position 属性\n            this.setLabelPosition(label, mappingData, index, labelCfg.position);\n        }\n        var offsetPoint = this.getLabelOffset(labelCfg, index, total);\n        label.start = { x: label.x, y: label.y };\n        label.x += offsetPoint.x;\n        label.y += offsetPoint.y;\n        label.color = mappingData.color;\n        return label;\n    };\n    /**\n     * 获取文本的对齐方式\n     * @param item\n     * @param index\n     * @param total\n     * @returns\n     */\n    GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n        var align = 'center';\n        var coordinate = this.getCoordinate();\n        if (coordinate.isTransposed) {\n            var offset = this.getDefaultOffset(item.offset);\n            if (offset < 0) {\n                align = 'right';\n            }\n            else if (offset === 0) {\n                align = 'center';\n            }\n            else {\n                align = 'left';\n            }\n            if (total > 1 && index === 0) {\n                if (align === 'right') {\n                    align = 'left';\n                }\n                else if (align === 'left') {\n                    align = 'right';\n                }\n            }\n        }\n        return align;\n    };\n    /**\n     * 获取每一个 label 的唯一 id\n     * @param mappingData label 对应的图形的绘制数据\n     */\n    GeometryLabel.prototype.getLabelId = function (mappingData) {\n        var geometry = this.geometry;\n        var type = geometry.type;\n        var xScale = geometry.getXScale();\n        var yScale = geometry.getYScale();\n        var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n        var labelId = geometry.getElementId(mappingData);\n        if (type === 'line' || type === 'area') {\n            // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n            labelId += \" \" + origin[xScale.field];\n        }\n        else if (type === 'path') {\n            // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n            labelId += \" \" + origin[xScale.field] + \"-\" + origin[yScale.field];\n        }\n        return labelId;\n    };\n    // 获取 labels 组件\n    GeometryLabel.prototype.getLabelsRenderer = function () {\n        var _a = this.geometry, labelsContainer = _a.labelsContainer, labelOption = _a.labelOption, canvasRegion = _a.canvasRegion, animateOption = _a.animateOption;\n        var coordinate = this.geometry.coordinate;\n        var labelsRenderer = this.labelsRenderer;\n        if (!labelsRenderer) {\n            labelsRenderer = new Labels({\n                container: labelsContainer,\n                layout: get(labelOption, ['cfg', 'layout'], {\n                    type: this.defaultLayout,\n                }),\n            });\n            this.labelsRenderer = labelsRenderer;\n        }\n        labelsRenderer.region = canvasRegion;\n        // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n        labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n        return labelsRenderer;\n    };\n    GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n        var _this = this;\n        var geometry = this.geometry;\n        var defaultLabelCfg = this.getDefaultLabelCfg();\n        var type = geometry.type, theme = geometry.theme, labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;\n        var _a = labelOption, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;\n        var labelScales = fields.map(function (field) {\n            return scales[field];\n        });\n        var labelCfgs = [];\n        each(mapppingArray, function (mappingData, index) {\n            var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n            var originText = _this.getLabelText(origin, labelScales);\n            var callbackCfg;\n            if (callback) {\n                // 当同时配置了 callback 和 cfg 时，以 callback 为准\n                var originValues = fields.map(function (field) { return origin[field]; });\n                callbackCfg = callback.apply(void 0, originValues);\n                if (isNil(callbackCfg)) {\n                    labelCfgs.push(null);\n                    return;\n                }\n            }\n            var labelCfg = __assign(__assign({ id: _this.getLabelId(mappingData), data: origin, // 存储原始数据\n                mappingData: mappingData,\n                coordinate: coordinate }, cfg), callbackCfg);\n            var content = labelCfg.content;\n            if (isFunction(content)) {\n                labelCfg.content = content(origin, mappingData, index);\n            }\n            else if (isUndefined(content)) {\n                // 用户未配置 content，则默认为映射的第一个字段的值\n                labelCfg.content = originText[0];\n            }\n            if (isFunction(labelCfg.position)) {\n                labelCfg.position = labelCfg.position(origin, mappingData, index);\n            }\n            if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n                // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n                labelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n            }\n            else {\n                labelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n            }\n            labelCfgs.push(labelCfg);\n        });\n        return labelCfgs;\n    };\n    GeometryLabel.prototype.getLabelText = function (origin, scales) {\n        var labelTexts = [];\n        each(scales, function (scale) {\n            var value = origin[scale.field];\n            if (isArray(value)) {\n                value = value.map(function (subVal) {\n                    return scale.getText(subVal);\n                });\n            }\n            else {\n                value = scale.getText(value);\n            }\n            if (isNil(value) || value === '') {\n                labelTexts.push(null);\n            }\n            else {\n                labelTexts.push(value);\n            }\n        });\n        return labelTexts;\n    };\n    GeometryLabel.prototype.getOffsetVector = function (offset) {\n        if (offset === void 0) { offset = 0; }\n        var coordinate = this.getCoordinate();\n        // 如果 x,y 翻转，则偏移 x，否则偏移 y\n        return coordinate.isTransposed ? coordinate.applyMatrix(offset, 0) : coordinate.applyMatrix(0, offset);\n    };\n    GeometryLabel.prototype.getGeometryShapes = function () {\n        var geometry = this.geometry;\n        var shapes = {};\n        each(geometry.elementsMap, function (element, id) {\n            shapes[id] = element.shape;\n        });\n        // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n        each(geometry.getOffscreenGroup().getChildren(), function (child) {\n            var id = geometry.getElementId(child.get('origin').mappingData);\n            shapes[id] = child;\n        });\n        return shapes;\n    };\n    return GeometryLabel;\n}());\nexport default GeometryLabel;\n//# sourceMappingURL=base.js.map"]}]}