{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\gilbert.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\gilbert.js","mtime":1467599198000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { geoEquirectangular, geoOrthographic } from \"d3-geo\";\r\nimport { asin, atan, degrees, radians, sin, tan } from \"./math\";\r\nfunction gilbertForward(point) {\r\n    return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\r\n}\r\nfunction gilbertInvert(point) {\r\n    return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\r\n}\r\nexport default function (projectionType) {\r\n    if (projectionType == null)\r\n        projectionType = geoOrthographic;\r\n    var projection = projectionType(), equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]);\r\n    function gilbert(point) {\r\n        return projection(gilbertForward(point));\r\n    }\r\n    if (projection.invert)\r\n        gilbert.invert = function (point) {\r\n            return gilbertInvert(projection.invert(point));\r\n        };\r\n    gilbert.stream = function (stream) {\r\n        var s1 = projection.stream(stream), s0 = equirectangular.stream({\r\n            point: function (lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\r\n            lineStart: function () { s1.lineStart(); },\r\n            lineEnd: function () { s1.lineEnd(); },\r\n            polygonStart: function () { s1.polygonStart(); },\r\n            polygonEnd: function () { s1.polygonEnd(); }\r\n        });\r\n        s0.sphere = s1.sphere;\r\n        return s0;\r\n    };\r\n    function property(name) {\r\n        gilbert[name] = function (_) {\r\n            return arguments.length ? (projection[name](_), gilbert) : projection[name]();\r\n        };\r\n    }\r\n    gilbert.rotate = function (_) {\r\n        return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\r\n    };\r\n    gilbert.center = function (_) {\r\n        return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\r\n    };\r\n    property(\"clipAngle\");\r\n    property(\"clipExtent\");\r\n    property(\"scale\");\r\n    property(\"translate\");\r\n    property(\"precision\");\r\n    return gilbert\r\n        .scale(249.5);\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\gilbert.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\gilbert.js"],"names":[],"mappings":"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","sourcesContent":["import {geoEquirectangular, geoOrthographic} from \"d3-geo\";\nimport {asin, atan, degrees, radians, sin, tan} from \"./math\";\n\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\n\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\n\nexport default function(projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n      equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n\n  if (projection.invert) gilbert.invert = function(point) {\n    return gilbertInvert(projection.invert(point));\n  };\n\n  gilbert.stream = function(stream) {\n    var s1 = projection.stream(stream), s0 = equirectangular.stream({\n      point: function(lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n      lineStart: function() { s1.lineStart(); },\n      lineEnd: function() { s1.lineEnd(); },\n      polygonStart: function() { s1.polygonStart(); },\n      polygonEnd: function() { s1.polygonEnd(); }\n    });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n\n  function property(name) {\n    gilbert[name] = function(_) {\n      return arguments.length ? (projection[name](_), gilbert) : projection[name]();\n    };\n  }\n\n  gilbert.rotate = function(_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n\n  gilbert.center = function(_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n\n  return gilbert\n      .scale(249.5);\n}\n"]}]}