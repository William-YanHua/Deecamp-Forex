{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/component/lib/axis/line.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/component/lib/axis/line.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) {\n    var NewTarget = _getPrototypeOf(this).constructor;\n    result = Reflect.construct(Super, arguments, NewTarget);\n}\nelse {\n    result = Super.apply(this, arguments);\n} return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n} return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n} return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct)\n    return false; if (Reflect.construct.sham)\n    return false; if (typeof Proxy === \"function\")\n    return true; try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));\n    return true;\n}\ncatch (e) {\n    return false;\n} }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\nvar Base = require('./base');\nvar Util = require('../util');\nvar MatrixUtil = Util.MatrixUtil;\nvar vec2 = MatrixUtil.vec2;\nvar Line = function (_Base) {\n    _inheritsLoose(Line, _Base);\n    var _super = _createSuper(Line);\n    function Line() {\n        return _Base.apply(this, arguments) || this;\n    }\n    var _proto = Line.prototype;\n    _proto.getDefaultCfg = function getDefaultCfg() {\n        var cfg = _Base.prototype.getDefaultCfg.call(this);\n        return Util.mix({}, cfg, {\n            x: null,\n            y: null,\n            line: {\n                lineWidth: 1,\n                stroke: '#C0D0E0'\n            },\n            tickLine: {\n                lineWidth: 1,\n                stroke: '#C0D0E0',\n                length: 5\n            },\n            isVertical: false,\n            start: null,\n            end: null\n        });\n    };\n    _proto._getAvgLabelLength = function _getAvgLabelLength(labelRenderer) {\n        var labels = labelRenderer.get('group').get('children');\n        return labels[1].attr('x') - labels[0].attr('x');\n    };\n    _proto._getAvgLabelHeightSpace = function _getAvgLabelHeightSpace(labelRenderer) {\n        var labels = labelRenderer.get('group').get('children');\n        return labels[1].attr('y') - labels[0].attr('y');\n    };\n    _proto.getSideVector = function getSideVector(offset) {\n        var self = this;\n        var isVertical = self.get('isVertical');\n        var factor = self.get('factor');\n        if (!Util.isNumber(offset)) {\n            return [0, 0];\n        }\n        var start = self.get('start');\n        var end = self.get('end');\n        var axisVector = self.getAxisVector();\n        var normal = vec2.normalize([], axisVector);\n        var direction = false;\n        if (isVertical && start.y < end.y || !isVertical && start.x > end.x) {\n            direction = true;\n        }\n        var verticalVector = vec2.vertical([], normal, direction);\n        return vec2.scale([], verticalVector, offset * factor);\n    };\n    _proto.getAxisVector = function getAxisVector() {\n        var start = this.get('start');\n        var end = this.get('end');\n        return [end.x - start.x, end.y - start.y];\n    };\n    _proto.getLinePath = function getLinePath() {\n        var self = this;\n        var start = self.get('start');\n        var end = self.get('end');\n        var path = [];\n        path.push(['M', start.x, start.y]);\n        path.push(['L', end.x, end.y]);\n        return path;\n    };\n    _proto.getTickEnd = function getTickEnd(start, value) {\n        var self = this;\n        var offsetVector = self.getSideVector(value);\n        return {\n            x: start.x + offsetVector[0],\n            y: start.y + offsetVector[1]\n        };\n    };\n    _proto.getTickPoint = function getTickPoint(tickValue) {\n        var self = this;\n        var start = self.get('start');\n        var end = self.get('end');\n        var rangeX = end.x - start.x;\n        var rangeY = end.y - start.y;\n        return {\n            x: start.x + rangeX * tickValue,\n            y: start.y + rangeY * tickValue\n        };\n    };\n    _proto.renderTitle = function renderTitle() {\n        var self = this;\n        var title = self.get('title');\n        var offsetPoint = self.getTickPoint(0.5);\n        var titleOffset = title.offset;\n        if (Util.isNil(titleOffset)) {\n            titleOffset = 20;\n            var labelsGroup = self.get('labelsGroup');\n            if (labelsGroup) {\n                var labelLength = self.getMaxLabelWidth(labelsGroup);\n                var labelOffset = self.get('label').offset || self.get('_labelOffset');\n                titleOffset += labelLength + labelOffset;\n            }\n        }\n        var textStyle = title.textStyle;\n        var cfg = Util.mix({}, textStyle);\n        if (title.text) {\n            var vector = self.getAxisVector();\n            if (title.autoRotate && Util.isNil(textStyle.rotate)) {\n                var angle = 0;\n                if (!Util.snapEqual(vector[1], 0)) {\n                    var v1 = [1, 0];\n                    var v2 = [vector[0], vector[1]];\n                    angle = vec2.angleTo(v2, v1, true);\n                }\n                cfg.rotate = angle * (180 / Math.PI);\n            }\n            else if (!Util.isNil(textStyle.rotate)) {\n                cfg.rotate = textStyle.rotate / 180 * Math.PI;\n            }\n            var sideVector = self.getSideVector(titleOffset);\n            var point;\n            var position = title.position;\n            if (position === 'start') {\n                point = {\n                    x: this.get('start').x + sideVector[0],\n                    y: this.get('start').y + sideVector[1]\n                };\n            }\n            else if (position === 'end') {\n                point = {\n                    x: this.get('end').x + sideVector[0],\n                    y: this.get('end').y + sideVector[1]\n                };\n            }\n            else {\n                point = {\n                    x: offsetPoint.x + sideVector[0],\n                    y: offsetPoint.y + sideVector[1]\n                };\n            }\n            cfg.x = point.x;\n            cfg.y = point.y;\n            cfg.text = title.text;\n            var group = self.get('group');\n            var titleShape = group.addShape('Text', {\n                zIndex: 2,\n                attrs: cfg\n            });\n            titleShape.name = 'axis-title';\n            self.get('appendInfo') && titleShape.setSilent('appendInfo', self.get('appendInfo'));\n        }\n    };\n    _proto.autoRotateLabels = function autoRotateLabels() {\n        var self = this;\n        var labelRenderer = self.get('labelRenderer');\n        var title = self.get('title');\n        if (labelRenderer) {\n            var labelGroup = labelRenderer.get('group');\n            var labels = labelGroup.get('children');\n            var offset = self.get('label').offset;\n            var append = 12;\n            var titleOffset = title ? title.offset : 48;\n            if (titleOffset < 0) {\n                return;\n            }\n            var vector = self.getAxisVector();\n            var angle;\n            var maxWidth;\n            if (Util.snapEqual(vector[0], 0) && title && title.text) {\n                maxWidth = self.getMaxLabelWidth(labelRenderer);\n                if (maxWidth > titleOffset - offset - append) {\n                    angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;\n                }\n            }\n            else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n                var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n                maxWidth = self.getMaxLabelWidth(labelRenderer);\n                if (maxWidth > avgWidth) {\n                    angle = Math.asin((titleOffset - offset - append) * 1.25 / maxWidth);\n                }\n            }\n            if (angle) {\n                var factor = self.get('factor');\n                Util.each(labels, function (label) {\n                    label.rotateAtStart(angle);\n                    if (Util.snapEqual(vector[1], 0)) {\n                        if (factor > 0) {\n                            label.attr('textAlign', 'left');\n                        }\n                        else {\n                            label.attr('textAlign', 'right');\n                        }\n                    }\n                });\n            }\n        }\n    };\n    _proto.autoHideLabels = function autoHideLabels() {\n        var self = this;\n        var labelRenderer = self.get('labelRenderer');\n        var labelSpace;\n        var tickStep;\n        var append = 8;\n        if (labelRenderer) {\n            var labelGroup = labelRenderer.get('group');\n            var labels = labelGroup.get('children');\n            var vector = self.getAxisVector();\n            if (labels.length < 2) {\n                return;\n            }\n            if (Util.snapEqual(vector[0], 0)) {\n                var maxHeight = self.getMaxLabelHeight(labelRenderer) + append;\n                var avgHeight = Math.abs(self._getAvgLabelHeightSpace(labelRenderer));\n                if (maxHeight > avgHeight) {\n                    labelSpace = maxHeight;\n                    tickStep = avgHeight;\n                }\n            }\n            else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n                var maxWidth = self.getMaxLabelWidth(labelRenderer) + append;\n                var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n                if (maxWidth > avgWidth) {\n                    labelSpace = maxWidth;\n                    tickStep = avgWidth;\n                }\n            }\n            if (labelSpace && tickStep) {\n                var ratio = Math.ceil(labelSpace / tickStep);\n                Util.each(labels, function (label, i) {\n                    if (i % ratio !== 0) {\n                        label.attr('text', '');\n                    }\n                });\n            }\n        }\n    };\n    return Line;\n}(Base);\nmodule.exports = Line;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/component/lib/axis/line.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/component/lib/axis/line.js"],"names":[],"mappings":"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","sourcesContent":["function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Base = require('./base');\n\nvar Util = require('../util');\n\nvar MatrixUtil = Util.MatrixUtil;\nvar vec2 = MatrixUtil.vec2;\n\nvar Line = /*#__PURE__*/function (_Base) {\n  _inheritsLoose(Line, _Base);\n\n  var _super = _createSuper(Line);\n\n  function Line() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      x: null,\n      // @type {Number} 距离初始位置的x轴偏移量,仅对于左侧、右侧的纵向坐标有效\n      y: null,\n      // @type {Number} 距离初始位置的y轴偏移量，仅对顶部、底部的横向坐标轴有效\n      line: {\n        // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n        lineWidth: 1,\n        stroke: '#C0D0E0'\n      },\n      tickLine: {\n        // @type {Attrs} 标注坐标线的图形属性\n        lineWidth: 1,\n        stroke: '#C0D0E0',\n        length: 5\n      },\n      isVertical: false,\n      start: null,\n      // @type {Object} 起点\n      end: null // @type {Object} 终点\n\n    });\n  };\n\n  _proto._getAvgLabelLength = function _getAvgLabelLength(labelRenderer) {\n    var labels = labelRenderer.get('group').get('children');\n    return labels[1].attr('x') - labels[0].attr('x');\n  };\n\n  _proto._getAvgLabelHeightSpace = function _getAvgLabelHeightSpace(labelRenderer) {\n    var labels = labelRenderer.get('group').get('children');\n    return labels[1].attr('y') - labels[0].attr('y');\n  }\n  /**\n   * 获取距离坐标轴的向量\n   * @override\n   * @param  {Number} offset 偏移值\n   * @return {Array}        返回二维向量\n   */\n  ;\n\n  _proto.getSideVector = function getSideVector(offset) {\n    var self = this;\n    var isVertical = self.get('isVertical');\n    var factor = self.get('factor'); // if (Util.isArray(offset)) {\n    //   return offset.map(value => value * factor);\n    // }\n\n    if (!Util.isNumber(offset)) {\n      return [0, 0];\n    }\n\n    var start = self.get('start');\n    var end = self.get('end');\n    var axisVector = self.getAxisVector();\n    var normal = vec2.normalize([], axisVector);\n    var direction = false;\n\n    if (isVertical && start.y < end.y || !isVertical && start.x > end.x) {\n      direction = true;\n    }\n\n    var verticalVector = vec2.vertical([], normal, direction);\n    return vec2.scale([], verticalVector, offset * factor);\n  };\n\n  _proto.getAxisVector = function getAxisVector() {\n    var start = this.get('start');\n    var end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, value) {\n    var self = this;\n    var offsetVector = self.getSideVector(value);\n    return {\n      x: start.x + offsetVector[0],\n      y: start.y + offsetVector[1]\n    };\n  };\n\n  _proto.getTickPoint = function getTickPoint(tickValue) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var rangeX = end.x - start.x;\n    var rangeY = end.y - start.y;\n    return {\n      x: start.x + rangeX * tickValue,\n      y: start.y + rangeY * tickValue\n    };\n  };\n\n  _proto.renderTitle = function renderTitle() {\n    var self = this;\n    var title = self.get('title');\n    var offsetPoint = self.getTickPoint(0.5);\n    var titleOffset = title.offset;\n\n    if (Util.isNil(titleOffset)) {\n      // 没有指定 offset 则自动计算\n      titleOffset = 20;\n      var labelsGroup = self.get('labelsGroup');\n\n      if (labelsGroup) {\n        var labelLength = self.getMaxLabelWidth(labelsGroup);\n        var labelOffset = self.get('label').offset || self.get('_labelOffset');\n        titleOffset += labelLength + labelOffset;\n      }\n    }\n\n    var textStyle = title.textStyle;\n    var cfg = Util.mix({}, textStyle);\n\n    if (title.text) {\n      var vector = self.getAxisVector(); // 坐标轴方向的向量\n\n      if (title.autoRotate && Util.isNil(textStyle.rotate)) {\n        // 自动旋转并且用户没有指定标题的旋转角度\n        var angle = 0;\n\n        if (!Util.snapEqual(vector[1], 0)) {\n          // 所有水平坐标轴，文本不转置\n          var v1 = [1, 0];\n          var v2 = [vector[0], vector[1]];\n          angle = vec2.angleTo(v2, v1, true);\n        }\n\n        cfg.rotate = angle * (180 / Math.PI);\n      } else if (!Util.isNil(textStyle.rotate)) {\n        // 用户设置了旋转角度就以用户设置的为准\n        cfg.rotate = textStyle.rotate / 180 * Math.PI; // 将角度转换为弧度\n      }\n\n      var sideVector = self.getSideVector(titleOffset);\n      var point;\n      var position = title.position;\n\n      if (position === 'start') {\n        point = {\n          x: this.get('start').x + sideVector[0],\n          y: this.get('start').y + sideVector[1]\n        };\n      } else if (position === 'end') {\n        point = {\n          x: this.get('end').x + sideVector[0],\n          y: this.get('end').y + sideVector[1]\n        };\n      } else {\n        point = {\n          x: offsetPoint.x + sideVector[0],\n          y: offsetPoint.y + sideVector[1]\n        };\n      }\n\n      cfg.x = point.x;\n      cfg.y = point.y;\n      cfg.text = title.text;\n      var group = self.get('group');\n      var titleShape = group.addShape('Text', {\n        zIndex: 2,\n        attrs: cfg\n      });\n      titleShape.name = 'axis-title';\n      self.get('appendInfo') && titleShape.setSilent('appendInfo', self.get('appendInfo'));\n    }\n  };\n\n  _proto.autoRotateLabels = function autoRotateLabels() {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var title = self.get('title');\n\n    if (labelRenderer) {\n      var labelGroup = labelRenderer.get('group');\n      var labels = labelGroup.get('children');\n      var offset = self.get('label').offset;\n      var append = 12;\n      var titleOffset = title ? title.offset : 48;\n\n      if (titleOffset < 0) {\n        // 如果是负的的话就不旋转\n        return;\n      }\n\n      var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景\n\n      var angle;\n      var maxWidth;\n\n      if (Util.snapEqual(vector[0], 0) && title && title.text) {\n        // 坐标轴垂直，由于不知道边距，只能防止跟title重合，如果title不存在，则不自动旋转\n        maxWidth = self.getMaxLabelWidth(labelRenderer);\n\n        if (maxWidth > titleOffset - offset - append) {\n          angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;\n        }\n      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n        // 坐标轴水平，不考虑边距，根据最长的和平均值进行翻转\n        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n        maxWidth = self.getMaxLabelWidth(labelRenderer);\n\n        if (maxWidth > avgWidth) {\n          angle = Math.asin((titleOffset - offset - append) * 1.25 / maxWidth);\n        }\n      }\n\n      if (angle) {\n        var factor = self.get('factor');\n        Util.each(labels, function (label) {\n          label.rotateAtStart(angle);\n\n          if (Util.snapEqual(vector[1], 0)) {\n            if (factor > 0) {\n              label.attr('textAlign', 'left');\n            } else {\n              label.attr('textAlign', 'right');\n            }\n          }\n        });\n      }\n    }\n  };\n\n  _proto.autoHideLabels = function autoHideLabels() {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var labelSpace;\n    var tickStep;\n    var append = 8;\n\n    if (labelRenderer) {\n      var labelGroup = labelRenderer.get('group');\n      var labels = labelGroup.get('children');\n      var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景\n\n      if (labels.length < 2) {\n        return;\n      }\n\n      if (Util.snapEqual(vector[0], 0)) {\n        // 坐标轴垂直\n        var maxHeight = self.getMaxLabelHeight(labelRenderer) + append;\n        var avgHeight = Math.abs(self._getAvgLabelHeightSpace(labelRenderer));\n\n        if (maxHeight > avgHeight) {\n          labelSpace = maxHeight;\n          tickStep = avgHeight;\n        }\n      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n        // 坐标轴水平\n        var maxWidth = self.getMaxLabelWidth(labelRenderer) + append;\n        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n\n        if (maxWidth > avgWidth) {\n          labelSpace = maxWidth;\n          tickStep = avgWidth;\n        }\n      }\n\n      if (labelSpace && tickStep) {\n        var ratio = Math.ceil(labelSpace / tickStep);\n        Util.each(labels, function (label, i) {\n          if (i % ratio !== 0) {\n            label.attr('text', '');\n          }\n        });\n      }\n    }\n  };\n\n  return Line;\n}(Base);\n\nmodule.exports = Line;"]}]}