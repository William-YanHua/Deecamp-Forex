{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/rank/network-simplex.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/rank/network-simplex.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\nmodule.exports = networkSimplex;\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\nfunction networkSimplex(g) {\n    g = simplify(g);\n    initRank(g);\n    var t = feasibleTree(g);\n    initLowLimValues(t);\n    initCutValues(t, g);\n    var e, f;\n    while ((e = leaveEdge(t))) {\n        f = enterEdge(t, g, e);\n        exchangeEdges(t, g, e, f);\n    }\n}\nfunction initCutValues(t, g) {\n    var vs = postorder(t, t.nodes());\n    vs = vs.slice(0, vs.length - 1);\n    _.forEach(vs, function (v) {\n        assignCutValue(t, g, v);\n    });\n}\nfunction assignCutValue(t, g, child) {\n    var childLab = t.node(child);\n    var parent = childLab.parent;\n    t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\nfunction calcCutValue(t, g, child) {\n    var childLab = t.node(child);\n    var parent = childLab.parent;\n    var childIsTail = true;\n    var graphEdge = g.edge(child, parent);\n    var cutValue = 0;\n    if (!graphEdge) {\n        childIsTail = false;\n        graphEdge = g.edge(parent, child);\n    }\n    cutValue = graphEdge.weight;\n    _.forEach(g.nodeEdges(child), function (e) {\n        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;\n        if (other !== parent) {\n            var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;\n            cutValue += pointsToHead ? otherWeight : -otherWeight;\n            if (isTreeEdge(t, child, other)) {\n                var otherCutValue = t.edge(child, other).cutvalue;\n                cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n            }\n        }\n    });\n    return cutValue;\n}\nfunction initLowLimValues(tree, root) {\n    if (arguments.length < 2) {\n        root = tree.nodes()[0];\n    }\n    dfsAssignLowLim(tree, {}, 1, root);\n}\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n    var low = nextLim;\n    var label = tree.node(v);\n    visited[v] = true;\n    _.forEach(tree.neighbors(v), function (w) {\n        if (!_.has(visited, w)) {\n            nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n        }\n    });\n    label.low = low;\n    label.lim = nextLim++;\n    if (parent) {\n        label.parent = parent;\n    }\n    else {\n        delete label.parent;\n    }\n    return nextLim;\n}\nfunction leaveEdge(tree) {\n    return _.find(tree.edges(), function (e) {\n        return tree.edge(e).cutvalue < 0;\n    });\n}\nfunction enterEdge(t, g, edge) {\n    var v = edge.v;\n    var w = edge.w;\n    if (!g.hasEdge(v, w)) {\n        v = edge.w;\n        w = edge.v;\n    }\n    var vLabel = t.node(v);\n    var wLabel = t.node(w);\n    var tailLabel = vLabel;\n    var flip = false;\n    if (vLabel.lim > wLabel.lim) {\n        tailLabel = wLabel;\n        flip = true;\n    }\n    var candidates = _.filter(g.edges(), function (edge) {\n        return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n            flip !== isDescendant(t, t.node(edge.w), tailLabel);\n    });\n    return _.minBy(candidates, function (edge) { return slack(g, edge); });\n}\nfunction exchangeEdges(t, g, e, f) {\n    var v = e.v;\n    var w = e.w;\n    t.removeEdge(v, w);\n    t.setEdge(f.v, f.w, {});\n    initLowLimValues(t);\n    initCutValues(t, g);\n    updateRanks(t, g);\n}\nfunction updateRanks(t, g) {\n    var root = _.find(t.nodes(), function (v) { return !g.node(v).parent; });\n    var vs = preorder(t, root);\n    vs = vs.slice(1);\n    _.forEach(vs, function (v) {\n        var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;\n        if (!edge) {\n            edge = g.edge(parent, v);\n            flipped = true;\n        }\n        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n    });\n}\nfunction isTreeEdge(tree, u, v) {\n    return tree.hasEdge(u, v);\n}\nfunction isDescendant(tree, vLabel, rootLabel) {\n    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/rank/network-simplex.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/rank/network-simplex.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n"]}]}