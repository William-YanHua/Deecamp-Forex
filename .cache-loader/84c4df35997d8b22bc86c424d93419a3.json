{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-selection\\src\\selection\\data.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-selection\\src\\selection\\data.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { Selection } from \"./index\";\r\nimport { EnterNode } from \"./enter\";\r\nimport constant from \"../constant\";\r\nvar keyPrefix = \"$\";\r\nfunction bindIndex(parent, group, enter, update, exit, data) {\r\n    var i = 0, node, groupLength = group.length, dataLength = data.length;\r\n    for (; i < dataLength; ++i) {\r\n        if (node = group[i]) {\r\n            node.__data__ = data[i];\r\n            update[i] = node;\r\n        }\r\n        else {\r\n            enter[i] = new EnterNode(parent, data[i]);\r\n        }\r\n    }\r\n    for (; i < groupLength; ++i) {\r\n        if (node = group[i]) {\r\n            exit[i] = node;\r\n        }\r\n    }\r\n}\r\nfunction bindKey(parent, group, enter, update, exit, data, key) {\r\n    var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;\r\n    for (i = 0; i < groupLength; ++i) {\r\n        if (node = group[i]) {\r\n            keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\r\n            if (keyValue in nodeByKeyValue) {\r\n                exit[i] = node;\r\n            }\r\n            else {\r\n                nodeByKeyValue[keyValue] = node;\r\n            }\r\n        }\r\n    }\r\n    for (i = 0; i < dataLength; ++i) {\r\n        keyValue = keyPrefix + key.call(parent, data[i], i, data);\r\n        if (node = nodeByKeyValue[keyValue]) {\r\n            update[i] = node;\r\n            node.__data__ = data[i];\r\n            nodeByKeyValue[keyValue] = null;\r\n        }\r\n        else {\r\n            enter[i] = new EnterNode(parent, data[i]);\r\n        }\r\n    }\r\n    for (i = 0; i < groupLength; ++i) {\r\n        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\r\n            exit[i] = node;\r\n        }\r\n    }\r\n}\r\nexport default function (value, key) {\r\n    if (!value) {\r\n        data = new Array(this.size()), j = -1;\r\n        this.each(function (d) { data[++j] = d; });\r\n        return data;\r\n    }\r\n    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;\r\n    if (typeof value !== \"function\")\r\n        value = constant(value);\r\n    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\r\n        var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);\r\n        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\r\n        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\r\n            if (previous = enterGroup[i0]) {\r\n                if (i0 >= i1)\r\n                    i1 = i0 + 1;\r\n                while (!(next = updateGroup[i1]) && ++i1 < dataLength)\r\n                    ;\r\n                previous._next = next || null;\r\n            }\r\n        }\r\n    }\r\n    update = new Selection(update, parents);\r\n    update._enter = enter;\r\n    update._exit = exit;\r\n    return update;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-selection\\src\\selection\\data.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-selection\\src\\selection\\data.js"],"names":[],"mappings":"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","sourcesContent":["import {Selection} from \"./index\";\nimport {EnterNode} from \"./enter\";\nimport constant from \"../constant\";\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n"]}]}