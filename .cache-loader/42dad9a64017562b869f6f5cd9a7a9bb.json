{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\centroid.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\centroid.js","mtime":1466568743000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { acos, asin, atan2, cos, degrees, epsilon, epsilon2, radians, sin, sqrt } from \"./math\";\r\nimport noop from \"./noop\";\r\nimport stream from \"./stream\";\r\nvar W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, x0, y0, z0;\r\nvar centroidStream = {\r\n    sphere: noop,\r\n    point: centroidPoint,\r\n    lineStart: centroidLineStart,\r\n    lineEnd: centroidLineEnd,\r\n    polygonStart: function () {\r\n        centroidStream.lineStart = centroidRingStart;\r\n        centroidStream.lineEnd = centroidRingEnd;\r\n    },\r\n    polygonEnd: function () {\r\n        centroidStream.lineStart = centroidLineStart;\r\n        centroidStream.lineEnd = centroidLineEnd;\r\n    }\r\n};\r\nfunction centroidPoint(lambda, phi) {\r\n    lambda *= radians, phi *= radians;\r\n    var cosPhi = cos(phi);\r\n    centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\r\n}\r\nfunction centroidPointCartesian(x, y, z) {\r\n    ++W0;\r\n    X0 += (x - X0) / W0;\r\n    Y0 += (y - Y0) / W0;\r\n    Z0 += (z - Z0) / W0;\r\n}\r\nfunction centroidLineStart() {\r\n    centroidStream.point = centroidLinePointFirst;\r\n}\r\nfunction centroidLinePointFirst(lambda, phi) {\r\n    lambda *= radians, phi *= radians;\r\n    var cosPhi = cos(phi);\r\n    x0 = cosPhi * cos(lambda);\r\n    y0 = cosPhi * sin(lambda);\r\n    z0 = sin(phi);\r\n    centroidStream.point = centroidLinePoint;\r\n    centroidPointCartesian(x0, y0, z0);\r\n}\r\nfunction centroidLinePoint(lambda, phi) {\r\n    lambda *= radians, phi *= radians;\r\n    var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\r\n    W1 += w;\r\n    X1 += w * (x0 + (x0 = x));\r\n    Y1 += w * (y0 + (y0 = y));\r\n    Z1 += w * (z0 + (z0 = z));\r\n    centroidPointCartesian(x0, y0, z0);\r\n}\r\nfunction centroidLineEnd() {\r\n    centroidStream.point = centroidPoint;\r\n}\r\nfunction centroidRingStart() {\r\n    centroidStream.point = centroidRingPointFirst;\r\n}\r\nfunction centroidRingEnd() {\r\n    centroidRingPoint(lambda00, phi00);\r\n    centroidStream.point = centroidPoint;\r\n}\r\nfunction centroidRingPointFirst(lambda, phi) {\r\n    lambda00 = lambda, phi00 = phi;\r\n    lambda *= radians, phi *= radians;\r\n    centroidStream.point = centroidRingPoint;\r\n    var cosPhi = cos(phi);\r\n    x0 = cosPhi * cos(lambda);\r\n    y0 = cosPhi * sin(lambda);\r\n    z0 = sin(phi);\r\n    centroidPointCartesian(x0, y0, z0);\r\n}\r\nfunction centroidRingPoint(lambda, phi) {\r\n    lambda *= radians, phi *= radians;\r\n    var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -acos(u) / m, w = atan2(m, u);\r\n    X2 += v * cx;\r\n    Y2 += v * cy;\r\n    Z2 += v * cz;\r\n    W1 += w;\r\n    X1 += w * (x0 + (x0 = x));\r\n    Y1 += w * (y0 + (y0 = y));\r\n    Z1 += w * (z0 + (z0 = z));\r\n    centroidPointCartesian(x0, y0, z0);\r\n}\r\nexport default function (object) {\r\n    W0 = W1 =\r\n        X0 = Y0 = Z0 =\r\n            X1 = Y1 = Z1 =\r\n                X2 = Y2 = Z2 = 0;\r\n    stream(object, centroidStream);\r\n    var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;\r\n    if (m < epsilon2) {\r\n        x = X1, y = Y1, z = Z1;\r\n        if (W1 < epsilon)\r\n            x = X0, y = Y0, z = Z0;\r\n        m = x * x + y * y + z * z;\r\n        if (m < epsilon2)\r\n            return [NaN, NaN];\r\n    }\r\n    return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\centroid.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\centroid.js"],"names":[],"mappings":"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","sourcesContent":["import {acos, asin, atan2, cos, degrees, epsilon, epsilon2, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      u = x0 * x + y0 * y + z0 * z,\n      v = m && -acos(u) / m, // area weight\n      w = atan2(m, u); // line weight\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  stream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n}\n"]}]}