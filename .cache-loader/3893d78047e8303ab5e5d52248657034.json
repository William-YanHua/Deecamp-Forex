{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\clip\\extent.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\clip\\extent.js","mtime":1467246014000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { abs, epsilon } from \"../math\";\r\nimport clipBuffer from \"./buffer\";\r\nimport clipLine from \"./line\";\r\nimport clipPolygon from \"./polygon\";\r\nimport { merge } from \"d3-array\";\r\nvar clipMax = 1e9, clipMin = -clipMax;\r\nexport function clipExtent(x0, y0, x1, y1) {\r\n    function visible(x, y) {\r\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\r\n    }\r\n    function interpolate(from, to, direction, stream) {\r\n        var a = 0, a1 = 0;\r\n        if (from == null\r\n            || (a = corner(from, direction)) !== (a1 = corner(to, direction))\r\n            || comparePoint(from, to) < 0 ^ direction > 0) {\r\n            do\r\n                stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\r\n            while ((a = (a + direction + 4) % 4) !== a1);\r\n        }\r\n        else {\r\n            stream.point(to[0], to[1]);\r\n        }\r\n    }\r\n    function corner(p, direction) {\r\n        return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\r\n            : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\r\n                : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\r\n                    : direction > 0 ? 3 : 2;\r\n    }\r\n    function compareIntersection(a, b) {\r\n        return comparePoint(a.x, b.x);\r\n    }\r\n    function comparePoint(a, b) {\r\n        var ca = corner(a, 1), cb = corner(b, 1);\r\n        return ca !== cb ? ca - cb\r\n            : ca === 0 ? b[1] - a[1]\r\n                : ca === 1 ? a[0] - b[0]\r\n                    : ca === 2 ? a[1] - b[1]\r\n                        : b[0] - a[0];\r\n    }\r\n    return function (stream) {\r\n        var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;\r\n        var clipStream = {\r\n            point: point,\r\n            lineStart: lineStart,\r\n            lineEnd: lineEnd,\r\n            polygonStart: polygonStart,\r\n            polygonEnd: polygonEnd\r\n        };\r\n        function point(x, y) {\r\n            if (visible(x, y))\r\n                activeStream.point(x, y);\r\n        }\r\n        function polygonInside() {\r\n            var winding = 0;\r\n            for (var i = 0, n = polygon.length; i < n; ++i) {\r\n                for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\r\n                    a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\r\n                    if (a1 <= y1) {\r\n                        if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))\r\n                            ++winding;\r\n                    }\r\n                    else {\r\n                        if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))\r\n                            --winding;\r\n                    }\r\n                }\r\n            }\r\n            return winding;\r\n        }\r\n        function polygonStart() {\r\n            activeStream = bufferStream, segments = [], polygon = [], clean = true;\r\n        }\r\n        function polygonEnd() {\r\n            var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = merge(segments)).length;\r\n            if (cleanInside || visible) {\r\n                stream.polygonStart();\r\n                if (cleanInside) {\r\n                    stream.lineStart();\r\n                    interpolate(null, null, 1, stream);\r\n                    stream.lineEnd();\r\n                }\r\n                if (visible) {\r\n                    clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\r\n                }\r\n                stream.polygonEnd();\r\n            }\r\n            activeStream = stream, segments = polygon = ring = null;\r\n        }\r\n        function lineStart() {\r\n            clipStream.point = linePoint;\r\n            if (polygon)\r\n                polygon.push(ring = []);\r\n            first = true;\r\n            v_ = false;\r\n            x_ = y_ = NaN;\r\n        }\r\n        function lineEnd() {\r\n            if (segments) {\r\n                linePoint(x__, y__);\r\n                if (v__ && v_)\r\n                    bufferStream.rejoin();\r\n                segments.push(bufferStream.result());\r\n            }\r\n            clipStream.point = point;\r\n            if (v_)\r\n                activeStream.lineEnd();\r\n        }\r\n        function linePoint(x, y) {\r\n            var v = visible(x, y);\r\n            if (polygon)\r\n                ring.push([x, y]);\r\n            if (first) {\r\n                x__ = x, y__ = y, v__ = v;\r\n                first = false;\r\n                if (v) {\r\n                    activeStream.lineStart();\r\n                    activeStream.point(x, y);\r\n                }\r\n            }\r\n            else {\r\n                if (v && v_)\r\n                    activeStream.point(x, y);\r\n                else {\r\n                    var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\r\n                    if (clipLine(a, b, x0, y0, x1, y1)) {\r\n                        if (!v_) {\r\n                            activeStream.lineStart();\r\n                            activeStream.point(a[0], a[1]);\r\n                        }\r\n                        activeStream.point(b[0], b[1]);\r\n                        if (!v)\r\n                            activeStream.lineEnd();\r\n                        clean = false;\r\n                    }\r\n                    else if (v) {\r\n                        activeStream.lineStart();\r\n                        activeStream.point(x, y);\r\n                        clean = false;\r\n                    }\r\n                }\r\n            }\r\n            x_ = x, y_ = y, v_ = v;\r\n        }\r\n        return clipStream;\r\n    };\r\n}\r\nexport default function () {\r\n    var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;\r\n    return clip = {\r\n        stream: function (stream) {\r\n            return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\r\n        },\r\n        extent: function (_) {\r\n            return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\r\n        }\r\n    };\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\clip\\extent.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\clip\\extent.js"],"names":[],"mappings":"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","sourcesContent":["import {abs, epsilon} from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipPolygon from \"./polygon\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport function clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n"]}]}