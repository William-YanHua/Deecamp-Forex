{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\clip\\index.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\clip\\index.js","mtime":1466440270000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import clipBuffer from \"./buffer\";\r\nimport clipPolygon from \"./polygon\";\r\nimport { epsilon, halfPi } from \"../math\";\r\nimport polygonContains from \"../polygonContains\";\r\nimport { merge } from \"d3-array\";\r\nexport default function (pointVisible, clipLine, interpolate, start) {\r\n    return function (rotate, sink) {\r\n        var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\r\n        var clip = {\r\n            point: point,\r\n            lineStart: lineStart,\r\n            lineEnd: lineEnd,\r\n            polygonStart: function () {\r\n                clip.point = pointRing;\r\n                clip.lineStart = ringStart;\r\n                clip.lineEnd = ringEnd;\r\n                segments = [];\r\n                polygon = [];\r\n            },\r\n            polygonEnd: function () {\r\n                clip.point = point;\r\n                clip.lineStart = lineStart;\r\n                clip.lineEnd = lineEnd;\r\n                segments = merge(segments);\r\n                var startInside = polygonContains(polygon, rotatedStart);\r\n                if (segments.length) {\r\n                    if (!polygonStarted)\r\n                        sink.polygonStart(), polygonStarted = true;\r\n                    clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\r\n                }\r\n                else if (startInside) {\r\n                    if (!polygonStarted)\r\n                        sink.polygonStart(), polygonStarted = true;\r\n                    sink.lineStart();\r\n                    interpolate(null, null, 1, sink);\r\n                    sink.lineEnd();\r\n                }\r\n                if (polygonStarted)\r\n                    sink.polygonEnd(), polygonStarted = false;\r\n                segments = polygon = null;\r\n            },\r\n            sphere: function () {\r\n                sink.polygonStart();\r\n                sink.lineStart();\r\n                interpolate(null, null, 1, sink);\r\n                sink.lineEnd();\r\n                sink.polygonEnd();\r\n            }\r\n        };\r\n        function point(lambda, phi) {\r\n            var point = rotate(lambda, phi);\r\n            if (pointVisible(lambda = point[0], phi = point[1]))\r\n                sink.point(lambda, phi);\r\n        }\r\n        function pointLine(lambda, phi) {\r\n            var point = rotate(lambda, phi);\r\n            line.point(point[0], point[1]);\r\n        }\r\n        function lineStart() {\r\n            clip.point = pointLine;\r\n            line.lineStart();\r\n        }\r\n        function lineEnd() {\r\n            clip.point = point;\r\n            line.lineEnd();\r\n        }\r\n        function pointRing(lambda, phi) {\r\n            ring.push([lambda, phi]);\r\n            var point = rotate(lambda, phi);\r\n            ringSink.point(point[0], point[1]);\r\n        }\r\n        function ringStart() {\r\n            ringSink.lineStart();\r\n            ring = [];\r\n        }\r\n        function ringEnd() {\r\n            pointRing(ring[0][0], ring[0][1]);\r\n            ringSink.lineEnd();\r\n            var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\r\n            ring.pop();\r\n            polygon.push(ring);\r\n            ring = null;\r\n            if (!n)\r\n                return;\r\n            if (clean & 1) {\r\n                segment = ringSegments[0];\r\n                if ((m = segment.length - 1) > 0) {\r\n                    if (!polygonStarted)\r\n                        sink.polygonStart(), polygonStarted = true;\r\n                    sink.lineStart();\r\n                    for (i = 0; i < m; ++i)\r\n                        sink.point((point = segment[i])[0], point[1]);\r\n                    sink.lineEnd();\r\n                }\r\n                return;\r\n            }\r\n            if (n > 1 && clean & 2)\r\n                ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\r\n            segments.push(ringSegments.filter(validSegment));\r\n        }\r\n        return clip;\r\n    };\r\n}\r\nfunction validSegment(segment) {\r\n    return segment.length > 1;\r\n}\r\nfunction compareIntersection(a, b) {\r\n    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\r\n        - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\clip\\index.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-composite-projections\\node_modules\\d3-geo\\src\\clip\\index.js"],"names":[],"mappings":"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","sourcesContent":["import clipBuffer from \"./buffer\";\nimport clipPolygon from \"./polygon\";\nimport {epsilon, halfPi} from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n"]}]}