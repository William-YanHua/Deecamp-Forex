{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/util.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/util.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nvar _ = require(\"./lodash\");\nvar Graph = require(\"./graphlib\").Graph;\nmodule.exports = {\n    addDummyNode: addDummyNode,\n    simplify: simplify,\n    asNonCompoundGraph: asNonCompoundGraph,\n    successorWeights: successorWeights,\n    predecessorWeights: predecessorWeights,\n    intersectRect: intersectRect,\n    buildLayerMatrix: buildLayerMatrix,\n    normalizeRanks: normalizeRanks,\n    removeEmptyRanks: removeEmptyRanks,\n    addBorderNode: addBorderNode,\n    maxRank: maxRank,\n    partition: partition,\n    time: time,\n    notime: notime\n};\nfunction addDummyNode(g, type, attrs, name) {\n    var v;\n    do {\n        v = _.uniqueId(name);\n    } while (g.hasNode(v));\n    attrs.dummy = type;\n    g.setNode(v, attrs);\n    return v;\n}\nfunction simplify(g) {\n    var simplified = new Graph().setGraph(g.graph());\n    _.forEach(g.nodes(), function (v) { simplified.setNode(v, g.node(v)); });\n    _.forEach(g.edges(), function (e) {\n        var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n        var label = g.edge(e);\n        simplified.setEdge(e.v, e.w, {\n            weight: simpleLabel.weight + label.weight,\n            minlen: Math.max(simpleLabel.minlen, label.minlen)\n        });\n    });\n    return simplified;\n}\nfunction asNonCompoundGraph(g) {\n    var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n    _.forEach(g.nodes(), function (v) {\n        if (!g.children(v).length) {\n            simplified.setNode(v, g.node(v));\n        }\n    });\n    _.forEach(g.edges(), function (e) {\n        simplified.setEdge(e, g.edge(e));\n    });\n    return simplified;\n}\nfunction successorWeights(g) {\n    var weightMap = _.map(g.nodes(), function (v) {\n        var sucs = {};\n        _.forEach(g.outEdges(v), function (e) {\n            sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n        });\n        return sucs;\n    });\n    return _.zipObject(g.nodes(), weightMap);\n}\nfunction predecessorWeights(g) {\n    var weightMap = _.map(g.nodes(), function (v) {\n        var preds = {};\n        _.forEach(g.inEdges(v), function (e) {\n            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n        });\n        return preds;\n    });\n    return _.zipObject(g.nodes(), weightMap);\n}\nfunction intersectRect(rect, point) {\n    var x = rect.x;\n    var y = rect.y;\n    var dx = point.x - x;\n    var dy = point.y - y;\n    var w = rect.width / 2;\n    var h = rect.height / 2;\n    if (!dx && !dy) {\n        throw new Error(\"Not possible to find intersection inside of the rectangle\");\n    }\n    var sx, sy;\n    if (Math.abs(dy) * w > Math.abs(dx) * h) {\n        if (dy < 0) {\n            h = -h;\n        }\n        sx = h * dx / dy;\n        sy = h;\n    }\n    else {\n        if (dx < 0) {\n            w = -w;\n        }\n        sx = w;\n        sy = w * dy / dx;\n    }\n    return { x: x + sx, y: y + sy };\n}\nfunction buildLayerMatrix(g) {\n    var layering = _.map(_.range(maxRank(g) + 1), function () { return []; });\n    _.forEach(g.nodes(), function (v) {\n        var node = g.node(v);\n        var rank = node.rank;\n        if (!_.isUndefined(rank)) {\n            layering[rank][node.order] = v;\n        }\n    });\n    return layering;\n}\nfunction normalizeRanks(g) {\n    var min = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank; }));\n    _.forEach(g.nodes(), function (v) {\n        var node = g.node(v);\n        if (_.has(node, \"rank\")) {\n            node.rank -= min;\n        }\n    });\n}\nfunction removeEmptyRanks(g) {\n    var offset = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank; }));\n    var layers = [];\n    _.forEach(g.nodes(), function (v) {\n        var rank = g.node(v).rank - offset;\n        if (!layers[rank]) {\n            layers[rank] = [];\n        }\n        layers[rank].push(v);\n    });\n    var delta = 0;\n    var nodeRankFactor = g.graph().nodeRankFactor;\n    _.forEach(layers, function (vs, i) {\n        if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n            --delta;\n        }\n        else if (delta) {\n            _.forEach(vs, function (v) { g.node(v).rank += delta; });\n        }\n    });\n}\nfunction addBorderNode(g, prefix, rank, order) {\n    var node = {\n        width: 0,\n        height: 0\n    };\n    if (arguments.length >= 4) {\n        node.rank = rank;\n        node.order = order;\n    }\n    return addDummyNode(g, \"border\", node, prefix);\n}\nfunction maxRank(g) {\n    return _.max(_.map(g.nodes(), function (v) {\n        var rank = g.node(v).rank;\n        if (!_.isUndefined(rank)) {\n            return rank;\n        }\n    }));\n}\nfunction partition(collection, fn) {\n    var result = { lhs: [], rhs: [] };\n    _.forEach(collection, function (value) {\n        if (fn(value)) {\n            result.lhs.push(value);\n        }\n        else {\n            result.rhs.push(value);\n        }\n    });\n    return result;\n}\nfunction time(name, fn) {\n    var start = _.now();\n    try {\n        return fn();\n    }\n    finally {\n        console.log(name + \" time: \" + (_.now() - start) + \"ms\");\n    }\n}\nfunction notime(name, fn) {\n    return fn();\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/util.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/util.js"],"names":[],"mappings":"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","sourcesContent":["/* eslint \"no-console\": off */\n\n\"use strict\";\n\nvar _ = require(\"./lodash\");\nvar Graph = require(\"./graphlib\").Graph;\n\nmodule.exports = {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function(e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function(e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function(e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (_.has(node, \"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n\n  var layers = [];\n  _.forEach(g.nodes(), function(v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function(vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function(v) { g.node(v).rank += delta; });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(_.map(g.nodes(), function(v) {\n    var rank = g.node(v).rank;\n    if (!_.isUndefined(rank)) {\n      return rank;\n    }\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function(value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (_.now() - start) + \"ms\");\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n"]}]}