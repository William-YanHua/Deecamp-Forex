{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/coordinate.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/coordinate.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCoordinateClipCfg = exports.getAngleByPoint = exports.isPointInCoordinate = exports.getDistanceToCenter = exports.isFullCircle = exports.getXDimensionLength = void 0;\nvar graphics_1 = require(\"./graphics\");\nvar helper_1 = require(\"./helper\");\nfunction getXDimensionLength(coordinate) {\n    if (coordinate.isPolar && !coordinate.isTransposed) {\n        return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n    }\n    var start = coordinate.convert({ x: 0, y: 0 });\n    var end = coordinate.convert({ x: 1, y: 0 });\n    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\nexports.getXDimensionLength = getXDimensionLength;\nfunction isFullCircle(coordinate) {\n    if (coordinate.isPolar) {\n        var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;\n        return endAngle - startAngle === Math.PI * 2;\n    }\n    return false;\n}\nexports.isFullCircle = isFullCircle;\nfunction getDistanceToCenter(coordinate, point) {\n    var center = coordinate.getCenter();\n    return Math.sqrt(Math.pow((point.x - center.x), 2) + Math.pow((point.y - center.y), 2));\n}\nexports.getDistanceToCenter = getDistanceToCenter;\nfunction isPointInCoordinate(coordinate, point) {\n    var result = false;\n    if (coordinate) {\n        if (coordinate.type === 'theta') {\n            var start = coordinate.start, end = coordinate.end;\n            result = helper_1.isBetween(point.x, start.x, end.x) && helper_1.isBetween(point.y, start.y, end.y);\n        }\n        else {\n            var invertPoint = coordinate.invert(point);\n            result = helper_1.isBetween(invertPoint.x, 0, 1) && helper_1.isBetween(invertPoint.y, 0, 1);\n        }\n    }\n    return result;\n}\nexports.isPointInCoordinate = isPointInCoordinate;\nfunction getAngleByPoint(coordinate, point) {\n    var center = coordinate.getCenter();\n    return Math.atan2(point.y - center.y, point.x - center.x);\n}\nexports.getAngleByPoint = getAngleByPoint;\nfunction getCoordinateClipCfg(coordinate, margin) {\n    if (margin === void 0) {\n        margin = 0;\n    }\n    var start = coordinate.start, end = coordinate.end;\n    var width = coordinate.getWidth();\n    var height = coordinate.getHeight();\n    if (coordinate.isPolar) {\n        var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;\n        var center_1 = coordinate.getCenter();\n        var radius_1 = coordinate.getRadius();\n        return {\n            type: 'path',\n            startState: {\n                path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1),\n            },\n            endState: function (ratio) {\n                var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n                var path = graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n                return {\n                    path: path,\n                };\n            },\n            attrs: {\n                path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1),\n            },\n        };\n    }\n    var endState;\n    if (coordinate.isTransposed) {\n        endState = {\n            height: height + margin * 2,\n        };\n    }\n    else {\n        endState = {\n            width: width + margin * 2,\n        };\n    }\n    return {\n        type: 'rect',\n        startState: {\n            x: start.x - margin,\n            y: end.y - margin,\n            width: coordinate.isTransposed ? width + margin * 2 : 0,\n            height: coordinate.isTransposed ? 0 : height + margin * 2,\n        },\n        endState: endState,\n        attrs: {\n            x: start.x - margin,\n            y: end.y - margin,\n            width: width + margin * 2,\n            height: height + margin * 2,\n        },\n    };\n}\nexports.getCoordinateClipCfg = getCoordinateClipCfg;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/coordinate.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/lib/util/coordinate.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCoordinateClipCfg = exports.getAngleByPoint = exports.isPointInCoordinate = exports.getDistanceToCenter = exports.isFullCircle = exports.getXDimensionLength = void 0;\nvar graphics_1 = require(\"./graphics\");\nvar helper_1 = require(\"./helper\");\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nfunction getXDimensionLength(coordinate) {\n    if (coordinate.isPolar && !coordinate.isTransposed) {\n        // 极坐标系下 width 为弧长\n        return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n    }\n    // 直角坐标系\n    var start = coordinate.convert({ x: 0, y: 0 });\n    var end = coordinate.convert({ x: 1, y: 0 });\n    // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\nexports.getXDimensionLength = getXDimensionLength;\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nfunction isFullCircle(coordinate) {\n    if (coordinate.isPolar) {\n        var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;\n        return endAngle - startAngle === Math.PI * 2;\n    }\n    return false;\n}\nexports.isFullCircle = isFullCircle;\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nfunction getDistanceToCenter(coordinate, point) {\n    var center = coordinate.getCenter();\n    return Math.sqrt(Math.pow((point.x - center.x), 2) + Math.pow((point.y - center.y), 2));\n}\nexports.getDistanceToCenter = getDistanceToCenter;\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nfunction isPointInCoordinate(coordinate, point) {\n    var result = false;\n    if (coordinate) {\n        if (coordinate.type === 'theta') {\n            var start = coordinate.start, end = coordinate.end;\n            result = helper_1.isBetween(point.x, start.x, end.x) && helper_1.isBetween(point.y, start.y, end.y);\n        }\n        else {\n            var invertPoint = coordinate.invert(point);\n            result = helper_1.isBetween(invertPoint.x, 0, 1) && helper_1.isBetween(invertPoint.y, 0, 1);\n        }\n    }\n    return result;\n}\nexports.isPointInCoordinate = isPointInCoordinate;\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nfunction getAngleByPoint(coordinate, point) {\n    var center = coordinate.getCenter();\n    return Math.atan2(point.y - center.y, point.x - center.x);\n}\nexports.getAngleByPoint = getAngleByPoint;\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nfunction getCoordinateClipCfg(coordinate, margin) {\n    if (margin === void 0) { margin = 0; }\n    var start = coordinate.start, end = coordinate.end;\n    var width = coordinate.getWidth();\n    var height = coordinate.getHeight();\n    if (coordinate.isPolar) {\n        var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;\n        var center_1 = coordinate.getCenter();\n        var radius_1 = coordinate.getRadius();\n        return {\n            type: 'path',\n            startState: {\n                path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1),\n            },\n            endState: function (ratio) {\n                var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n                var path = graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n                return {\n                    path: path,\n                };\n            },\n            attrs: {\n                path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1),\n            },\n        };\n    }\n    var endState;\n    if (coordinate.isTransposed) {\n        endState = {\n            height: height + margin * 2,\n        };\n    }\n    else {\n        endState = {\n            width: width + margin * 2,\n        };\n    }\n    return {\n        type: 'rect',\n        startState: {\n            x: start.x - margin,\n            y: end.y - margin,\n            width: coordinate.isTransposed ? width + margin * 2 : 0,\n            height: coordinate.isTransposed ? 0 : height + margin * 2,\n        },\n        endState: endState,\n        attrs: {\n            x: start.x - margin,\n            y: end.y - margin,\n            width: width + margin * 2,\n            height: height + margin * 2,\n        },\n    };\n}\nexports.getCoordinateClipCfg = getCoordinateClipCfg;\n//# sourceMappingURL=coordinate.js.map"]}]}