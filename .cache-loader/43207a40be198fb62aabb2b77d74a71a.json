{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g-math\\lib\\ellipse.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g-math\\lib\\ellipse.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nfunction copysign(v1, v2) {\r\n    var absv = Math.abs(v1);\r\n    return v2 > 0 ? absv : absv * -1;\r\n}\r\nexports.default = {\r\n    box: function (x, y, rx, ry) {\r\n        return {\r\n            x: x - rx,\r\n            y: y - ry,\r\n            width: rx * 2,\r\n            height: ry * 2,\r\n        };\r\n    },\r\n    length: function (x, y, rx, ry) {\r\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\r\n    },\r\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\r\n        var a = rx;\r\n        var b = ry;\r\n        if (a === 0 || b === 0) {\r\n            return {\r\n                x: x,\r\n                y: y,\r\n            };\r\n        }\r\n        var relativeX = x0 - x;\r\n        var relativeY = y0 - y;\r\n        var px = Math.abs(relativeX);\r\n        var py = Math.abs(relativeY);\r\n        var squareA = a * a;\r\n        var squareB = b * b;\r\n        var t = Math.PI / 4;\r\n        var nearestX;\r\n        var nearestY;\r\n        for (var i = 0; i < 4; i++) {\r\n            nearestX = a * Math.cos(t);\r\n            nearestY = b * Math.sin(t);\r\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\r\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\r\n            var rx1 = nearestX - ex;\r\n            var ry1 = nearestY - ey;\r\n            var qx = px - ex;\r\n            var qy = py - ey;\r\n            var r = Math.hypot(ry1, rx1);\r\n            var q = Math.hypot(qy, qx);\r\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\r\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\r\n            t += delta_t;\r\n            t = Math.min(Math.PI / 2, Math.max(0, t));\r\n        }\r\n        return {\r\n            x: x + copysign(nearestX, relativeX),\r\n            y: y + copysign(nearestY, relativeY),\r\n        };\r\n    },\r\n    pointDistance: function (x, y, rx, ry, x0, y0) {\r\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\r\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\r\n    },\r\n    pointAt: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t;\r\n        return {\r\n            x: x + rx * Math.cos(angle),\r\n            y: y + ry * Math.sin(angle),\r\n        };\r\n    },\r\n    tangentAngle: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t;\r\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\r\n        return util_1.piMod(tangentAngle);\r\n    },\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g-math\\lib\\ellipse.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g-math\\lib\\ellipse.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nfunction copysign(v1, v2) {\n    var absv = Math.abs(v1);\n    return v2 > 0 ? absv : absv * -1;\n}\nexports.default = {\n    /**\n     * 包围盒计算\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {object} 包围盒\n     */\n    box: function (x, y, rx, ry) {\n        return {\n            x: x - rx,\n            y: y - ry,\n            width: rx * 2,\n            height: ry * 2,\n        };\n    },\n    /**\n     * 计算周长，使用近似法\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {number} 椭圆周长\n     */\n    length: function (x, y, rx, ry) {\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    },\n    /**\n     * 距离椭圆最近的点\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {object} 椭圆上距离指定点最近的点\n     */\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\n        var a = rx;\n        var b = ry;\n        // 假如椭圆半径为0则返回圆心\n        if (a === 0 || b === 0) {\n            return {\n                x: x,\n                y: y,\n            };\n        }\n        // 转换成 0， 0 为中心的椭圆计算\n        var relativeX = x0 - x;\n        var relativeY = y0 - y;\n        var px = Math.abs(relativeX);\n        var py = Math.abs(relativeY);\n        var squareA = a * a;\n        var squareB = b * b;\n        // const angle0 = Math.atan2(relativeY, relativeX);\n        var t = Math.PI / 4;\n        var nearestX; // 椭圆上的任一点\n        var nearestY;\n        // 迭代 4 次\n        for (var i = 0; i < 4; i++) {\n            nearestX = a * Math.cos(t);\n            nearestY = b * Math.sin(t);\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\n            var rx1 = nearestX - ex;\n            var ry1 = nearestY - ey;\n            var qx = px - ex;\n            var qy = py - ey;\n            var r = Math.hypot(ry1, rx1);\n            var q = Math.hypot(qy, qx);\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n            t += delta_t;\n            t = Math.min(Math.PI / 2, Math.max(0, t));\n        }\n        return {\n            x: x + copysign(nearestX, relativeX),\n            y: y + copysign(nearestY, relativeY),\n        };\n    },\n    /**\n     * 点到椭圆最近的距离\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {number} 点到椭圆的距离\n     */\n    pointDistance: function (x, y, rx, ry, x0, y0) {\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例，x轴方向为 0\n     * @return {object} 点\n     */\n    pointAt: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        return {\n            x: x + rx * Math.cos(angle),\n            y: y + ry * Math.sin(angle),\n        };\n    },\n    /**\n     * 根据比例计算切线角度\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n     * @return {number} 角度，在 0 - 2PI 之间\n     */\n    tangentAngle: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n        // 也可以使用指定点的切线方程计算，成本有些高\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n        // if (angle >= 0 && angle <= Math.PI) {\n        //   tangentAngle += Math.PI;\n        // }\n        return util_1.piMod(tangentAngle);\n    },\n};\n//# sourceMappingURL=ellipse.js.map"]}]}