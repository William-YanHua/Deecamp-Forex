{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/layout/distribute.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/layout/distribute.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { isObject, each, find, get } from '@antv/util';\nimport { polarToCartesian } from '../../../util/graphics';\nvar MARGIN = 4;\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n    var overlapping = true;\n    var start = plotRange.start;\n    var end = plotRange.end;\n    var startY = Math.min(start.y, end.y);\n    var totalHeight = Math.abs(start.y - end.y);\n    var i;\n    var maxY = 0;\n    var minY = Number.MIN_VALUE;\n    var boxes = labels.map(function (label) {\n        if (label.y > maxY) {\n            maxY = label.y;\n        }\n        if (label.y < minY) {\n            minY = label.y;\n        }\n        return {\n            size: lineHeight,\n            targets: [label.y - startY],\n        };\n    });\n    minY -= startY;\n    if (maxY - startY > totalHeight) {\n        totalHeight = maxY - startY;\n    }\n    while (overlapping) {\n        boxes.forEach(function (box) {\n            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n        });\n        overlapping = false;\n        i = boxes.length;\n        while (i--) {\n            if (i > 0) {\n                var previousBox = boxes[i - 1];\n                var box = boxes[i];\n                if (previousBox.pos + previousBox.size > box.pos) {\n                    previousBox.size += box.size;\n                    previousBox.targets = previousBox.targets.concat(box.targets);\n                    if (previousBox.pos + previousBox.size > totalHeight) {\n                        previousBox.pos = totalHeight - previousBox.size;\n                    }\n                    boxes.splice(i, 1);\n                    overlapping = true;\n                }\n            }\n        }\n    }\n    i = 0;\n    boxes.forEach(function (b) {\n        var posInCompositeBox = startY + lineHeight / 2;\n        b.targets.forEach(function () {\n            labels[i].y = b.pos + posInCompositeBox;\n            posInCompositeBox += lineHeight;\n            i++;\n        });\n    });\n    var labelsMap = {};\n    for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {\n        var labelShape = labelShapes_1[_i];\n        labelsMap[labelShape.get('id')] = labelShape;\n    }\n    labels.forEach(function (label) {\n        var rPow2 = label.r * label.r;\n        var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n        if (rPow2 < dyPow2) {\n            label.x = center.x;\n        }\n        else {\n            var dx = Math.sqrt(rPow2 - dyPow2);\n            if (!isRight) {\n                label.x = center.x - dx;\n            }\n            else {\n                label.x = center.x + dx;\n            }\n        }\n        var labelShape = labelsMap[label.id];\n        labelShape.attr('x', label.x);\n        labelShape.attr('y', label.y);\n        var textShape = find(labelShape.getChildren(), function (ele) { return ele.get('type') === 'text'; });\n        if (textShape) {\n            textShape.attr('y', label.y);\n            textShape.attr('x', label.x);\n        }\n    });\n}\nexport function distribute(items, labels, shapes, region) {\n    var offset = items[0] ? items[0].offset : 0;\n    var coordinate = labels[0].get('coordinate');\n    var radius = coordinate.getRadius();\n    var center = coordinate.getCenter();\n    if (offset > 0) {\n        var lineHeight_1 = 14;\n        var totalR = radius + offset;\n        var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;\n        var plotRange_1 = {\n            start: coordinate.start,\n            end: coordinate.end,\n        };\n        var halves_1 = [\n            [],\n            [],\n        ];\n        items.forEach(function (labelItem) {\n            if (!labelItem) {\n                return;\n            }\n            if (labelItem.textAlign === 'right') {\n                halves_1[0].push(labelItem);\n            }\n            else {\n                halves_1[1].push(labelItem);\n            }\n        });\n        halves_1.forEach(function (half, index) {\n            var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n            if (half.length > maxLabelsCountForOneSide) {\n                half.sort(function (a, b) {\n                    return b['..percent'] - a['..percent'];\n                });\n                half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n            }\n            half.sort(function (a, b) {\n                return a.y - b.y;\n            });\n            antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);\n        });\n    }\n    each(items, function (item) {\n        if (item && item.labelLine) {\n            var distance = item.offset;\n            var angle = item.angle;\n            var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n            var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n            var itemX = item.x + get(item, 'offsetX', 0);\n            var itemY = item.y + get(item, 'offsetY', 0);\n            var endPoint = {\n                x: itemX - Math.cos(angle) * MARGIN,\n                y: itemY - Math.sin(angle) * MARGIN,\n            };\n            if (!isObject(item.labelLine)) {\n                item.labelLine = {};\n            }\n            item.labelLine.path = [\n                \"M \" + startPoint.x,\n                startPoint.y + \" Q\" + innerPoint.x,\n                innerPoint.y + \" \" + endPoint.x,\n                endPoint.y,\n            ].join(',');\n        }\n    });\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/layout/distribute.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g2plot/node_modules/@antv/g2/esm/geometry/label/layout/distribute.js"],"names":[],"mappings":"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","sourcesContent":["import { isObject, each, find, get } from '@antv/util';\nimport { polarToCartesian } from '../../../util/graphics';\n/** label text和line距离 4px */\nvar MARGIN = 4;\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n    // adjust y position of labels to avoid overlapping\n    var overlapping = true;\n    var start = plotRange.start;\n    var end = plotRange.end;\n    var startY = Math.min(start.y, end.y);\n    var totalHeight = Math.abs(start.y - end.y);\n    var i;\n    var maxY = 0;\n    var minY = Number.MIN_VALUE;\n    var boxes = labels.map(function (label) {\n        if (label.y > maxY) {\n            maxY = label.y;\n        }\n        if (label.y < minY) {\n            minY = label.y;\n        }\n        return {\n            size: lineHeight,\n            targets: [label.y - startY],\n        };\n    });\n    minY -= startY;\n    if (maxY - startY > totalHeight) {\n        totalHeight = maxY - startY;\n    }\n    while (overlapping) {\n        /* eslint no-loop-func: 0 */\n        boxes.forEach(function (box) {\n            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n            // box.pos = Math.max(0, target - box.size / 2);\n        });\n        // detect overlapping and join boxes\n        overlapping = false;\n        i = boxes.length;\n        while (i--) {\n            if (i > 0) {\n                var previousBox = boxes[i - 1];\n                var box = boxes[i];\n                if (previousBox.pos + previousBox.size > box.pos) {\n                    // overlapping\n                    previousBox.size += box.size;\n                    previousBox.targets = previousBox.targets.concat(box.targets);\n                    // overflow, shift up\n                    if (previousBox.pos + previousBox.size > totalHeight) {\n                        previousBox.pos = totalHeight - previousBox.size;\n                    }\n                    boxes.splice(i, 1); // removing box\n                    overlapping = true;\n                }\n            }\n        }\n    }\n    i = 0;\n    // step 4: normalize y and adjust x\n    boxes.forEach(function (b) {\n        var posInCompositeBox = startY + lineHeight / 2; // middle of the label\n        b.targets.forEach(function () {\n            labels[i].y = b.pos + posInCompositeBox;\n            posInCompositeBox += lineHeight;\n            i++;\n        });\n    });\n    var labelsMap = {};\n    for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {\n        var labelShape = labelShapes_1[_i];\n        labelsMap[labelShape.get('id')] = labelShape;\n    }\n    // (x - cx)^2 + (y - cy)^2 = totalR^2\n    labels.forEach(function (label) {\n        var rPow2 = label.r * label.r;\n        var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n        if (rPow2 < dyPow2) {\n            label.x = center.x;\n        }\n        else {\n            var dx = Math.sqrt(rPow2 - dyPow2);\n            if (!isRight) {\n                // left\n                label.x = center.x - dx;\n            }\n            else {\n                // right\n                label.x = center.x + dx;\n            }\n        }\n        // adjust labelShape\n        var labelShape = labelsMap[label.id];\n        labelShape.attr('x', label.x);\n        labelShape.attr('y', label.y);\n        // because group could not effect text-shape, should set text-shape position manually\n        var textShape = find(labelShape.getChildren(), function (ele) { return ele.get('type') === 'text'; });\n        // @ts-ignore\n        if (textShape) {\n            textShape.attr('y', label.y);\n            textShape.attr('x', label.x);\n        }\n    });\n}\nexport function distribute(items, labels, shapes, region) {\n    var offset = items[0] ? items[0].offset : 0;\n    var coordinate = labels[0].get('coordinate');\n    var radius = coordinate.getRadius();\n    var center = coordinate.getCenter();\n    if (offset > 0) {\n        // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n        var lineHeight_1 = 14; // TODO\n        var totalR = radius + offset;\n        var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;\n        var plotRange_1 = {\n            start: coordinate.start,\n            end: coordinate.end,\n        };\n        // step 1: separate labels\n        var halves_1 = [\n            [],\n            [],\n        ];\n        items.forEach(function (labelItem) {\n            if (!labelItem) {\n                return;\n            }\n            if (labelItem.textAlign === 'right') {\n                // left\n                halves_1[0].push(labelItem);\n            }\n            else {\n                // right or center will be put on the right side\n                halves_1[1].push(labelItem);\n            }\n        });\n        halves_1.forEach(function (half, index) {\n            // step 2: reduce labels\n            var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n            if (half.length > maxLabelsCountForOneSide) {\n                half.sort(function (a, b) {\n                    // sort by percentage DESC\n                    return b['..percent'] - a['..percent'];\n                });\n                half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n            }\n            // step 3: distribute position (x and y)\n            half.sort(function (a, b) {\n                // sort by y ASC\n                return a.y - b.y;\n            });\n            antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);\n        });\n    }\n    // 配置 labelLine\n    each(items, function (item) {\n        if (item && item.labelLine) {\n            var distance = item.offset;\n            var angle = item.angle;\n            // 贴近圆周\n            var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n            var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n            var itemX = item.x + get(item, 'offsetX', 0);\n            var itemY = item.y + get(item, 'offsetY', 0);\n            var endPoint = {\n                x: itemX - Math.cos(angle) * MARGIN,\n                y: itemY - Math.sin(angle) * MARGIN,\n            };\n            if (!isObject(item.labelLine)) {\n                // labelLine: true\n                item.labelLine = {};\n            }\n            item.labelLine.path = [\n                \"M \" + startPoint.x,\n                startPoint.y + \" Q\" + innerPoint.x,\n                innerPoint.y + \" \" + endPoint.x,\n                endPoint.y,\n            ].join(',');\n        }\n    });\n}\n//# sourceMappingURL=distribute.js.map"]}]}