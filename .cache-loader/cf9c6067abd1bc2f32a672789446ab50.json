{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\src\\app\\api\\HttpService.ts","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\src\\app\\api\\HttpService.ts","mtime":1596379644439},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { appendQueryString, HttpMethod, NETWORK_ERROR_CODE, urlJoin } from \"./utils\";\r\nimport { Injectable } from \"react.di\";\r\nvar HttpService = (function () {\r\n    function HttpService() {\r\n        this.token = \"\";\r\n    }\r\n    HttpService.prototype.fetchRaw = function (fetchInfo) {\r\n        if (fetchInfo === void 0) { fetchInfo = {}; }\r\n        return __awaiter(this, void 0, Promise, function () {\r\n            var body, mode;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        body = fetchInfo.body\r\n                            ? { body: fetchInfo.body }\r\n                            : null;\r\n                        mode = fetchInfo.mode\r\n                            ? { mode: fetchInfo.mode }\r\n                            : {};\r\n                        return [4, fetch(appendQueryString(fetchInfo.path, fetchInfo.queryParams), __assign({ method: fetchInfo.method || HttpMethod.GET, headers: fetchInfo.headers }, mode, body))];\r\n                    case 1: return [2, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpService.prototype.fetch = function (fetchInfo) {\r\n        if (fetchInfo === void 0) { fetchInfo = {}; }\r\n        return __awaiter(this, void 0, Promise, function () {\r\n            var token, authHeader, response, content, parsedContent, e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        token = fetchInfo.token || this.token;\r\n                        authHeader = token\r\n                            ? { Authorization: \"\" + token }\r\n                            : {};\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 4, , 5]);\r\n                        return [4, this.fetchRaw(__assign({}, fetchInfo, { body: JSON.stringify(fetchInfo.body), path: urlJoin(APIROOTURL, fetchInfo.path), headers: __assign({}, authHeader, { \"Content-Type\": \"application/json\" }, fetchInfo.headers) }))];\r\n                    case 2:\r\n                        response = _a.sent();\r\n                        return [4, response.text()];\r\n                    case 3:\r\n                        content = _a.sent();\r\n                        parsedContent = content ? JSON.parse(content) : null;\r\n                        if (response.ok) {\r\n                            return [2, {\r\n                                    statusCode: response.status,\r\n                                    response: parsedContent,\r\n                                }];\r\n                        }\r\n                        else {\r\n                            throw {\r\n                                statusCode: response.status,\r\n                                info: parsedContent,\r\n                                isNetworkError: false,\r\n                                isServerError: true,\r\n                            };\r\n                        }\r\n                        return [3, 5];\r\n                    case 4:\r\n                        e_1 = _a.sent();\r\n                        if (e_1.isServerError) {\r\n                            throw e_1;\r\n                        }\r\n                        throw {\r\n                            statusCode: NETWORK_ERROR_CODE,\r\n                            info: e_1,\r\n                            isNetworkError: true,\r\n                            isServerError: false\r\n                        };\r\n                    case 5: return [2];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpService = __decorate([\r\n        Injectable\r\n    ], HttpService);\r\n    return HttpService;\r\n}());\r\nexport { HttpService };\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\src\\app\\api\\HttpService.ts","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\src\\app\\api\\HttpService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,iBAAiB,EAAE,UAAU,EAAE,kBAAkB,EAAE,OAAO,EAAE,MAAM,SAAS,CAAC;AACrF,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAgBtC;IADA;QAGE,UAAK,GAAY,EAAE,CAAC;IA0EtB,CAAC;IAxEO,8BAAQ,GAAd,UAAe,SAAyB;QAAzB,0BAAA,EAAA,cAAyB;uCAAG,OAAO;;;;;wBAC1C,IAAI,GAAG,SAAS,CAAC,IAAI;4BACzB,CAAC,CAAC,EAAC,IAAI,EAAE,SAAS,CAAC,IAAI,EAAC;4BACxB,CAAC,CAAC,IAAI,CAAC;wBAEH,IAAI,GAAG,SAAS,CAAC,IAAI;4BAC3B,CAAC,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,EAAC;4BACzB,CAAC,CAAC,EAAE,CAAC;wBAEE,WAAM,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,EAAE,SAAS,CAAC,WAAW,CAAC,aACvE,MAAM,EAAE,SAAS,CAAC,MAAM,IAAI,UAAU,CAAC,GAAG,EAC1C,OAAO,EAAE,SAAS,CAAC,OAAO,IACvB,IAAI,EACJ,IAAI,EACP,EAAA;4BALJ,WAAO,SAKH,EAAC;;;;KACN;IAUK,2BAAK,GAAX,UAAqB,SAAyB;QAAzB,0BAAA,EAAA,cAAyB;uCAAG,OAAO;;;;;wBAChD,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;wBACtC,UAAU,GAAG,KAAK;4BACtB,CAAC,CAAC,EAAC,aAAa,EAAE,KAAG,KAAO,EAAC;4BAC7B,CAAC,CAAC,EAAE,CAAC;;;;wBAEY,WAAM,IAAI,CAAC,QAAQ,cAC/B,SAAS,IACZ,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,EACpC,IAAI,EAAE,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC,EACzC,OAAO,eACF,UAAU,IACb,cAAc,EAAE,kBAAkB,IAC/B,SAAS,CAAC,OAAO,KAEtB,EAAA;;wBATI,QAAQ,GAAG,SASf;wBAEc,WAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;wBAA/B,OAAO,GAAG,SAAqB;wBAC/B,aAAa,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;wBAE3D,IAAI,QAAQ,CAAC,EAAE,EAAE;4BACf,WAAO;oCACL,UAAU,EAAE,QAAQ,CAAC,MAAM;oCAC3B,QAAQ,EAAE,aAAa;iCACxB,EAAC;yBACH;6BAAM;4BACL,MAAM;gCACJ,UAAU,EAAE,QAAQ,CAAC,MAAM;gCAC3B,IAAI,EAAE,aAAa;gCACnB,cAAc,EAAE,KAAK;gCACrB,aAAa,EAAE,IAAI;6BACJ,CAAC;yBACnB;;;;wBAGD,IAAI,GAAC,CAAC,aAAa,EAAE;4BACnB,MAAM,GAAC,CAAC;yBACT;wBACD,MAAM;4BACJ,UAAU,EAAE,kBAAkB;4BAC9B,IAAI,EAAE,GAAC;4BACP,cAAc,EAAE,IAAI;4BACpB,aAAa,EAAE,KAAK;yBACL,CAAC;;;;;KAGrB;IA3EU,WAAW;QADvB,UAAU;OACE,WAAW,CA4EvB;IAAD,kBAAC;CAAA,AA5ED,IA4EC;SA5EY,WAAW","sourcesContent":["import { appendQueryString, HttpMethod, NETWORK_ERROR_CODE, urlJoin } from \"./utils\";\r\nimport { Injectable } from \"react.di\";\r\nimport { NetworkError, NetworkResponse } from \"./NetworkResponse\";\r\n\r\nexport interface FetchInfo {\r\n  path?: string;\r\n  method?: HttpMethod;\r\n  queryParams?: any;\r\n  body?: any;\r\n  headers?: {[s: string]: string};\r\n  mode?: RequestMode;\r\n  token?: string;\r\n}\r\n\r\ndeclare var APIROOTURL: string;\r\n\r\n@Injectable\r\nexport class HttpService {\r\n\r\n  token: string  = \"\";\r\n\r\n  async fetchRaw(fetchInfo: FetchInfo = {}): Promise<Response> {\r\n    const body = fetchInfo.body\r\n      ? {body: fetchInfo.body}\r\n      : null;\r\n\r\n    const mode = fetchInfo.mode\r\n    ? { mode: fetchInfo.mode}\r\n    : {};\r\n\r\n    return await fetch(appendQueryString(fetchInfo.path, fetchInfo.queryParams), {\r\n        method: fetchInfo.method || HttpMethod.GET,\r\n        headers: fetchInfo.headers,\r\n        ...mode,\r\n        ...body,\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Execute the fetch request.\r\n   * @param fetchInfo info\r\n   * @returns If request is successful and status code is [200,300),\r\n   * returns NetworkResponse containing statusCode and response payload\r\n   * @throws If request is not successful or statusCode is >=300,\r\n   * throws NetworkError containing statusCode and error payload\r\n   */\r\n  async fetch<T = any>(fetchInfo: FetchInfo = {}): Promise<NetworkResponse<T>> {\r\n    const token = fetchInfo.token || this.token;\r\n    const authHeader = token\r\n      ? {Authorization: `${token}`}\r\n      : {};\r\n    try {\r\n      const response = await this.fetchRaw({\r\n        ...fetchInfo,\r\n        body: JSON.stringify(fetchInfo.body),\r\n        path: urlJoin(APIROOTURL, fetchInfo.path),\r\n        headers: {\r\n          ...authHeader,\r\n          \"Content-Type\": \"application/json\",\r\n          ...fetchInfo.headers,\r\n        },\r\n      });\r\n\r\n      const content = await response.text();\r\n      const parsedContent = content ? JSON.parse(content) : null;\r\n\r\n      if (response.ok) {\r\n        return {\r\n          statusCode: response.status,\r\n          response: parsedContent,\r\n        };\r\n      } else {\r\n        throw {\r\n          statusCode: response.status,\r\n          info: parsedContent,\r\n          isNetworkError: false,\r\n          isServerError: true,\r\n        } as NetworkError;\r\n      }\r\n\r\n    } catch (e) {\r\n      if (e.isServerError) {\r\n        throw e;\r\n      }\r\n      throw {\r\n        statusCode: NETWORK_ERROR_CODE,\r\n        info: e,\r\n        isNetworkError: true,\r\n        isServerError: false\r\n      } as NetworkError;\r\n    }\r\n\r\n  }\r\n}\r\n"]}]}