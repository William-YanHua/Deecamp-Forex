{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\healpix.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\healpix.js","mtime":1478025116000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { range } from \"d3-array\";\r\nimport { geoStream, geoProjectionMutator as projectionMutator } from \"d3-geo\";\r\nimport { collignonRaw } from \"./collignon\";\r\nimport { cylindricalEqualAreaRaw } from \"./cylindricalEqualArea\";\r\nimport { abs, floor, max, min, pi, radians, sqrtPi, tau } from \"./math\";\r\nvar healpixParallel = 41 + 48 / 36 + 37 / 3600, healpixLambert = cylindricalEqualAreaRaw(0);\r\nexport function healpixRaw(H) {\r\n    var phi0 = healpixParallel * radians, dx = collignonRaw(pi, phi0)[0] - collignonRaw(-pi, phi0)[0], y0 = healpixLambert(0, phi0)[1], y1 = collignonRaw(0, phi0)[1], dy1 = sqrtPi - y1, k = tau / H, w = 4 / tau, h = y0 + (dy1 * dy1 * 4) / tau;\r\n    function forward(lambda, phi) {\r\n        var point, phi2 = abs(phi);\r\n        if (phi2 > phi0) {\r\n            var i = min(H - 1, max(0, floor((lambda + pi) / k)));\r\n            lambda += pi * (H - 1) / H - i * k;\r\n            point = collignonRaw(lambda, phi2);\r\n            point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;\r\n            point[1] = y0 + (point[1] - y1) * 4 * dy1 / tau;\r\n            if (phi < 0)\r\n                point[1] = -point[1];\r\n        }\r\n        else {\r\n            point = healpixLambert(lambda, phi);\r\n        }\r\n        point[0] *= w, point[1] /= h;\r\n        return point;\r\n    }\r\n    forward.invert = function (x, y) {\r\n        x /= w, y *= h;\r\n        var y2 = abs(y);\r\n        if (y2 > y0) {\r\n            var i = min(H - 1, max(0, floor((x + pi) / k)));\r\n            x = (x + pi * (H - 1) / H - i * k) * dx / tau;\r\n            var point = collignonRaw.invert(x, 0.25 * (y2 - y0) * tau / dy1 + y1);\r\n            point[0] -= pi * (H - 1) / H - i * k;\r\n            if (y < 0)\r\n                point[1] = -point[1];\r\n            return point;\r\n        }\r\n        return healpixLambert.invert(x, y);\r\n    };\r\n    return forward;\r\n}\r\nfunction sphere(step) {\r\n    return {\r\n        type: \"Polygon\",\r\n        coordinates: [\r\n            range(-180, 180 + step / 2, step).map(function (x, i) { return [x, i & 1 ? 90 - 1e-6 : healpixParallel]; })\r\n                .concat(range(180, -180 - step / 2, -step).map(function (x, i) { return [x, i & 1 ? -90 + 1e-6 : -healpixParallel]; }))\r\n        ]\r\n    };\r\n}\r\nexport default function () {\r\n    var H = 4, m = projectionMutator(healpixRaw), p = m(H), stream_ = p.stream;\r\n    p.lobes = function (_) {\r\n        return arguments.length ? m(H = +_) : H;\r\n    };\r\n    p.stream = function (stream) {\r\n        var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\r\n        p.rotate(rotate);\r\n        rotateStream.sphere = function () { geoStream(sphere(180 / H), sphereStream); };\r\n        return rotateStream;\r\n    };\r\n    return p\r\n        .scale(239.75);\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\healpix.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\healpix.js"],"names":[],"mappings":"AAAA,OAAO,EAAC,KAAK,EAAC,MAAM,UAAU,CAAC;AAC/B,OAAO,EAAC,SAAS,EAAE,oBAAoB,IAAI,iBAAiB,EAAC,MAAM,QAAQ,CAAC;AAC5E,OAAO,EAAC,YAAY,EAAC,MAAM,aAAa,CAAC;AACzC,OAAO,EAAC,uBAAuB,EAAC,MAAM,wBAAwB,CAAC;AAC/D,OAAO,EAAC,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAC,MAAM,QAAQ,CAAC;AAEtE,IAAI,eAAe,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,EAC1C,cAAc,GAAG,uBAAuB,CAAC,CAAC,CAAC,CAAC;AAEhD,MAAM,UAAU,UAAU,CAAC,CAAC;IAC1B,IAAI,IAAI,GAAG,eAAe,GAAG,OAAO,EAChC,EAAE,GAAG,YAAY,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3D,EAAE,GAAG,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAC/B,EAAE,GAAG,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAC7B,GAAG,GAAG,MAAM,GAAG,EAAE,EACjB,CAAC,GAAG,GAAG,GAAG,CAAC,EACX,CAAC,GAAG,CAAC,GAAG,GAAG,EACX,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;IAEnC,SAAS,OAAO,CAAC,MAAM,EAAE,GAAG;QAC1B,IAAI,KAAK,EACL,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;QACpB,IAAI,IAAI,GAAG,IAAI,EAAE;YACf,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,MAAM,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACrD,MAAM,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACnC,KAAK,GAAG,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YACnC,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;YACvE,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC;YAChD,IAAI,GAAG,GAAG,CAAC;gBAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACnC;aAAM;YACL,KAAK,GAAG,cAAc,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;SACrC;QACD,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC7B,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,CAAC,MAAM,GAAG,UAAS,CAAC,EAAE,CAAC;QAC5B,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACf,IAAI,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QAChB,IAAI,EAAE,GAAG,EAAE,EAAE;YACX,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC;YAC9C,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;YACtE,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACrC,IAAI,CAAC,GAAG,CAAC;gBAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAChC,OAAO,KAAK,CAAC;SACd;QACD,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACrC,CAAC,CAAC;IAEF,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,MAAM,CAAC,IAAI;IAClB,OAAO;QACL,IAAI,EAAE,SAAS;QACf,WAAW,EAAE;YACX,KAAK,CAAC,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,UAAS,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzG,MAAM,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,UAAS,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACvH;KACF,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,OAAO;IACZ,IAAI,CAAC,GAAG,CAAC,EACL,CAAC,GAAG,iBAAiB,CAAC,UAAU,CAAC,EACjC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EACR,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC;IAEvB,CAAC,CAAC,KAAK,GAAG,UAAS,CAAC;QAClB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC,CAAC;IAEF,CAAC,CAAC,MAAM,GAAG,UAAS,MAAM;QACxB,IAAI,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE,EACnB,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,EAC9B,YAAY,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;QACvD,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjB,YAAY,CAAC,MAAM,GAAG,cAAa,SAAS,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/E,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC;IAEF,OAAO,CAAC;SACH,KAAK,CAAC,MAAM,CAAC,CAAC;AACrB,CAAC","sourcesContent":["import {range} from \"d3-array\";\nimport {geoStream, geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {collignonRaw} from \"./collignon\";\nimport {cylindricalEqualAreaRaw} from \"./cylindricalEqualArea\";\nimport {abs, floor, max, min, pi, radians, sqrtPi, tau} from \"./math\";\n\nvar healpixParallel = 41 + 48 / 36 + 37 / 3600, // for K=3; TODO automate\n    healpixLambert = cylindricalEqualAreaRaw(0);\n\nexport function healpixRaw(H) {\n  var phi0 = healpixParallel * radians,\n      dx = collignonRaw(pi, phi0)[0] - collignonRaw(-pi, phi0)[0],\n      y0 = healpixLambert(0, phi0)[1],\n      y1 = collignonRaw(0, phi0)[1],\n      dy1 = sqrtPi - y1,\n      k = tau / H,\n      w = 4 / tau,\n      h = y0 + (dy1 * dy1 * 4) / tau;\n\n  function forward(lambda, phi) {\n    var point,\n        phi2 = abs(phi);\n    if (phi2 > phi0) {\n      var i = min(H - 1, max(0, floor((lambda + pi) / k)));\n      lambda += pi * (H - 1) / H - i * k;\n      point = collignonRaw(lambda, phi2);\n      point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;\n      point[1] = y0 + (point[1] - y1) * 4 * dy1 / tau;\n      if (phi < 0) point[1] = -point[1];\n    } else {\n      point = healpixLambert(lambda, phi);\n    }\n    point[0] *= w, point[1] /= h;\n    return point;\n  }\n\n  forward.invert = function(x, y) {\n    x /= w, y *= h;\n    var y2 = abs(y);\n    if (y2 > y0) {\n      var i = min(H - 1, max(0, floor((x + pi) / k)));\n      x = (x + pi * (H - 1) / H - i * k) * dx / tau;\n      var point = collignonRaw.invert(x, 0.25 * (y2 - y0) * tau / dy1 + y1);\n      point[0] -= pi * (H - 1) / H - i * k;\n      if (y < 0) point[1] = -point[1];\n      return point;\n    }\n    return healpixLambert.invert(x, y);\n  };\n\n  return forward;\n}\n\nfunction sphere(step) {\n  return {\n    type: \"Polygon\",\n    coordinates: [\n      range(-180, 180 + step / 2, step).map(function(x, i) { return [x, i & 1 ? 90 - 1e-6 : healpixParallel]; })\n      .concat(range(180, -180 - step / 2, -step).map(function(x, i) { return [x, i & 1 ? -90 + 1e-6 : -healpixParallel]; }))\n    ]\n  };\n}\n\nexport default function() {\n  var H = 4,\n      m = projectionMutator(healpixRaw),\n      p = m(H),\n      stream_ = p.stream;\n\n  p.lobes = function(_) {\n    return arguments.length ? m(H = +_) : H;\n  };\n\n  p.stream = function(stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream));\n    p.rotate(rotate);\n    rotateStream.sphere = function() { geoStream(sphere(180 / H), sphereStream); };\n    return rotateStream;\n  };\n\n  return p\n      .scale(239.75);\n}\n"]}]}