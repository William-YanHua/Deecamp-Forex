{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js","mtime":1588443663000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { epsilon, halfPi } from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start) {\n    return function (sink) {\n        var line = clipLine(sink), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n        var clip = {\n            point: point,\n            lineStart: lineStart,\n            lineEnd: lineEnd,\n            polygonStart: function () {\n                clip.point = pointRing;\n                clip.lineStart = ringStart;\n                clip.lineEnd = ringEnd;\n                segments = [];\n                polygon = [];\n            },\n            polygonEnd: function () {\n                clip.point = point;\n                clip.lineStart = lineStart;\n                clip.lineEnd = lineEnd;\n                segments = merge(segments);\n                var startInside = polygonContains(polygon, start);\n                if (segments.length) {\n                    if (!polygonStarted)\n                        sink.polygonStart(), polygonStarted = true;\n                    clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n                }\n                else if (startInside) {\n                    if (!polygonStarted)\n                        sink.polygonStart(), polygonStarted = true;\n                    sink.lineStart();\n                    interpolate(null, null, 1, sink);\n                    sink.lineEnd();\n                }\n                if (polygonStarted)\n                    sink.polygonEnd(), polygonStarted = false;\n                segments = polygon = null;\n            },\n            sphere: function () {\n                sink.polygonStart();\n                sink.lineStart();\n                interpolate(null, null, 1, sink);\n                sink.lineEnd();\n                sink.polygonEnd();\n            }\n        };\n        function point(lambda, phi) {\n            if (pointVisible(lambda, phi))\n                sink.point(lambda, phi);\n        }\n        function pointLine(lambda, phi) {\n            line.point(lambda, phi);\n        }\n        function lineStart() {\n            clip.point = pointLine;\n            line.lineStart();\n        }\n        function lineEnd() {\n            clip.point = point;\n            line.lineEnd();\n        }\n        function pointRing(lambda, phi) {\n            ring.push([lambda, phi]);\n            ringSink.point(lambda, phi);\n        }\n        function ringStart() {\n            ringSink.lineStart();\n            ring = [];\n        }\n        function ringEnd() {\n            pointRing(ring[0][0], ring[0][1]);\n            ringSink.lineEnd();\n            var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\n            ring.pop();\n            polygon.push(ring);\n            ring = null;\n            if (!n)\n                return;\n            if (clean & 1) {\n                segment = ringSegments[0];\n                if ((m = segment.length - 1) > 0) {\n                    if (!polygonStarted)\n                        sink.polygonStart(), polygonStarted = true;\n                    sink.lineStart();\n                    for (i = 0; i < m; ++i)\n                        sink.point((point = segment[i])[0], point[1]);\n                    sink.lineEnd();\n                }\n                return;\n            }\n            if (n > 1 && clean & 2)\n                ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n            segments.push(ringSegments.filter(validSegment));\n        }\n        return clip;\n    };\n}\nfunction validSegment(segment) {\n    return segment.length > 1;\n}\nfunction compareIntersection(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n        - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js"],"names":[],"mappings":"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","sourcesContent":["import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport {epsilon, halfPi} from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n"]}]}