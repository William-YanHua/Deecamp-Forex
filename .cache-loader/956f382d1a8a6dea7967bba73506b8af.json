{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-canvas/esm/shape/base.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-canvas/esm/shape/base.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { isNil, intersectRect } from '../util/util';\nimport { applyAttrsToContext, refreshElement, getMergedRegion } from '../util/draw';\nimport { getBBoxMethod } from '@antv/g-base/lib/bbox/index';\nimport * as Shape from './index';\nimport Group from '../group';\nvar ShapeBase = (function (_super) {\n    __extends(ShapeBase, _super);\n    function ShapeBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ShapeBase.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\n    };\n    ShapeBase.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    ShapeBase.prototype.getGroupBase = function () {\n        return Group;\n    };\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    ShapeBase.prototype.calculateBBox = function () {\n        var type = this.get('type');\n        var lineWidth = this.getHitLineWidth();\n        var bboxMethod = getBBoxMethod(type);\n        var box = bboxMethod(this);\n        var halfLineWidth = lineWidth / 2;\n        var minX = box.x - halfLineWidth;\n        var minY = box.y - halfLineWidth;\n        var maxX = box.x + box.width + halfLineWidth;\n        var maxY = box.y + box.height + halfLineWidth;\n        return {\n            x: minX,\n            minX: minX,\n            y: minY,\n            minY: minY,\n            width: box.width + lineWidth,\n            height: box.height + lineWidth,\n            maxX: maxX,\n            maxY: maxY,\n        };\n    };\n    ShapeBase.prototype.isFill = function () {\n        return !!this.attrs['fill'] || this.isClipShape();\n    };\n    ShapeBase.prototype.isStroke = function () {\n        return !!this.attrs['stroke'];\n    };\n    ShapeBase.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            applyAttrsToContext(context, clip);\n            clip.createPath(context);\n            context.restore();\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    ShapeBase.prototype.draw = function (context, region) {\n        var clip = this.getClip();\n        if (region) {\n            var bbox = clip ? getMergedRegion([this, clip]) : this.getCanvasBBox();\n            if (!intersectRect(region, bbox)) {\n                this.set('hasChanged', false);\n                return;\n            }\n        }\n        context.save();\n        applyAttrsToContext(context, this);\n        this._applyClip(context, this.getClip());\n        this.drawPath(context);\n        context.restore();\n        this._afterDraw();\n    };\n    ShapeBase.prototype._afterDraw = function () {\n        var bbox = this.getCanvasBBox();\n        var canvas = this.getCanvas();\n        this.set('cacheCanvasBBox', bbox);\n        if (canvas) {\n            var viewRange = canvas.getViewRange();\n            this.set('isInView', intersectRect(bbox, viewRange));\n        }\n        this.set('hasChanged', false);\n    };\n    ShapeBase.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('isInView', null);\n        this.set('hasChanged', false);\n    };\n    ShapeBase.prototype.drawPath = function (context) {\n        this.createPath(context);\n        this.strokeAndFill(context);\n        this.afterDrawPath(context);\n    };\n    ShapeBase.prototype.fill = function (context) {\n        context.fill();\n    };\n    ShapeBase.prototype.stroke = function (context) {\n        context.stroke();\n    };\n    ShapeBase.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = strokeOpacity;\n                }\n                this.stroke(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    ShapeBase.prototype.createPath = function (context) { };\n    ShapeBase.prototype.afterDrawPath = function (context) { };\n    ShapeBase.prototype.isInShape = function (refX, refY) {\n        var isStroke = this.isStroke();\n        var isFill = this.isFill();\n        var lineWidth = this.getHitLineWidth();\n        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n    };\n    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        return false;\n    };\n    ShapeBase.prototype.getHitLineWidth = function () {\n        if (!this.isStroke()) {\n            return 0;\n        }\n        var attrs = this.attrs;\n        return attrs['lineWidth'] + attrs['lineAppendWidth'];\n    };\n    return ShapeBase;\n}(AbstractShape));\nexport default ShapeBase;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-canvas/esm/shape/base.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/g-canvas/esm/shape/base.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { isNil, intersectRect } from '../util/util';\nimport { applyAttrsToContext, refreshElement, getMergedRegion } from '../util/draw';\nimport { getBBoxMethod } from '@antv/g-base/lib/bbox/index';\nimport * as Shape from './index';\nimport Group from '../group';\nvar ShapeBase = /** @class */ (function (_super) {\n    __extends(ShapeBase, _super);\n    function ShapeBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ShapeBase.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        // 设置默认值\n        return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\n    };\n    ShapeBase.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    ShapeBase.prototype.getGroupBase = function () {\n        return Group;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    ShapeBase.prototype.calculateBBox = function () {\n        var type = this.get('type');\n        var lineWidth = this.getHitLineWidth();\n        // const attrs = this.attr();\n        var bboxMethod = getBBoxMethod(type);\n        var box = bboxMethod(this);\n        var halfLineWidth = lineWidth / 2;\n        var minX = box.x - halfLineWidth;\n        var minY = box.y - halfLineWidth;\n        var maxX = box.x + box.width + halfLineWidth;\n        var maxY = box.y + box.height + halfLineWidth;\n        return {\n            x: minX,\n            minX: minX,\n            y: minY,\n            minY: minY,\n            width: box.width + lineWidth,\n            height: box.height + lineWidth,\n            maxX: maxX,\n            maxY: maxY,\n        };\n    };\n    ShapeBase.prototype.isFill = function () {\n        return !!this.attrs['fill'] || this.isClipShape();\n    };\n    ShapeBase.prototype.isStroke = function () {\n        return !!this.attrs['stroke'];\n    };\n    // 同 shape 中的方法重复了\n    ShapeBase.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    // 绘制图形时需要考虑 region 限制\n    ShapeBase.prototype.draw = function (context, region) {\n        var clip = this.getClip();\n        // 如果指定了区域，当与指定区域相交时，才会触发渲染\n        if (region) {\n            // 是否相交需要考虑 clip 的包围盒\n            var bbox = clip ? getMergedRegion([this, clip]) : this.getCanvasBBox();\n            if (!intersectRect(region, bbox)) {\n                // 图形的包围盒与重绘区域不相交时，也需要清除标记\n                this.set('hasChanged', false);\n                return;\n            }\n        }\n        context.save();\n        // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n        applyAttrsToContext(context, this);\n        this._applyClip(context, this.getClip());\n        this.drawPath(context);\n        context.restore();\n        this._afterDraw();\n    };\n    ShapeBase.prototype._afterDraw = function () {\n        var bbox = this.getCanvasBBox();\n        var canvas = this.getCanvas();\n        // 绘制的时候缓存包围盒\n        this.set('cacheCanvasBBox', bbox);\n        if (canvas) {\n            // @ts-ignore\n            var viewRange = canvas.getViewRange();\n            this.set('isInView', intersectRect(bbox, viewRange));\n        }\n        // 绘制后消除标记\n        this.set('hasChanged', false);\n    };\n    ShapeBase.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('isInView', null);\n        this.set('hasChanged', false);\n    };\n    /**\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.drawPath = function (context) {\n        this.createPath(context);\n        this.strokeAndFill(context);\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 填充图形\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.fill = function (context) {\n        context.fill();\n    };\n    /**\n     * @protected\n     * 绘制图形边框\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.stroke = function (context) {\n        context.stroke();\n    };\n    // 绘制或者填充\n    ShapeBase.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = strokeOpacity;\n                }\n                this.stroke(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.createPath = function (context) { };\n    /**\n     * 绘制完成 path 后的操作\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.afterDrawPath = function (context) { };\n    ShapeBase.prototype.isInShape = function (refX, refY) {\n        // return HitUtil.isHitShape(this, refX, refY);\n        var isStroke = this.isStroke();\n        var isFill = this.isFill();\n        var lineWidth = this.getHitLineWidth();\n        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n    };\n    // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\n    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        return false;\n    };\n    /**\n     * 获取线拾取的宽度\n     * @returns {number} 线的拾取宽度\n     */\n    ShapeBase.prototype.getHitLineWidth = function () {\n        if (!this.isStroke()) {\n            return 0;\n        }\n        var attrs = this.attrs;\n        return attrs['lineWidth'] + attrs['lineAppendWidth'];\n    };\n    return ShapeBase;\n}(AbstractShape));\nexport default ShapeBase;\n//# sourceMappingURL=base.js.map"]}]}