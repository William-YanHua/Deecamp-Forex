{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\berghaus.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\berghaus.js","mtime":1494943454000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { geoProjectionMutator as projectionMutator, geoAzimuthalEquidistantRaw as azimuthalEquidistantRaw } from \"d3-geo\";\r\nimport { abs, acos, asin, atan, atan2, cos, degrees, halfPi, pi, radians, round, sin, sqrt, tan } from \"./math\";\r\nexport function berghausRaw(lobes) {\r\n    var k = 2 * pi / lobes;\r\n    function forward(lambda, phi) {\r\n        var p = azimuthalEquidistantRaw(lambda, phi);\r\n        if (abs(lambda) > halfPi) {\r\n            var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k * round((theta - halfPi) / k) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta));\r\n            theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\r\n            p[0] = r * cos(theta);\r\n            p[1] = r * sin(theta);\r\n        }\r\n        return p;\r\n    }\r\n    forward.invert = function (x, y) {\r\n        var r = sqrt(x * x + y * y);\r\n        if (r > halfPi) {\r\n            var theta = atan2(y, x), theta0 = k * round((theta - halfPi) / k) + halfPi, s = theta > theta0 ? -1 : 1, A = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\r\n            theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\r\n            x = r * cos(theta), y = r * sin(theta);\r\n        }\r\n        return azimuthalEquidistantRaw.invert(x, y);\r\n    };\r\n    return forward;\r\n}\r\nexport default function () {\r\n    var lobes = 5, m = projectionMutator(berghausRaw), p = m(lobes), projectionStream = p.stream, epsilon = 1e-2, cr = -cos(epsilon * radians), sr = sin(epsilon * radians);\r\n    p.lobes = function (_) {\r\n        return arguments.length ? m(lobes = +_) : lobes;\r\n    };\r\n    p.stream = function (stream) {\r\n        var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));\r\n        p.rotate(rotate);\r\n        rotateStream.sphere = function () {\r\n            sphereStream.polygonStart(), sphereStream.lineStart();\r\n            for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\r\n                sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\r\n                if (phi < -90) {\r\n                    sphereStream.point(-90, -180 - phi - epsilon);\r\n                    sphereStream.point(-90, -180 - phi + epsilon);\r\n                }\r\n                else {\r\n                    sphereStream.point(90, phi + epsilon);\r\n                    sphereStream.point(90, phi - epsilon);\r\n                }\r\n            }\r\n            sphereStream.lineEnd(), sphereStream.polygonEnd();\r\n        };\r\n        return rotateStream;\r\n    };\r\n    return p\r\n        .scale(87.8076)\r\n        .center([0, 17.1875])\r\n        .clipAngle(180 - 1e-3);\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\berghaus.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\berghaus.js"],"names":[],"mappings":"AAAA,OAAO,EAAC,oBAAoB,IAAI,iBAAiB,EAAE,0BAA0B,IAAI,uBAAuB,EAAC,MAAM,QAAQ,CAAC;AACxH,OAAO,EAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,MAAM,QAAQ,CAAC;AAE9G,MAAM,UAAU,WAAW,CAAC,KAAK;IAC/B,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK,CAAC;IAEvB,SAAS,OAAO,CAAC,MAAM,EAAE,GAAG;QAC1B,IAAI,CAAC,GAAG,uBAAuB,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAC7C,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,EAAE;YACxB,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EACzB,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EACnC,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,EACjD,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,IAAI,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YACxD,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC;YACnD,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;YACtB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;SACvB;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IAED,OAAO,CAAC,MAAM,GAAG,UAAS,CAAC,EAAE,CAAC;QAC5B,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,IAAI,CAAC,GAAG,MAAM,EAAE;YACd,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EACnB,MAAM,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,EACjD,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3B,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,EAC3B,QAAQ,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7E,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC9E,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC;SACxC;QACD,OAAO,uBAAuB,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC;IAEF,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,MAAM,CAAC,OAAO;IACZ,IAAI,KAAK,GAAG,CAAC,EACT,CAAC,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAClC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,EACZ,gBAAgB,GAAG,CAAC,CAAC,MAAM,EAC3B,OAAO,GAAG,IAAI,EACd,EAAE,GAAG,CAAC,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,EAC5B,EAAE,GAAG,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC;IAEhC,CAAC,CAAC,KAAK,GAAG,UAAS,CAAC;QAClB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAClD,CAAC,CAAC;IAEF,CAAC,CAAC,MAAM,GAAG,UAAS,MAAM;QACxB,IAAI,MAAM,GAAG,CAAC,CAAC,MAAM,EAAE,EACnB,YAAY,GAAG,gBAAgB,CAAC,MAAM,CAAC,EACvC,YAAY,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC;QAChE,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjB,YAAY,CAAC,MAAM,GAAG;YACpB,YAAY,CAAC,YAAY,EAAE,EAAE,YAAY,CAAC,SAAS,EAAE,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,GAAG,KAAK,EAAE,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,KAAK,EAAE,IAAI,GAAG,MAAM,EAAE,CAAC,GAAG,KAAK,EAAE,EAAE,CAAC,EAAE,GAAG,IAAI,KAAK,EAAE,IAAI,IAAI,MAAM,EAAE;gBACjJ,YAAY,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,GAAG,OAAO,EAAE,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;gBACxF,IAAI,GAAG,GAAG,CAAC,EAAE,EAAE;oBACb,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC;oBAC9C,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,OAAO,CAAC,CAAC;iBAC/C;qBAAM;oBACL,YAAY,CAAC,KAAK,CAAC,EAAE,EAAE,GAAG,GAAG,OAAO,CAAC,CAAC;oBACtC,YAAY,CAAC,KAAK,CAAC,EAAE,EAAE,GAAG,GAAG,OAAO,CAAC,CAAC;iBACvC;aACF;YACD,YAAY,CAAC,OAAO,EAAE,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC;QACpD,CAAC,CAAC;QACF,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC;IAEF,OAAO,CAAC;SACH,KAAK,CAAC,OAAO,CAAC;SACd,MAAM,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;SACpB,SAAS,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;AAC7B,CAAC","sourcesContent":["import {geoProjectionMutator as projectionMutator, geoAzimuthalEquidistantRaw as azimuthalEquidistantRaw} from \"d3-geo\";\nimport {abs, acos, asin, atan, atan2, cos, degrees, halfPi, pi, radians, round, sin, sqrt, tan} from \"./math\";\n\nexport function berghausRaw(lobes) {\n  var k = 2 * pi / lobes;\n\n  function forward(lambda, phi) {\n    var p = azimuthalEquidistantRaw(lambda, phi);\n    if (abs(lambda) > halfPi) { // back hemisphere\n      var theta = atan2(p[1], p[0]),\n          r = sqrt(p[0] * p[0] + p[1] * p[1]),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          alpha = atan2(sin(theta -= theta0), 2 - cos(theta)); // angle relative to lobe end\n      theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\n      p[0] = r * cos(theta);\n      p[1] = r * sin(theta);\n    }\n    return p;\n  }\n\n  forward.invert = function(x, y) {\n    var r = sqrt(x * x + y * y);\n    if (r > halfPi) {\n      var theta = atan2(y, x),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          s = theta > theta0 ? -1 : 1,\n          A = r * cos(theta0 - theta),\n          cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\n      theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\n      x = r * cos(theta), y = r * sin(theta);\n    }\n    return azimuthalEquidistantRaw.invert(x, y);\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var lobes = 5,\n      m = projectionMutator(berghausRaw),\n      p = m(lobes),\n      projectionStream = p.stream,\n      epsilon = 1e-2,\n      cr = -cos(epsilon * radians),\n      sr = sin(epsilon * radians);\n\n  p.lobes = function(_) {\n    return arguments.length ? m(lobes = +_) : lobes;\n  };\n\n  p.stream = function(stream) {\n    var rotate = p.rotate(),\n        rotateStream = projectionStream(stream),\n        sphereStream = (p.rotate([0, 0]), projectionStream(stream));\n    p.rotate(rotate);\n    rotateStream.sphere = function() {\n      sphereStream.polygonStart(), sphereStream.lineStart();\n      for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\n        sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\n        if (phi < -90) {\n          sphereStream.point(-90, -180 - phi - epsilon);\n          sphereStream.point(-90, -180 - phi + epsilon);\n        } else {\n          sphereStream.point(90, phi + epsilon);\n          sphereStream.point(90, phi - epsilon);\n        }\n      }\n      sphereStream.lineEnd(), sphereStream.polygonEnd();\n    };\n    return rotateStream;\n  };\n\n  return p\n      .scale(87.8076)\n      .center([0, 17.1875])\n      .clipAngle(180 - 1e-3);\n}\n"]}]}