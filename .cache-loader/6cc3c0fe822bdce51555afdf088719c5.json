{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\hexagon.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\hexagon.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar assign = require('@antv/util/lib/mix');\r\nvar forIn = require('@antv/util/lib/each');\r\nvar isArray = require('@antv/util/lib/type/is-array');\r\nvar registerTransform = require('../../data-set').registerTransform;\r\nvar getFields = require('../../util/option-parser').getFields;\r\nvar DEFAULT_OPTIONS = {\r\n    as: ['x', 'y', 'count'],\r\n    bins: [30, 30],\r\n    offset: [0, 0],\r\n    sizeByCount: false\r\n};\r\nvar SQRT3 = Math.sqrt(3);\r\nvar THIRD_PI = Math.PI / 3;\r\nvar ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];\r\nfunction distance(x0, y0, x1, y1) {\r\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\r\n}\r\nfunction nearestBinsCenters(value, scale, offset) {\r\n    var temp = value - offset;\r\n    scale = scale / 2;\r\n    var div = Math.floor(temp / scale);\r\n    var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\r\n    var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\r\n    return [rounded + offset, roundedScaled + offset];\r\n}\r\nfunction generateBins(points, binWidth, offset) {\r\n    if (binWidth === void 0) { binWidth = [1, 1]; }\r\n    if (offset === void 0) { offset = [0, 0]; }\r\n    var bins = {};\r\n    var _a = __read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];\r\n    var _b = __read(offset, 2), offsetX = _b[0], offsetY = _b[1];\r\n    points.forEach(function (point) {\r\n        var _a, _b;\r\n        var _c = __read(point, 2), x = _c[0], y = _c[1];\r\n        var _d = __read(nearestBinsCenters(x, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];\r\n        var _e = __read(nearestBinsCenters(y, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];\r\n        var d1 = distance(x, y, xRounded, yRounded);\r\n        var d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\r\n        var binKey;\r\n        var binX;\r\n        var binY;\r\n        if (d1 < d2) {\r\n            binKey = \"x\" + xRounded + \"y\" + yRounded;\r\n            _a = __read([xRounded, yRounded], 2), binX = _a[0], binY = _a[1];\r\n        }\r\n        else {\r\n            binKey = \"x\" + xRoundedScaled + \"y\" + yRoundedScaled;\r\n            _b = __read([xRoundedScaled, yRoundedScaled], 2), binX = _b[0], binY = _b[1];\r\n        }\r\n        bins[binKey] = bins[binKey] || {\r\n            x: binX,\r\n            y: binY,\r\n            count: 0\r\n        };\r\n        bins[binKey].count++;\r\n    });\r\n    return bins;\r\n}\r\nfunction transform(dataView, options) {\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var fields = getFields(options);\r\n    if (!isArray(fields) || fields.length !== 2) {\r\n        throw new TypeError('Invalid fields: it must be an array with 2 strings!');\r\n    }\r\n    var _a = __read(fields, 2), fieldX = _a[0], fieldY = _a[1];\r\n    var rangeFieldX = dataView.range(fieldX);\r\n    var rangeFieldY = dataView.range(fieldY);\r\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\r\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\r\n    var binWidth = options.binWidth || [];\r\n    if (binWidth.length !== 2) {\r\n        var _b = __read(options.bins, 2), binsX = _b[0], binsY = _b[1];\r\n        if (binsX <= 0 || binsY <= 0) {\r\n            throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\r\n        }\r\n        binWidth = [widthX / binsX, widthY / binsY];\r\n    }\r\n    var _c = __read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\r\n    var yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);\r\n    var points = dataView.rows.map(function (row) { return [row[fieldX], yScale * row[fieldY]]; });\r\n    var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);\r\n    var _d = __read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\r\n    if (!asX || !asY || !asCount) {\r\n        throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\r\n    }\r\n    var radius = binWidth[0] / SQRT3;\r\n    var hexagonPoints = ANGLES.map(function (angle) { return [Math.sin(angle) * radius, -Math.cos(angle) * radius]; });\r\n    var result = [];\r\n    var maxCount = 0;\r\n    if (options.sizeByCount) {\r\n        forIn(bins, function (bin) {\r\n            if (bin.count > maxCount) {\r\n                maxCount = bin.count;\r\n            }\r\n        });\r\n    }\r\n    forIn(bins, function (bin) {\r\n        var x = bin.x, y = bin.y, count = bin.count;\r\n        var row = {};\r\n        row[asCount] = count;\r\n        if (options.sizeByCount) {\r\n            row[asX] = hexagonPoints.map(function (p) { return x + (bin.count / maxCount) * p[0]; });\r\n            row[asY] = hexagonPoints.map(function (p) { return (y + (bin.count / maxCount) * p[1]) / yScale; });\r\n        }\r\n        else {\r\n            row[asX] = hexagonPoints.map(function (p) { return x + p[0]; });\r\n            row[asY] = hexagonPoints.map(function (p) { return (y + p[1]) / yScale; });\r\n        }\r\n        result.push(row);\r\n    });\r\n    dataView.rows = result;\r\n}\r\nregisterTransform('bin.hexagon', transform);\r\nregisterTransform('bin.hex', transform);\r\nregisterTransform('hexbin', transform);\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\hexagon.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\bin\\hexagon.js"],"names":[],"mappings":"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","sourcesContent":["const assign = require('@antv/util/lib/mix');\nconst forIn = require('@antv/util/lib/each');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y', 'count' ],\n  bins: [ 30, 30 ], // Numeric vector giving number of bins in both horizontal and vertical directions\n  offset: [ 0, 0 ],\n  sizeByCount: false // calculate bin size by binning count\n  // fields: ['field0', 'field1'], // required\n  // binWidth: [ 30, 30 ], // Numeric vector giving bin width in both horizontal and vertical directions. Overrides bins if both set.\n};\nconst SQRT3 = Math.sqrt(3);\nconst THIRD_PI = Math.PI / 3;\nconst ANGLES = [ 0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI ];\n\nfunction distance(x0, y0, x1, y1) {\n  return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\n}\nfunction nearestBinsCenters(value, scale, offset) {\n  const temp = value - offset;\n  scale = scale / 2;\n  const div = Math.floor(temp / scale);\n  const rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\n  const roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\n  return [ rounded + offset, roundedScaled + offset ];\n}\nfunction generateBins(points, binWidth = [ 1, 1 ], offset = [ 0, 0 ]) { // processing aligned data\n  const bins = {};\n  const [ binWidthX, binWidthY ] = binWidth;\n  const [ offsetX, offsetY ] = offset;\n  points.forEach(point => {\n    const [ x, y ] = point;\n    // step3.1: nearest two centers\n    const [ xRounded, xRoundedScaled ] = nearestBinsCenters(x, binWidthX, offsetX);\n    const [ yRounded, yRoundedScaled ] = nearestBinsCenters(y, binWidthY, offsetY);\n    // step3.2: compare distances\n    const d1 = distance(x, y, xRounded, yRounded);\n    const d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\n    let binKey;\n    let binX;\n    let binY;\n\n    if (d1 < d2) {\n      binKey = `x${xRounded}y${yRounded}`;\n      [ binX, binY ] = [ xRounded, yRounded ];\n    } else {\n      binKey = `x${xRoundedScaled}y${yRoundedScaled}`;\n      [ binX, binY ] = [ xRoundedScaled, yRoundedScaled ];\n    }\n    bins[binKey] = bins[binKey] || {\n      x: binX,\n      y: binY,\n      count: 0\n    };\n    bins[binKey].count ++;\n  });\n  return bins;\n}\n\nfunction transform(dataView, options) {\n  // step1: get binWidth, etc.\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length !== 2) {\n    throw new TypeError('Invalid fields: it must be an array with 2 strings!');\n  }\n  const [ fieldX, fieldY ] = fields;\n  const rangeFieldX = dataView.range(fieldX);\n  const rangeFieldY = dataView.range(fieldY);\n  const widthX = rangeFieldX[1] - rangeFieldX[0];\n  const widthY = rangeFieldY[1] - rangeFieldY[0];\n  let binWidth = options.binWidth || [];\n  if (binWidth.length !== 2) {\n    const [ binsX, binsY ] = options.bins;\n    if (binsX <= 0 || binsY <= 0) {\n      throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\n    }\n    binWidth = [ widthX / binsX, widthY / binsY ];\n  }\n  // step2: align scale (squash Y)\n  /*\n   * binWidthX / binWidthY should be Math.sqrt3 / 1.5\n   * -: binWidthX |: binWidthY\n   *           3\n   *           |\n   *   4       |        2\n   *           |\n   *           |\n   *   5----------------1\n   *\n   *           0\n   */\n  const [ offsetX, offsetY ] = options.offset;\n  const yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);\n  // const yScale = binWidth[0] / (SQRT3 * binWidth[1]);\n  const points = dataView.rows.map(row => [ row[fieldX], yScale * row[fieldY] ]);\n  // step3: binning\n  const bins = generateBins(points, [ binWidth[0], yScale * binWidth[1] ], [ offsetX, yScale * offsetY ]);\n  // step4: restore scale (for Y)\n  const [ asX, asY, asCount ] = options.as;\n  if (!asX || !asY || !asCount) {\n    throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\n  }\n  const radius = binWidth[0] / SQRT3;\n  const hexagonPoints = ANGLES.map(angle => [ Math.sin(angle) * radius, -Math.cos(angle) * radius ]);\n  const result = [];\n  let maxCount = 0;\n  if (options.sizeByCount) {\n    forIn(bins, bin => {\n      if (bin.count > maxCount) {\n        maxCount = bin.count;\n      }\n    });\n  }\n  forIn(bins, bin => {\n    const { x, y, count } = bin;\n    const row = {};\n    row[asCount] = count;\n    if (options.sizeByCount) {\n      row[asX] = hexagonPoints.map(p => x + (bin.count / maxCount) * p[0]);\n      row[asY] = hexagonPoints.map(p => (y + (bin.count / maxCount) * p[1]) / yScale);\n    } else {\n      row[asX] = hexagonPoints.map(p => x + p[0]);\n      row[asY] = hexagonPoints.map(p => (y + p[1]) / yScale);\n    }\n    result.push(row);\n  });\n\n  dataView.rows = result;\n}\n\nregisterTransform('bin.hexagon', transform);\nregisterTransform('bin.hex', transform);\nregisterTransform('hexbin', transform);\n"]}]}