{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\path-util\\lib\\is-polygons-intersect.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\path-util\\lib\\is-polygons-intersect.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar point_in_polygon_1 = require(\"./point-in-polygon\");\r\nvar get_line_intersect_1 = require(\"./get-line-intersect\");\r\nvar util_1 = require(\"@antv/util\");\r\nfunction parseToLines(points) {\r\n    var lines = [];\r\n    var count = points.length;\r\n    for (var i = 0; i < count - 1; i++) {\r\n        var point = points[i];\r\n        var next = points[i + 1];\r\n        lines.push({\r\n            from: {\r\n                x: point[0],\r\n                y: point[1]\r\n            },\r\n            to: {\r\n                x: next[0],\r\n                y: next[1]\r\n            }\r\n        });\r\n    }\r\n    if (lines.length > 1) {\r\n        var first = points[0];\r\n        var last = points[count - 1];\r\n        lines.push({\r\n            from: {\r\n                x: last[0],\r\n                y: last[1]\r\n            },\r\n            to: {\r\n                x: first[0],\r\n                y: first[1]\r\n            }\r\n        });\r\n    }\r\n    return lines;\r\n}\r\nfunction lineIntersectPolygon(lines, line) {\r\n    var isIntersect = false;\r\n    util_1.each(lines, function (l) {\r\n        if (get_line_intersect_1.default(l.from, l.to, line.from, line.to)) {\r\n            isIntersect = true;\r\n            return false;\r\n        }\r\n    });\r\n    return isIntersect;\r\n}\r\nfunction getBBox(points) {\r\n    var xArr = points.map(function (p) { return p[0]; });\r\n    var yArr = points.map(function (p) { return p[1]; });\r\n    return {\r\n        minX: Math.min.apply(null, xArr),\r\n        maxX: Math.max.apply(null, xArr),\r\n        minY: Math.min.apply(null, yArr),\r\n        maxY: Math.max.apply(null, yArr)\r\n    };\r\n}\r\nfunction intersectBBox(box1, box2) {\r\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\r\n}\r\nfunction isPolygonsIntersect(points1, points2) {\r\n    if (points1.length < 2 || points2.length < 2) {\r\n        return false;\r\n    }\r\n    var bbox1 = getBBox(points1);\r\n    var bbox2 = getBBox(points2);\r\n    if (!intersectBBox(bbox1, bbox2)) {\r\n        return false;\r\n    }\r\n    var isIn = false;\r\n    util_1.each(points2, function (point) {\r\n        if (point_in_polygon_1.default(points1, point[0], point[1])) {\r\n            isIn = true;\r\n            return false;\r\n        }\r\n    });\r\n    if (isIn) {\r\n        return true;\r\n    }\r\n    util_1.each(points1, function (point) {\r\n        if (point_in_polygon_1.default(points2, point[0], point[1])) {\r\n            isIn = true;\r\n            return false;\r\n        }\r\n    });\r\n    if (isIn) {\r\n        return true;\r\n    }\r\n    var lines1 = parseToLines(points1);\r\n    var lines2 = parseToLines(points2);\r\n    var isIntersect = false;\r\n    util_1.each(lines2, function (line) {\r\n        if (lineIntersectPolygon(lines1, line)) {\r\n            isIntersect = true;\r\n            return false;\r\n        }\r\n    });\r\n    return isIntersect;\r\n}\r\nexports.default = isPolygonsIntersect;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\path-util\\lib\\is-polygons-intersect.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\path-util\\lib\\is-polygons-intersect.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar point_in_polygon_1 = require(\"./point-in-polygon\");\nvar get_line_intersect_1 = require(\"./get-line-intersect\");\nvar util_1 = require(\"@antv/util\");\nfunction parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n    for (var i = 0; i < count - 1; i++) {\n        var point = points[i];\n        var next = points[i + 1];\n        lines.push({\n            from: {\n                x: point[0],\n                y: point[1]\n            },\n            to: {\n                x: next[0],\n                y: next[1]\n            }\n        });\n    }\n    if (lines.length > 1) {\n        var first = points[0];\n        var last = points[count - 1];\n        lines.push({\n            from: {\n                x: last[0],\n                y: last[1]\n            },\n            to: {\n                x: first[0],\n                y: first[1]\n            }\n        });\n    }\n    return lines;\n}\nfunction lineIntersectPolygon(lines, line) {\n    var isIntersect = false;\n    util_1.each(lines, function (l) {\n        if (get_line_intersect_1.default(l.from, l.to, line.from, line.to)) {\n            isIntersect = true;\n            return false;\n        }\n    });\n    return isIntersect;\n}\nfunction getBBox(points) {\n    var xArr = points.map(function (p) { return p[0]; });\n    var yArr = points.map(function (p) { return p[1]; });\n    return {\n        minX: Math.min.apply(null, xArr),\n        maxX: Math.max.apply(null, xArr),\n        minY: Math.min.apply(null, yArr),\n        maxY: Math.max.apply(null, yArr)\n    };\n}\nfunction intersectBBox(box1, box2) {\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\nfunction isPolygonsIntersect(points1, points2) {\n    // 空数组，或者一个点返回 false\n    if (points1.length < 2 || points2.length < 2) {\n        return false;\n    }\n    var bbox1 = getBBox(points1);\n    var bbox2 = getBBox(points2);\n    // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n    if (!intersectBBox(bbox1, bbox2)) {\n        return false;\n    }\n    var isIn = false;\n    // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n    util_1.each(points2, function (point) {\n        if (point_in_polygon_1.default(points1, point[0], point[1])) {\n            isIn = true;\n            return false;\n        }\n    });\n    if (isIn) {\n        return true;\n    }\n    // 两个多边形都需要判定\n    util_1.each(points1, function (point) {\n        if (point_in_polygon_1.default(points2, point[0], point[1])) {\n            isIn = true;\n            return false;\n        }\n    });\n    if (isIn) {\n        return true;\n    }\n    var lines1 = parseToLines(points1);\n    var lines2 = parseToLines(points2);\n    var isIntersect = false;\n    util_1.each(lines2, function (line) {\n        if (lineIntersectPolygon(lines1, line)) {\n            isIntersect = true;\n            return false;\n        }\n    });\n    return isIntersect;\n}\nexports.default = isPolygonsIntersect;\n//# sourceMappingURL=is-polygons-intersect.js.map"]}]}