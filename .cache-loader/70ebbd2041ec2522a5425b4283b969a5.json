{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\position\\bk.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\position\\bk.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["\"use strict\";\r\nvar _ = require(\"../lodash\"), Graph = require(\"../graphlib\").Graph, util = require(\"../util\");\r\nmodule.exports = {\r\n    positionX: positionX,\r\n    findType1Conflicts: findType1Conflicts,\r\n    findType2Conflicts: findType2Conflicts,\r\n    addConflict: addConflict,\r\n    hasConflict: hasConflict,\r\n    verticalAlignment: verticalAlignment,\r\n    horizontalCompaction: horizontalCompaction,\r\n    alignCoordinates: alignCoordinates,\r\n    findSmallestWidthAlignment: findSmallestWidthAlignment,\r\n    balance: balance\r\n};\r\nfunction findType1Conflicts(g, layering) {\r\n    var conflicts = {};\r\n    function visitLayer(prevLayer, layer) {\r\n        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _.last(layer);\r\n        _.forEach(layer, function (v, i) {\r\n            var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;\r\n            if (w || v === lastNode) {\r\n                _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\r\n                    _.forEach(g.predecessors(scanNode), function (u) {\r\n                        var uLabel = g.node(u), uPos = uLabel.order;\r\n                        if ((uPos < k0 || k1 < uPos) &&\r\n                            !(uLabel.dummy && g.node(scanNode).dummy)) {\r\n                            addConflict(conflicts, u, scanNode);\r\n                        }\r\n                    });\r\n                });\r\n                scanPos = i + 1;\r\n                k0 = k1;\r\n            }\r\n        });\r\n        return layer;\r\n    }\r\n    _.reduce(layering, visitLayer);\r\n    return conflicts;\r\n}\r\nfunction findType2Conflicts(g, layering) {\r\n    var conflicts = {};\r\n    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\r\n        var v;\r\n        _.forEach(_.range(southPos, southEnd), function (i) {\r\n            v = south[i];\r\n            if (g.node(v).dummy) {\r\n                _.forEach(g.predecessors(v), function (u) {\r\n                    var uNode = g.node(u);\r\n                    if (uNode.dummy &&\r\n                        (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\r\n                        addConflict(conflicts, u, v);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    function visitLayer(north, south) {\r\n        var prevNorthPos = -1, nextNorthPos, southPos = 0;\r\n        _.forEach(south, function (v, southLookahead) {\r\n            if (g.node(v).dummy === \"border\") {\r\n                var predecessors = g.predecessors(v);\r\n                if (predecessors.length) {\r\n                    nextNorthPos = g.node(predecessors[0]).order;\r\n                    scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\r\n                    southPos = southLookahead;\r\n                    prevNorthPos = nextNorthPos;\r\n                }\r\n            }\r\n            scan(south, southPos, south.length, nextNorthPos, north.length);\r\n        });\r\n        return south;\r\n    }\r\n    _.reduce(layering, visitLayer);\r\n    return conflicts;\r\n}\r\nfunction findOtherInnerSegmentNode(g, v) {\r\n    if (g.node(v).dummy) {\r\n        return _.find(g.predecessors(v), function (u) {\r\n            return g.node(u).dummy;\r\n        });\r\n    }\r\n}\r\nfunction addConflict(conflicts, v, w) {\r\n    if (v > w) {\r\n        var tmp = v;\r\n        v = w;\r\n        w = tmp;\r\n    }\r\n    var conflictsV = conflicts[v];\r\n    if (!conflictsV) {\r\n        conflicts[v] = conflictsV = {};\r\n    }\r\n    conflictsV[w] = true;\r\n}\r\nfunction hasConflict(conflicts, v, w) {\r\n    if (v > w) {\r\n        var tmp = v;\r\n        v = w;\r\n        w = tmp;\r\n    }\r\n    return _.has(conflicts[v], w);\r\n}\r\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\r\n    var root = {}, align = {}, pos = {};\r\n    _.forEach(layering, function (layer) {\r\n        _.forEach(layer, function (v, order) {\r\n            root[v] = v;\r\n            align[v] = v;\r\n            pos[v] = order;\r\n        });\r\n    });\r\n    _.forEach(layering, function (layer) {\r\n        var prevIdx = -1;\r\n        _.forEach(layer, function (v) {\r\n            var ws = neighborFn(v);\r\n            if (ws.length) {\r\n                ws = _.sortBy(ws, function (w) { return pos[w]; });\r\n                var mp = (ws.length - 1) / 2;\r\n                for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\r\n                    var w = ws[i];\r\n                    if (align[v] === v &&\r\n                        prevIdx < pos[w] &&\r\n                        !hasConflict(conflicts, v, w)) {\r\n                        align[w] = v;\r\n                        align[v] = root[v] = root[w];\r\n                        prevIdx = pos[w];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return { root: root, align: align };\r\n}\r\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\r\n    var xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\r\n    function iterate(setXsFunc, nextNodesFunc) {\r\n        var stack = blockG.nodes();\r\n        var elem = stack.pop();\r\n        var visited = {};\r\n        while (elem) {\r\n            if (visited[elem]) {\r\n                setXsFunc(elem);\r\n            }\r\n            else {\r\n                visited[elem] = true;\r\n                stack.push(elem);\r\n                stack = stack.concat(nextNodesFunc(elem));\r\n            }\r\n            elem = stack.pop();\r\n        }\r\n    }\r\n    function pass1(elem) {\r\n        xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {\r\n            return Math.max(acc, xs[e.v] + blockG.edge(e));\r\n        }, 0);\r\n    }\r\n    function pass2(elem) {\r\n        var min = blockG.outEdges(elem).reduce(function (acc, e) {\r\n            return Math.min(acc, xs[e.w] - blockG.edge(e));\r\n        }, Number.POSITIVE_INFINITY);\r\n        var node = g.node(elem);\r\n        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\r\n            xs[elem] = Math.max(xs[elem], min);\r\n        }\r\n    }\r\n    iterate(pass1, _.bind(blockG.predecessors, blockG));\r\n    iterate(pass2, _.bind(blockG.successors, blockG));\r\n    _.forEach(align, function (v) {\r\n        xs[v] = xs[root[v]];\r\n    });\r\n    return xs;\r\n}\r\nfunction buildBlockGraph(g, layering, root, reverseSep) {\r\n    var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\r\n    _.forEach(layering, function (layer) {\r\n        var u;\r\n        _.forEach(layer, function (v) {\r\n            var vRoot = root[v];\r\n            blockGraph.setNode(vRoot);\r\n            if (u) {\r\n                var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);\r\n                blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\r\n            }\r\n            u = v;\r\n        });\r\n    });\r\n    return blockGraph;\r\n}\r\nfunction findSmallestWidthAlignment(g, xss) {\r\n    return _.minBy(_.values(xss), function (xs) {\r\n        var max = Number.NEGATIVE_INFINITY;\r\n        var min = Number.POSITIVE_INFINITY;\r\n        _.forIn(xs, function (x, v) {\r\n            var halfWidth = width(g, v) / 2;\r\n            max = Math.max(x + halfWidth, max);\r\n            min = Math.min(x - halfWidth, min);\r\n        });\r\n        return max - min;\r\n    });\r\n}\r\nfunction alignCoordinates(xss, alignTo) {\r\n    var alignToVals = _.values(alignTo), alignToMin = _.min(alignToVals), alignToMax = _.max(alignToVals);\r\n    _.forEach([\"u\", \"d\"], function (vert) {\r\n        _.forEach([\"l\", \"r\"], function (horiz) {\r\n            var alignment = vert + horiz, xs = xss[alignment], delta;\r\n            if (xs === alignTo)\r\n                return;\r\n            var xsVals = _.values(xs);\r\n            delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\r\n            if (delta) {\r\n                xss[alignment] = _.mapValues(xs, function (x) { return x + delta; });\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction balance(xss, align) {\r\n    return _.mapValues(xss.ul, function (ignore, v) {\r\n        if (align) {\r\n            return xss[align.toLowerCase()][v];\r\n        }\r\n        else {\r\n            var xs = _.sortBy(_.map(xss, v));\r\n            return (xs[1] + xs[2]) / 2;\r\n        }\r\n    });\r\n}\r\nfunction positionX(g) {\r\n    var layering = util.buildLayerMatrix(g), conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));\r\n    var xss = {}, adjustedLayering;\r\n    _.forEach([\"u\", \"d\"], function (vert) {\r\n        adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\r\n        _.forEach([\"l\", \"r\"], function (horiz) {\r\n            if (horiz === \"r\") {\r\n                adjustedLayering = _.map(adjustedLayering, function (inner) {\r\n                    return _.values(inner).reverse();\r\n                });\r\n            }\r\n            var neighborFn = _.bind(vert === \"u\" ? g.predecessors : g.successors, g);\r\n            var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\r\n            var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === \"r\");\r\n            if (horiz === \"r\") {\r\n                xs = _.mapValues(xs, function (x) { return -x; });\r\n            }\r\n            xss[vert + horiz] = xs;\r\n        });\r\n    });\r\n    var smallestWidth = findSmallestWidthAlignment(g, xss);\r\n    alignCoordinates(xss, smallestWidth);\r\n    return balance(xss, g.graph().align);\r\n}\r\nfunction sep(nodeSep, edgeSep, reverseSep) {\r\n    return function (g, v, w) {\r\n        var vLabel = g.node(v), wLabel = g.node(w), sum = 0, delta;\r\n        sum += vLabel.width / 2;\r\n        if (_.has(vLabel, \"labelpos\")) {\r\n            switch (vLabel.labelpos.toLowerCase()) {\r\n                case \"l\":\r\n                    delta = -vLabel.width / 2;\r\n                    break;\r\n                case \"r\":\r\n                    delta = vLabel.width / 2;\r\n                    break;\r\n            }\r\n        }\r\n        if (delta) {\r\n            sum += reverseSep ? delta : -delta;\r\n        }\r\n        delta = 0;\r\n        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\r\n        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\r\n        sum += wLabel.width / 2;\r\n        if (_.has(wLabel, \"labelpos\")) {\r\n            switch (wLabel.labelpos.toLowerCase()) {\r\n                case \"l\":\r\n                    delta = wLabel.width / 2;\r\n                    break;\r\n                case \"r\":\r\n                    delta = -wLabel.width / 2;\r\n                    break;\r\n            }\r\n        }\r\n        if (delta) {\r\n            sum += reverseSep ? delta : -delta;\r\n        }\r\n        delta = 0;\r\n        return sum;\r\n    };\r\n}\r\nfunction width(g, v) {\r\n    return g.node(v).width;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\position\\bk.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\position\\bk.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\"),\n    Graph = require(\"../graphlib\").Graph,\n    util = require(\"../util\");\n\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var\n      // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function(v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n          k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\n          _.forEach(g.predecessors(scanNode), function(u) {\n            var uLabel = g.node(u),\n                uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) &&\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function(i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function(u) {\n          var uNode = g.node(u);\n          if (uNode.dummy &&\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n        nextNorthPos,\n        southPos = 0;\n\n    _.forEach(south, function(v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function(u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n      align = {},\n      pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function(layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function(v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v &&\n              prevIdx < pos[w] &&\n              !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n      blockG = buildBlockGraph(g, layering, root, reverseSep),\n      borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, _.bind(blockG.predecessors, blockG));\n  iterate(pass2, _.bind(blockG.successors, blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function(v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n      graphLabel = g.graph(),\n      sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function(layer) {\n    var u;\n    _.forEach(layer, function(v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n            prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n      alignToMin = _.min(alignToVals),\n      alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function(vert) {\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      var alignment = vert + horiz,\n          xs = xss[alignment],\n          delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function(ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g),\n      conflicts = _.merge(findType1Conflicts(g, layering),\n                          findType2Conflicts(g, layering));\n\n  var xss = {},\n      adjustedLayering;\n  _.forEach([\"u\", \"d\"], function(vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = _.bind(vert === \"u\" ? g.predecessors : g.successors, g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering,\n                                    align.root, align.align,\n                                    horiz === \"r\");\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function(x) { return -x; });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function(g, v, w) {\n    var vLabel = g.node(v),\n        wLabel = g.node(w),\n        sum = 0,\n        delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case \"l\": delta = -vLabel.width / 2; break;\n        case \"r\": delta = vLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case \"l\": delta = wLabel.width / 2; break;\n        case \"r\": delta = -wLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n"]}]}