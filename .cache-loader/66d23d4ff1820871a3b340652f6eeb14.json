{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\non-layered-tidy.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\non-layered-tidy.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["function WrappedTree(w, h, y, c) {\r\n    if (c === void 0) {\r\n        c = [];\r\n    }\r\n    var me = this;\r\n    me.w = w || 0;\r\n    me.h = h || 0;\r\n    me.y = y || 0;\r\n    me.x = 0;\r\n    me.c = c || [];\r\n    me.cs = c.length;\r\n    me.prelim = 0;\r\n    me.mod = 0;\r\n    me.shift = 0;\r\n    me.change = 0;\r\n    me.tl = null;\r\n    me.tr = null;\r\n    me.el = null;\r\n    me.er = null;\r\n    me.msel = 0;\r\n    me.mser = 0;\r\n}\r\nWrappedTree.fromNode = function (root, isHorizontal) {\r\n    if (!root)\r\n        return null;\r\n    var children = [];\r\n    root.children.forEach(function (child) {\r\n        children.push(WrappedTree.fromNode(child, isHorizontal));\r\n    });\r\n    if (isHorizontal)\r\n        return new WrappedTree(root.height, root.width, root.x, children);\r\n    return new WrappedTree(root.width, root.height, root.y, children);\r\n};\r\nfunction moveRight(node, move, isHorizontal) {\r\n    if (isHorizontal) {\r\n        node.y += move;\r\n    }\r\n    else {\r\n        node.x += move;\r\n    }\r\n    node.children.forEach(function (child) {\r\n        moveRight(child, move, isHorizontal);\r\n    });\r\n}\r\nfunction getMin(node, isHorizontal) {\r\n    var res = isHorizontal ? node.y : node.x;\r\n    node.children.forEach(function (child) {\r\n        res = Math.min(getMin(child, isHorizontal), res);\r\n    });\r\n    return res;\r\n}\r\nfunction normalize(node, isHorizontal) {\r\n    var min = getMin(node, isHorizontal);\r\n    moveRight(node, -min, isHorizontal);\r\n}\r\nfunction convertBack(converted, root, isHorizontal) {\r\n    if (isHorizontal) {\r\n        root.y = converted.x;\r\n    }\r\n    else {\r\n        root.x = converted.x;\r\n    }\r\n    converted.c.forEach(function (child, i) {\r\n        convertBack(child, root.children[i], isHorizontal);\r\n    });\r\n}\r\nfunction layer(node, isHorizontal, d) {\r\n    if (d === void 0) {\r\n        d = 0;\r\n    }\r\n    if (isHorizontal) {\r\n        node.x = d;\r\n        d += node.width;\r\n    }\r\n    else {\r\n        node.y = d;\r\n        d += node.height;\r\n    }\r\n    node.children.forEach(function (child) {\r\n        layer(child, isHorizontal, d);\r\n    });\r\n}\r\nmodule.exports = function (root, options) {\r\n    if (options === void 0) {\r\n        options = {};\r\n    }\r\n    var isHorizontal = options.isHorizontal;\r\n    function firstWalk(t) {\r\n        if (t.cs === 0) {\r\n            setExtremes(t);\r\n            return;\r\n        }\r\n        firstWalk(t.c[0]);\r\n        var ih = updateIYL(bottom(t.c[0].el), 0, null);\r\n        for (var i = 1; i < t.cs; ++i) {\r\n            firstWalk(t.c[i]);\r\n            var min = bottom(t.c[i].er);\r\n            separate(t, i, ih);\r\n            ih = updateIYL(min, i, ih);\r\n        }\r\n        positionRoot(t);\r\n        setExtremes(t);\r\n    }\r\n    function setExtremes(t) {\r\n        if (t.cs === 0) {\r\n            t.el = t;\r\n            t.er = t;\r\n            t.msel = t.mser = 0;\r\n        }\r\n        else {\r\n            t.el = t.c[0].el;\r\n            t.msel = t.c[0].msel;\r\n            t.er = t.c[t.cs - 1].er;\r\n            t.mser = t.c[t.cs - 1].mser;\r\n        }\r\n    }\r\n    function separate(t, i, ih) {\r\n        var sr = t.c[i - 1];\r\n        var mssr = sr.mod;\r\n        var cl = t.c[i];\r\n        var mscl = cl.mod;\r\n        while (sr !== null && cl !== null) {\r\n            if (bottom(sr) > ih.low)\r\n                ih = ih.nxt;\r\n            var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\r\n            if (dist > 0) {\r\n                mscl += dist;\r\n                moveSubtree(t, i, ih.index, dist);\r\n            }\r\n            var sy = bottom(sr);\r\n            var cy = bottom(cl);\r\n            if (sy <= cy) {\r\n                sr = nextRightContour(sr);\r\n                if (sr !== null)\r\n                    mssr += sr.mod;\r\n            }\r\n            if (sy >= cy) {\r\n                cl = nextLeftContour(cl);\r\n                if (cl !== null)\r\n                    mscl += cl.mod;\r\n            }\r\n        }\r\n        if (!sr && !!cl) {\r\n            setLeftThread(t, i, cl, mscl);\r\n        }\r\n        else if (!!sr && !cl) {\r\n            setRightThread(t, i, sr, mssr);\r\n        }\r\n    }\r\n    function moveSubtree(t, i, si, dist) {\r\n        t.c[i].mod += dist;\r\n        t.c[i].msel += dist;\r\n        t.c[i].mser += dist;\r\n        distributeExtra(t, i, si, dist);\r\n    }\r\n    function nextLeftContour(t) {\r\n        return t.cs === 0 ? t.tl : t.c[0];\r\n    }\r\n    function nextRightContour(t) {\r\n        return t.cs === 0 ? t.tr : t.c[t.cs - 1];\r\n    }\r\n    function bottom(t) {\r\n        return t.y + t.h;\r\n    }\r\n    function setLeftThread(t, i, cl, modsumcl) {\r\n        var li = t.c[0].el;\r\n        li.tl = cl;\r\n        var diff = modsumcl - cl.mod - t.c[0].msel;\r\n        li.mod += diff;\r\n        li.prelim -= diff;\r\n        t.c[0].el = t.c[i].el;\r\n        t.c[0].msel = t.c[i].msel;\r\n    }\r\n    function setRightThread(t, i, sr, modsumsr) {\r\n        var ri = t.c[i].er;\r\n        ri.tr = sr;\r\n        var diff = modsumsr - sr.mod - t.c[i].mser;\r\n        ri.mod += diff;\r\n        ri.prelim -= diff;\r\n        t.c[i].er = t.c[i - 1].er;\r\n        t.c[i].mser = t.c[i - 1].mser;\r\n    }\r\n    function positionRoot(t) {\r\n        t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\r\n    }\r\n    function secondWalk(t, modsum) {\r\n        modsum += t.mod;\r\n        t.x = t.prelim + modsum;\r\n        addChildSpacing(t);\r\n        for (var i = 0; i < t.cs; i++) {\r\n            secondWalk(t.c[i], modsum);\r\n        }\r\n    }\r\n    function distributeExtra(t, i, si, dist) {\r\n        if (si !== i - 1) {\r\n            var nr = i - si;\r\n            t.c[si + 1].shift += dist / nr;\r\n            t.c[i].shift -= dist / nr;\r\n            t.c[i].change -= dist - dist / nr;\r\n        }\r\n    }\r\n    function addChildSpacing(t) {\r\n        var d = 0;\r\n        var modsumdelta = 0;\r\n        for (var i = 0; i < t.cs; i++) {\r\n            d += t.c[i].shift;\r\n            modsumdelta += d + t.c[i].change;\r\n            t.c[i].mod += modsumdelta;\r\n        }\r\n    }\r\n    function updateIYL(low, index, ih) {\r\n        while (ih !== null && low >= ih.low) {\r\n            ih = ih.nxt;\r\n        }\r\n        return {\r\n            low: low,\r\n            index: index,\r\n            nxt: ih\r\n        };\r\n    }\r\n    layer(root, isHorizontal);\r\n    var wt = WrappedTree.fromNode(root, isHorizontal);\r\n    firstWalk(wt);\r\n    secondWalk(wt, 0);\r\n    convertBack(wt, root, isHorizontal);\r\n    normalize(root, isHorizontal);\r\n    return root;\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\non-layered-tidy.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\non-layered-tidy.js"],"names":[],"mappings":"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","sourcesContent":["// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};"]}]}