{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kde.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kde.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar assign = require('@antv/util/lib/mix');\nvar each = require('@antv/util/lib/each');\nvar forIn = require('@antv/util/lib/each');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar isFunction = require('@antv/util/lib/type/is-function');\nvar isNumber = require('@antv/util/lib/type/is-number');\nvar isString = require('@antv/util/lib/type/is-string');\nvar keys = require('@antv/util/lib/object/keys');\nvar pick = require('@antv/util/lib/pick');\nvar getSeriesValues = require('../util/get-series-values');\nvar kernel = require('../util/kernel');\nvar bandwidth = require('../util/bandwidth');\nvar partition = require('../util/partition');\nvar registerTransform = require('../data-set').registerTransform;\nvar getFields = require('../util/option-parser').getFields;\nvar kernelDensityEstimation = require('simple-statistics').kernelDensityEstimation;\nvar DEFAULT_OPTIONS = {\n    minSize: 0.01,\n    as: ['key', 'y', 'size'],\n    extent: [],\n    method: 'gaussian',\n    bandwidth: 'nrd',\n    step: 0,\n    groupBy: []\n};\nvar KERNEL_METHODS = keys(kernel);\nvar BANDWIDTH_METHODS = keys(bandwidth);\nfunction transform(dv, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var fields = getFields(options);\n    if (!isArray(fields) || fields.length < 1) {\n        throw new TypeError('invalid fields: must be an array of at least 1 strings!');\n    }\n    var as = options.as;\n    if (!isArray(as) || as.length !== 3) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method = options.method;\n    if (isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel[method];\n    }\n    if (!isFunction(method)) {\n        throw new TypeError('invalid method: kernel method must be a function!');\n    }\n    var extent = options.extent;\n    if (!isArray(extent) || extent.length === 0) {\n        var rangeArr_1 = [];\n        each(fields, function (field) {\n            var range = dv.range(field);\n            rangeArr_1 = rangeArr_1.concat(range);\n        });\n        extent = [Math.min.apply(Math, __spread(rangeArr_1)), Math.max.apply(Math, __spread(rangeArr_1))];\n    }\n    var bw = options.bandwidth;\n    if (isString(bw) && bandwidth[bw]) {\n        bw = bandwidth[bw](dv.getColumn(fields[0]));\n    }\n    else if (isFunction(bw)) {\n        bw = bw(dv.getColumn(fields[0]));\n    }\n    else if (!isNumber(bw) || bw <= 0) {\n        bw = bandwidth.nrd(dv.getColumn(fields[0]));\n    }\n    var seriesValues = getSeriesValues(extent, options.step ? options.step : bw);\n    var result = [];\n    var groupBy = options.groupBy;\n    var groups = partition(dv.rows, groupBy);\n    forIn(groups, function (group) {\n        var probalityDensityFunctionByField = {};\n        each(fields, function (field) {\n            var row = pick(group[0], groupBy);\n            probalityDensityFunctionByField[field] = kernelDensityEstimation(group.map(function (item) { return item[field]; }), method, bw);\n            var _a = __read(as, 3), key = _a[0], y = _a[1], size = _a[2];\n            row[key] = field;\n            row[y] = [];\n            row[size] = [];\n            each(seriesValues, function (yValue) {\n                var sizeValue = probalityDensityFunctionByField[field](yValue);\n                if (sizeValue >= options.minSize) {\n                    row[y].push(yValue);\n                    row[size].push(sizeValue);\n                }\n            });\n            result.push(row);\n        });\n    });\n    dv.rows = result;\n}\nregisterTransform('kernel-density-estimation', transform);\nregisterTransform('kde', transform);\nregisterTransform('KDE', transform);\nmodule.exports = {\n    KERNEL_METHODS: KERNEL_METHODS,\n    BANDWIDTH_METHODS: BANDWIDTH_METHODS\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kde.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kde.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * kernel density estimation\n */\nconst assign = require('@antv/util/lib/mix');\nconst each = require('@antv/util/lib/each');\nconst forIn = require('@antv/util/lib/each');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\nconst pick = require('@antv/util/lib/pick');\nconst getSeriesValues = require('../util/get-series-values');\nconst kernel = require('../util/kernel');\nconst bandwidth = require('../util/bandwidth');\nconst partition = require('../util/partition');\nconst {\n  registerTransform\n} = require('../data-set');\nconst {\n  getFields\n} = require('../util/option-parser');\nconst {\n  kernelDensityEstimation\n} = require('simple-statistics');\n\nconst DEFAULT_OPTIONS = {\n  minSize: 0.01,\n  as: [ 'key', 'y', 'size' ],\n  // fields: [ 'y1', 'y2' ], // required, one or more fields\n  extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]\n  method: 'gaussian', // kernel method: should be one of keys(kernel)\n  bandwidth: 'nrd', // bandwidth method to execute kernel function // nrd, silverman or a fixed bandwidth value\n  step: 0,\n  groupBy: []\n};\n\nconst KERNEL_METHODS = keys(kernel);\nconst BANDWIDTH_METHODS = keys(bandwidth);\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length < 1) {\n    throw new TypeError('invalid fields: must be an array of at least 1 strings!');\n  }\n  const as = options.as;\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('invalid as: must be an array of 3 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  let extent = options.extent;\n  if (!isArray(extent) || extent.length === 0) {\n    let rangeArr = [];\n    each(fields, field => {\n      const range = dv.range(field);\n      rangeArr = rangeArr.concat(range);\n    });\n    extent = [ Math.min(...rangeArr), Math.max(...rangeArr) ];\n  }\n  let bw = options.bandwidth;\n  if (isString(bw) && bandwidth[bw]) {\n    bw = bandwidth[bw](dv.getColumn(fields[0]));\n  } else if (isFunction(bw)) {\n    bw = bw(dv.getColumn(fields[0]));\n  } else if (!isNumber(bw) || bw <= 0) {\n    bw = bandwidth.nrd(dv.getColumn(fields[0]));\n  }\n  const seriesValues = getSeriesValues(extent, options.step ? options.step : bw);\n  const result = [];\n\n  const groupBy = options.groupBy;\n  const groups = partition(dv.rows, groupBy);\n  forIn(groups, group => {\n    const probalityDensityFunctionByField = {};\n    each(fields, field => {\n      const row = pick(group[0], groupBy);\n      probalityDensityFunctionByField[field] = kernelDensityEstimation(group.map(item => item[field]), method, bw);\n      const [ key, y, size ] = as;\n      row[key] = field;\n      row[y] = [];\n      row[size] = [];\n      each(seriesValues, yValue => {\n        const sizeValue = probalityDensityFunctionByField[field](yValue);\n        if (sizeValue >= options.minSize) {\n          row[y].push(yValue);\n          row[size].push(sizeValue);\n        }\n      });\n      result.push(row);\n    });\n  });\n\n  dv.rows = result;\n}\n\nregisterTransform('kernel-density-estimation', transform);\nregisterTransform('kde', transform);\nregisterTransform('KDE', transform);\n\nmodule.exports = {\n  KERNEL_METHODS,\n  BANDWIDTH_METHODS\n};\n"]}]}