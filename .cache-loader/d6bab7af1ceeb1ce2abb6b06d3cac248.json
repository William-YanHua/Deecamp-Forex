{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\density.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\density.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar assign = require('@antv/util/lib/mix');\r\nvar isArray = require('@antv/util/lib/type/is-array');\r\nvar isFunction = require('@antv/util/lib/type/is-function');\r\nvar isNumber = require('@antv/util/lib/type/is-number');\r\nvar isString = require('@antv/util/lib/type/is-string');\r\nvar keys = require('@antv/util/lib/object/keys');\r\nvar getSeriesValues = require('../../util/get-series-values');\r\nvar kernel = require('../../util/kernel');\r\nvar registerTransform = require('../../data-set').registerTransform;\r\nvar getFields = require('../../util/option-parser').getFields;\r\nvar silverman = require('../../util/bandwidth').silverman;\r\nvar DEFAULT_OPTIONS = {\r\n    as: ['x', 'y', 'z'],\r\n    method: 'gaussian',\r\n    extent: [],\r\n    bandwidth: []\r\n};\r\nvar KERNEL_METHODS = keys(kernel);\r\nfunction transform(dv, options) {\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var fields = getFields(options);\r\n    if (!isArray(fields) || fields.length !== 2) {\r\n        throw new TypeError('invalid fields: must be an array of 2 strings!');\r\n    }\r\n    var _a = __read(options.as, 3), asX = _a[0], asY = _a[1], asZ = _a[2];\r\n    if (!isString(asX) || !isString(asY) || !isString(asZ)) {\r\n        throw new TypeError('invalid as: must be an array of 3 strings!');\r\n    }\r\n    var method = options.method;\r\n    if (isString(method)) {\r\n        if (KERNEL_METHODS.indexOf(method) === -1) {\r\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\r\n        }\r\n        method = kernel[method];\r\n    }\r\n    if (!isFunction(method)) {\r\n        throw new TypeError('invalid method: kernel method must be a function!');\r\n    }\r\n    var _b = __read(fields, 2), xField = _b[0], yField = _b[1];\r\n    var _c = __read(options.extent, 2), extentX = _c[0], extentY = _c[1];\r\n    if (!isArray(extentX) || !isArray(extentY)) {\r\n        extentX = dv.range(xField);\r\n        extentY = dv.range(yField);\r\n    }\r\n    var _d = __read(options.bandwidth, 2), bwX = _d[0], bwY = _d[1];\r\n    if (!isNumber(bwX) || bwX <= 0 || !isNumber(bwY) || bwY <= 0) {\r\n        bwX = silverman(dv.getColumn(xField));\r\n        bwY = silverman(dv.getColumn(yField));\r\n    }\r\n    var seriesValuesX = getSeriesValues(extentX, bwX);\r\n    var seriesValuesY = getSeriesValues(extentY, bwY);\r\n    var count = dv.rows.length;\r\n    var result = [];\r\n    for (var i = 0; i < seriesValuesX.length; i++) {\r\n        for (var j = 0; j < seriesValuesY.length; j++) {\r\n            var sum = 0;\r\n            var x = seriesValuesX[i];\r\n            var y = seriesValuesY[j];\r\n            for (var k = 0; k < count; k++) {\r\n                sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\r\n            }\r\n            var z = (1 / (count * bwX * bwY)) * sum;\r\n            var row = {};\r\n            row[asX] = x;\r\n            row[asY] = y;\r\n            row[asZ] = z;\r\n            result.push(row);\r\n        }\r\n    }\r\n    dv.rows = result;\r\n}\r\nregisterTransform('kernel-smooth.density', transform);\r\nregisterTransform('kernel.density', transform);\r\nmodule.exports = {\r\n    KERNEL_METHODS: KERNEL_METHODS\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\density.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kernel-smooth\\density.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nconst assign = require('@antv/util/lib/mix');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\n// const regression = require('regression');\nconst getSeriesValues = require('../../util/get-series-values');\n// const enclideanDistance = require('../../util/euclidean-distance');\nconst kernel = require('../../util/kernel');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\nconst {\n  silverman\n} = require('../../util/bandwidth');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y', 'z' ],\n  // fields: [ 'x', 'y' ], // required, one or two fields\n  method: 'gaussian', // kernel method: should be one of keys(kernel)\n  extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]\n  bandwidth: [] // bandWidth to execute kernel function\n};\n\nconst KERNEL_METHODS = keys(kernel);\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length !== 2) {\n    throw new TypeError('invalid fields: must be an array of 2 strings!');\n  }\n  const [ asX, asY, asZ ] = options.as;\n  if (!isString(asX) || !isString(asY) || !isString(asZ)) {\n    throw new TypeError('invalid as: must be an array of 3 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  const [ xField, yField ] = fields;\n  let [ extentX, extentY ] = options.extent;\n  if (!isArray(extentX) || !isArray(extentY)) {\n    extentX = dv.range(xField);\n    extentY = dv.range(yField);\n  }\n  let [ bwX, bwY ] = options.bandwidth;\n  if (!isNumber(bwX) || bwX <= 0 || !isNumber(bwY) || bwY <= 0) {\n    bwX = silverman(dv.getColumn(xField));\n    bwY = silverman(dv.getColumn(yField));\n  }\n  const seriesValuesX = getSeriesValues(extentX, bwX);\n  const seriesValuesY = getSeriesValues(extentY, bwY);\n  const count = dv.rows.length;\n  const result = [];\n\n  for (let i = 0; i < seriesValuesX.length; i++) {\n    for (let j = 0; j < seriesValuesY.length; j++) {\n      let sum = 0;\n      const x = seriesValuesX[i];\n      const y = seriesValuesY[j];\n      for (let k = 0; k < count; k++) {\n        sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\n      }\n      const z = (1 / (count * bwX * bwY)) * sum;\n      const row = {};\n      row[asX] = x;\n      row[asY] = y;\n      row[asZ] = z;\n      result.push(row);\n    }\n  }\n\n  dv.rows = result;\n}\n\nregisterTransform('kernel-smooth.density', transform);\nregisterTransform('kernel.density', transform);\n\nmodule.exports = {\n  KERNEL_METHODS\n};\n"]}]}