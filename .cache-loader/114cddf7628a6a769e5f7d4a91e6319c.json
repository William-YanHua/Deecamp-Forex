{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/antimeridian.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/antimeridian.js","mtime":1467246014000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import clip from \"./index\";\nimport { abs, atan, cos, epsilon, halfPi, pi, sin } from \"../math\";\nexport default clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\nfunction clipAntimeridianLine(stream) {\n    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;\n    return {\n        lineStart: function () {\n            stream.lineStart();\n            clean = 1;\n        },\n        point: function (lambda1, phi1) {\n            var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);\n            if (abs(delta - pi) < epsilon) {\n                stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n                stream.point(sign0, phi0);\n                stream.lineEnd();\n                stream.lineStart();\n                stream.point(sign1, phi0);\n                stream.point(lambda1, phi0);\n                clean = 0;\n            }\n            else if (sign0 !== sign1 && delta >= pi) {\n                if (abs(lambda0 - sign0) < epsilon)\n                    lambda0 -= sign0 * epsilon;\n                if (abs(lambda1 - sign1) < epsilon)\n                    lambda1 -= sign1 * epsilon;\n                phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n                stream.point(sign0, phi0);\n                stream.lineEnd();\n                stream.lineStart();\n                stream.point(sign1, phi0);\n                clean = 0;\n            }\n            stream.point(lambda0 = lambda1, phi0 = phi1);\n            sign0 = sign1;\n        },\n        lineEnd: function () {\n            stream.lineEnd();\n            lambda0 = phi0 = NaN;\n        },\n        clean: function () {\n            return 2 - clean;\n        }\n    };\n}\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);\n    return abs(sinLambda0Lambda1) > epsilon\n        ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n            - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n            / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n        : (phi0 + phi1) / 2;\n}\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n    var phi;\n    if (from == null) {\n        phi = direction * halfPi;\n        stream.point(-pi, phi);\n        stream.point(0, phi);\n        stream.point(pi, phi);\n        stream.point(pi, 0);\n        stream.point(pi, -phi);\n        stream.point(0, -phi);\n        stream.point(-pi, -phi);\n        stream.point(-pi, 0);\n        stream.point(-pi, phi);\n    }\n    else if (abs(from[0] - to[0]) > epsilon) {\n        var lambda = from[0] < to[0] ? pi : -pi;\n        phi = direction * lambda / 2;\n        stream.point(-lambda, phi);\n        stream.point(0, phi);\n        stream.point(lambda, phi);\n    }\n    else {\n        stream.point(to[0], to[1]);\n    }\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/antimeridian.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-geo/src/clip/antimeridian.js"],"names":[],"mappings":"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","sourcesContent":["import clip from \"./index\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n"]}]}