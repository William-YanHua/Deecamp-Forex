{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g\\lib\\core\\shape.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g\\lib\\core\\shape.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var Util = require('../util/index');\r\nvar isPointInPath = require('./mixin/isPointInPath');\r\nvar Element = require('./element');\r\nvar Inside = require('../shapes/util/inside');\r\nvar Shape = function Shape(cfg) {\r\n    Shape.superclass.constructor.call(this, cfg);\r\n};\r\nShape.ATTRS = {};\r\nUtil.extend(Shape, Element);\r\nvar ARRAY_ATTRS = {\r\n    matrix: 'matrix',\r\n    path: 'path',\r\n    points: 'points',\r\n    lineDash: 'lineDash'\r\n};\r\nfunction _cloneArrayAttr(arr) {\r\n    var result = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (Util.isArray(arr[i])) {\r\n            result.push([].concat(arr[i]));\r\n        }\r\n        else {\r\n            result.push(arr[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nUtil.augment(Shape, isPointInPath, {\r\n    isShape: true,\r\n    drawInner: function drawInner(context) {\r\n        var self = this;\r\n        var attrs = self._attrs;\r\n        self.createPath(context);\r\n        var originOpacity = context.globalAlpha;\r\n        if (self.hasFill()) {\r\n            var fillOpacity = attrs.fillOpacity;\r\n            if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\r\n                context.globalAlpha = fillOpacity;\r\n                context.fill();\r\n                context.globalAlpha = originOpacity;\r\n            }\r\n            else {\r\n                context.fill();\r\n            }\r\n        }\r\n        if (self.hasStroke()) {\r\n            var lineWidth = self._attrs.lineWidth;\r\n            if (lineWidth > 0) {\r\n                var strokeOpacity = attrs.strokeOpacity;\r\n                if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\r\n                    context.globalAlpha = strokeOpacity;\r\n                }\r\n                context.stroke();\r\n            }\r\n        }\r\n        self.afterPath(context);\r\n    },\r\n    afterPath: function afterPath() { },\r\n    isHitBox: function isHitBox() {\r\n        return true;\r\n    },\r\n    isHit: function isHit(x, y) {\r\n        var self = this;\r\n        var v = [x, y, 1];\r\n        self.invert(v);\r\n        if (self.isHitBox()) {\r\n            var box = self.getBBox();\r\n            if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {\r\n                return false;\r\n            }\r\n        }\r\n        var clip = self._attrs.clip;\r\n        if (clip) {\r\n            clip.invert(v, self.get('canvas'));\r\n            if (clip.isPointInPath(v[0], v[1])) {\r\n                return self.isPointInPath(v[0], v[1]);\r\n            }\r\n        }\r\n        else {\r\n            return self.isPointInPath(v[0], v[1]);\r\n        }\r\n        return false;\r\n    },\r\n    calculateBox: function calculateBox() {\r\n        return null;\r\n    },\r\n    getHitLineWidth: function getHitLineWidth() {\r\n        var attrs = this._attrs;\r\n        var lineAppendWidth = attrs.lineAppendWidth || 0;\r\n        var lineWidth = attrs.lineWidth || 0;\r\n        return lineWidth + lineAppendWidth;\r\n    },\r\n    clearTotalMatrix: function clearTotalMatrix() {\r\n        this._cfg.totalMatrix = null;\r\n        this._cfg.region = null;\r\n    },\r\n    clearBBox: function clearBBox() {\r\n        this._cfg.box = null;\r\n        this._cfg.region = null;\r\n    },\r\n    getBBox: function getBBox() {\r\n        var box = this._cfg.box;\r\n        if (!box) {\r\n            box = this.calculateBox();\r\n            if (box) {\r\n                box.x = box.minX;\r\n                box.y = box.minY;\r\n                box.width = box.maxX - box.minX;\r\n                box.height = box.maxY - box.minY;\r\n            }\r\n            this._cfg.box = box;\r\n        }\r\n        return box;\r\n    },\r\n    clone: function clone() {\r\n        var self = this;\r\n        var clone = null;\r\n        var _attrs = self._attrs;\r\n        var attrs = {};\r\n        Util.each(_attrs, function (i, k) {\r\n            if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {\r\n                attrs[k] = _cloneArrayAttr(_attrs[k]);\r\n            }\r\n            else {\r\n                attrs[k] = _attrs[k];\r\n            }\r\n        });\r\n        clone = new self.constructor({\r\n            attrs: attrs\r\n        });\r\n        clone._cfg.zIndex = self._cfg.zIndex;\r\n        return clone;\r\n    }\r\n});\r\nmodule.exports = Shape;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g\\lib\\core\\shape.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g\\lib\\core\\shape.js"],"names":[],"mappings":"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","sourcesContent":["var Util = require('../util/index');\n\nvar isPointInPath = require('./mixin/isPointInPath');\n\nvar Element = require('./element');\n\nvar Inside = require('../shapes/util/inside');\n\nvar Shape = function Shape(cfg) {\n  Shape.superclass.constructor.call(this, cfg);\n};\n\nShape.ATTRS = {};\nUtil.extend(Shape, Element);\nvar ARRAY_ATTRS = {\n  matrix: 'matrix',\n  path: 'path',\n  points: 'points',\n  lineDash: 'lineDash'\n};\n\nfunction _cloneArrayAttr(arr) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (Util.isArray(arr[i])) {\n      result.push([].concat(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nUtil.augment(Shape, isPointInPath, {\n  isShape: true,\n  drawInner: function drawInner(context) {\n    var self = this;\n    var attrs = self._attrs;\n    self.createPath(context);\n    var originOpacity = context.globalAlpha;\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        context.fill();\n        context.globalAlpha = originOpacity;\n      } else {\n        context.fill();\n      }\n    }\n\n    if (self.hasStroke()) {\n      var lineWidth = self._attrs.lineWidth;\n\n      if (lineWidth > 0) {\n        var strokeOpacity = attrs.strokeOpacity;\n\n        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n\n        context.stroke();\n      }\n    }\n\n    self.afterPath(context);\n  },\n  afterPath: function afterPath() {},\n\n  /**\n   * 击中图形时是否进行包围盒判断\n   * @return {Boolean} [description]\n   */\n  isHitBox: function isHitBox() {\n    return true;\n  },\n\n  /**\n   * 节点是否能够被击中\n   * @param {Number} x x坐标\n   * @param {Number} y y坐标\n   * @return {Boolean} 是否在图形中\n   */\n  isHit: function isHit(x, y) {\n    var self = this;\n    var v = [x, y, 1];\n    self.invert(v); // canvas\n\n    if (self.isHitBox()) {\n      var box = self.getBBox();\n\n      if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {\n        return false;\n      }\n    }\n\n    var clip = self._attrs.clip;\n\n    if (clip) {\n      clip.invert(v, self.get('canvas'));\n\n      if (clip.isPointInPath(v[0], v[1])) {\n        return self.isPointInPath(v[0], v[1]);\n      }\n    } else {\n      return self.isPointInPath(v[0], v[1]);\n    }\n\n    return false;\n  },\n\n  /**\n   * @protected\n   * 计算包围盒\n   * @return {Object} 包围盒\n   */\n  calculateBox: function calculateBox() {\n    return null;\n  },\n  // 获取拾取时线的宽度，需要考虑附加的线的宽度\n  getHitLineWidth: function getHitLineWidth() {\n    var attrs = this._attrs; // if (!attrs.stroke) {\n    //   return 0;\n    // }\n\n    var lineAppendWidth = attrs.lineAppendWidth || 0;\n    var lineWidth = attrs.lineWidth || 0;\n    return lineWidth + lineAppendWidth;\n  },\n  // 清除当前的矩阵\n  clearTotalMatrix: function clearTotalMatrix() {\n    this._cfg.totalMatrix = null;\n    this._cfg.region = null;\n  },\n  clearBBox: function clearBBox() {\n    this._cfg.box = null;\n    this._cfg.region = null;\n  },\n  getBBox: function getBBox() {\n    var box = this._cfg.box; // 延迟计算\n\n    if (!box) {\n      box = this.calculateBox();\n\n      if (box) {\n        box.x = box.minX;\n        box.y = box.minY;\n        box.width = box.maxX - box.minX;\n        box.height = box.maxY - box.minY;\n      }\n\n      this._cfg.box = box;\n    }\n\n    return box;\n  },\n  clone: function clone() {\n    var self = this;\n    var clone = null;\n    var _attrs = self._attrs;\n    var attrs = {};\n    Util.each(_attrs, function (i, k) {\n      if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {\n        attrs[k] = _cloneArrayAttr(_attrs[k]);\n      } else {\n        attrs[k] = _attrs[k];\n      }\n    });\n    clone = new self.constructor({\n      attrs: attrs\n    }); // zIndex也是绘图属性，但是在cfg中，特殊处理\n\n    clone._cfg.zIndex = self._cfg.zIndex;\n    return clone;\n  }\n});\nmodule.exports = Shape;"]}]}