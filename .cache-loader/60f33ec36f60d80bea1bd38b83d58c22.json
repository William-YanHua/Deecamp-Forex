{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unified\\index.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unified\\index.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["'use strict';\r\nvar extend = require('extend');\r\nvar bail = require('bail');\r\nvar vfile = require('vfile');\r\nvar trough = require('trough');\r\nvar string = require('x-is-string');\r\nvar plain = require('is-plain-obj');\r\nmodule.exports = unified().freeze();\r\nvar slice = [].slice;\r\nvar own = {}.hasOwnProperty;\r\nvar pipeline = trough()\r\n    .use(pipelineParse)\r\n    .use(pipelineRun)\r\n    .use(pipelineStringify);\r\nfunction pipelineParse(p, ctx) {\r\n    ctx.tree = p.parse(ctx.file);\r\n}\r\nfunction pipelineRun(p, ctx, next) {\r\n    p.run(ctx.tree, ctx.file, done);\r\n    function done(err, tree, file) {\r\n        if (err) {\r\n            next(err);\r\n        }\r\n        else {\r\n            ctx.tree = tree;\r\n            ctx.file = file;\r\n            next();\r\n        }\r\n    }\r\n}\r\nfunction pipelineStringify(p, ctx) {\r\n    ctx.file.contents = p.stringify(ctx.tree, ctx.file);\r\n}\r\nfunction unified() {\r\n    var attachers = [];\r\n    var transformers = trough();\r\n    var namespace = {};\r\n    var frozen = false;\r\n    var freezeIndex = -1;\r\n    processor.data = data;\r\n    processor.freeze = freeze;\r\n    processor.attachers = attachers;\r\n    processor.use = use;\r\n    processor.parse = parse;\r\n    processor.stringify = stringify;\r\n    processor.run = run;\r\n    processor.runSync = runSync;\r\n    processor.process = process;\r\n    processor.processSync = processSync;\r\n    return processor;\r\n    function processor() {\r\n        var destination = unified();\r\n        var length = attachers.length;\r\n        var index = -1;\r\n        while (++index < length) {\r\n            destination.use.apply(null, attachers[index]);\r\n        }\r\n        destination.data(extend(true, {}, namespace));\r\n        return destination;\r\n    }\r\n    function freeze() {\r\n        var values;\r\n        var plugin;\r\n        var options;\r\n        var transformer;\r\n        if (frozen) {\r\n            return processor;\r\n        }\r\n        while (++freezeIndex < attachers.length) {\r\n            values = attachers[freezeIndex];\r\n            plugin = values[0];\r\n            options = values[1];\r\n            transformer = null;\r\n            if (options === false) {\r\n                continue;\r\n            }\r\n            if (options === true) {\r\n                values[1] = undefined;\r\n            }\r\n            transformer = plugin.apply(processor, values.slice(1));\r\n            if (typeof transformer === 'function') {\r\n                transformers.use(transformer);\r\n            }\r\n        }\r\n        frozen = true;\r\n        freezeIndex = Infinity;\r\n        return processor;\r\n    }\r\n    function data(key, value) {\r\n        if (string(key)) {\r\n            if (arguments.length === 2) {\r\n                assertUnfrozen('data', frozen);\r\n                namespace[key] = value;\r\n                return processor;\r\n            }\r\n            return (own.call(namespace, key) && namespace[key]) || null;\r\n        }\r\n        if (key) {\r\n            assertUnfrozen('data', frozen);\r\n            namespace = key;\r\n            return processor;\r\n        }\r\n        return namespace;\r\n    }\r\n    function use(value) {\r\n        var settings;\r\n        assertUnfrozen('use', frozen);\r\n        if (value === null || value === undefined) {\r\n        }\r\n        else if (typeof value === 'function') {\r\n            addPlugin.apply(null, arguments);\r\n        }\r\n        else if (typeof value === 'object') {\r\n            if ('length' in value) {\r\n                addList(value);\r\n            }\r\n            else {\r\n                addPreset(value);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Expected usable value, not `' + value + '`');\r\n        }\r\n        if (settings) {\r\n            namespace.settings = extend(namespace.settings || {}, settings);\r\n        }\r\n        return processor;\r\n        function addPreset(result) {\r\n            addList(result.plugins);\r\n            if (result.settings) {\r\n                settings = extend(settings || {}, result.settings);\r\n            }\r\n        }\r\n        function add(value) {\r\n            if (typeof value === 'function') {\r\n                addPlugin(value);\r\n            }\r\n            else if (typeof value === 'object') {\r\n                if ('length' in value) {\r\n                    addPlugin.apply(null, value);\r\n                }\r\n                else {\r\n                    addPreset(value);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Expected usable value, not `' + value + '`');\r\n            }\r\n        }\r\n        function addList(plugins) {\r\n            var length;\r\n            var index;\r\n            if (plugins === null || plugins === undefined) {\r\n            }\r\n            else if (typeof plugins === 'object' && 'length' in plugins) {\r\n                length = plugins.length;\r\n                index = -1;\r\n                while (++index < length) {\r\n                    add(plugins[index]);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Expected a list of plugins, not `' + plugins + '`');\r\n            }\r\n        }\r\n        function addPlugin(plugin, value) {\r\n            var entry = find(plugin);\r\n            if (entry) {\r\n                if (plain(entry[1]) && plain(value)) {\r\n                    value = extend(entry[1], value);\r\n                }\r\n                entry[1] = value;\r\n            }\r\n            else {\r\n                attachers.push(slice.call(arguments));\r\n            }\r\n        }\r\n    }\r\n    function find(plugin) {\r\n        var length = attachers.length;\r\n        var index = -1;\r\n        var entry;\r\n        while (++index < length) {\r\n            entry = attachers[index];\r\n            if (entry[0] === plugin) {\r\n                return entry;\r\n            }\r\n        }\r\n    }\r\n    function parse(doc) {\r\n        var file = vfile(doc);\r\n        var Parser;\r\n        freeze();\r\n        Parser = processor.Parser;\r\n        assertParser('parse', Parser);\r\n        if (newable(Parser)) {\r\n            return new Parser(String(file), file).parse();\r\n        }\r\n        return Parser(String(file), file);\r\n    }\r\n    function run(node, file, cb) {\r\n        assertNode(node);\r\n        freeze();\r\n        if (!cb && typeof file === 'function') {\r\n            cb = file;\r\n            file = null;\r\n        }\r\n        if (!cb) {\r\n            return new Promise(executor);\r\n        }\r\n        executor(null, cb);\r\n        function executor(resolve, reject) {\r\n            transformers.run(node, vfile(file), done);\r\n            function done(err, tree, file) {\r\n                tree = tree || node;\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else if (resolve) {\r\n                    resolve(tree);\r\n                }\r\n                else {\r\n                    cb(null, tree, file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function runSync(node, file) {\r\n        var complete = false;\r\n        var result;\r\n        run(node, file, done);\r\n        assertDone('runSync', 'run', complete);\r\n        return result;\r\n        function done(err, tree) {\r\n            complete = true;\r\n            bail(err);\r\n            result = tree;\r\n        }\r\n    }\r\n    function stringify(node, doc) {\r\n        var file = vfile(doc);\r\n        var Compiler;\r\n        freeze();\r\n        Compiler = processor.Compiler;\r\n        assertCompiler('stringify', Compiler);\r\n        assertNode(node);\r\n        if (newable(Compiler)) {\r\n            return new Compiler(node, file).compile();\r\n        }\r\n        return Compiler(node, file);\r\n    }\r\n    function process(doc, cb) {\r\n        freeze();\r\n        assertParser('process', processor.Parser);\r\n        assertCompiler('process', processor.Compiler);\r\n        if (!cb) {\r\n            return new Promise(executor);\r\n        }\r\n        executor(null, cb);\r\n        function executor(resolve, reject) {\r\n            var file = vfile(doc);\r\n            pipeline.run(processor, { file: file }, done);\r\n            function done(err) {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else if (resolve) {\r\n                    resolve(file);\r\n                }\r\n                else {\r\n                    cb(null, file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function processSync(doc) {\r\n        var complete = false;\r\n        var file;\r\n        freeze();\r\n        assertParser('processSync', processor.Parser);\r\n        assertCompiler('processSync', processor.Compiler);\r\n        file = vfile(doc);\r\n        process(file, done);\r\n        assertDone('processSync', 'process', complete);\r\n        return file;\r\n        function done(err) {\r\n            complete = true;\r\n            bail(err);\r\n        }\r\n    }\r\n}\r\nfunction newable(value) {\r\n    return typeof value === 'function' && keys(value.prototype);\r\n}\r\nfunction keys(value) {\r\n    var key;\r\n    for (key in value) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction assertParser(name, Parser) {\r\n    if (typeof Parser !== 'function') {\r\n        throw new Error('Cannot `' + name + '` without `Parser`');\r\n    }\r\n}\r\nfunction assertCompiler(name, Compiler) {\r\n    if (typeof Compiler !== 'function') {\r\n        throw new Error('Cannot `' + name + '` without `Compiler`');\r\n    }\r\n}\r\nfunction assertUnfrozen(name, frozen) {\r\n    if (frozen) {\r\n        throw new Error([\r\n            'Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ',\r\n            'processor first, by invoking it: use `processor()` instead of ',\r\n            '`processor`.'\r\n        ].join(''));\r\n    }\r\n}\r\nfunction assertNode(node) {\r\n    if (!node || !string(node.type)) {\r\n        throw new Error('Expected node, got `' + node + '`');\r\n    }\r\n}\r\nfunction assertDone(name, asyncName, complete) {\r\n    if (!complete) {\r\n        throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\r\n    }\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unified\\index.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\unified\\index.js"],"names":[],"mappings":"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","sourcesContent":["'use strict'\n\n/* Dependencies. */\nvar extend = require('extend')\nvar bail = require('bail')\nvar vfile = require('vfile')\nvar trough = require('trough')\nvar string = require('x-is-string')\nvar plain = require('is-plain-obj')\n\n/* Expose a frozen processor. */\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n/* Process pipeline. */\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file)\n}\n\n/* Function to create the first processor. */\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var frozen = false\n  var freezeIndex = -1\n\n  /* Data management. */\n  processor.data = data\n\n  /* Lock. */\n  processor.freeze = freeze\n\n  /* Plug-ins. */\n  processor.attachers = attachers\n  processor.use = use\n\n  /* API. */\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  /* Expose. */\n  return processor\n\n  /* Create a new processor based on the processor\n   * in the current scope. */\n  function processor() {\n    var destination = unified()\n    var length = attachers.length\n    var index = -1\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /* Freeze: used to signal a processor that has finished\n   * configuration.\n   *\n   * For example, take unified itself.  It’s frozen.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be extended, by invoking it, before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor. */\n  function freeze() {\n    var values\n    var plugin\n    var options\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n      plugin = values[0]\n      options = values[1]\n      transformer = null\n\n      if (options === false) {\n        continue\n      }\n\n      if (options === true) {\n        values[1] = undefined\n      }\n\n      transformer = plugin.apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  /* Data management.\n   * Getter / setter for processor-specific informtion. */\n  function data(key, value) {\n    if (string(key)) {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n\n        namespace[key] = value\n\n        return processor\n      }\n\n      /* Get `key`. */\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    /* Set space. */\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    /* Get space. */\n    return namespace\n  }\n\n  /* Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a preset,\n   * *   a list of presets, attachers, and arguments (list\n   *     of attachers and options). */\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      /* Empty */\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var length\n      var index\n\n      if (plugins === null || plugins === undefined) {\n        /* Empty */\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length\n        index = -1\n\n        while (++index < length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length\n    var index = -1\n    var entry\n\n    while (++index < length) {\n      entry = attachers[index]\n\n      if (entry[0] === plugin) {\n        return entry\n      }\n    }\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor. */\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser)) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), async. */\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(err, tree, file) {\n        tree = tree || node\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), sync. */\n  function runSync(node, file) {\n    var complete = false\n    var result\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(err, tree) {\n      complete = true\n      bail(err)\n      result = tree\n    }\n  }\n\n  /* Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor. */\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler)) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile. */\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(err) {\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  /* Process the given document (in string or VFile\n   * representation), sync. */\n  function processSync(doc) {\n    var complete = false\n    var file\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(err) {\n      complete = true\n      bail(err)\n    }\n  }\n}\n\n/* Check if `func` is a constructor. */\nfunction newable(value) {\n  return typeof value === 'function' && keys(value.prototype)\n}\n\n/* Check if `value` is an object with keys. */\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n  return false\n}\n\n/* Assert a parser is available. */\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/* Assert a compiler is available. */\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/* Assert the processor is not frozen. */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      [\n        'Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ',\n        'processor first, by invoking it: use `processor()` instead of ',\n        '`processor`.'\n      ].join('')\n    )\n  }\n}\n\n/* Assert `node` is a Unist node. */\nfunction assertNode(node) {\n  if (!node || !string(node.type)) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n/* Assert that `complete` is `true`. */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n"]}]}