{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/scale/lib/auto/util.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/scale/lib/auto/util.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var DECIMAL_LENGTH = 12;\nfunction getFactor(v) {\n    var factor = 1;\n    if (v === Infinity || v === -Infinity) {\n        throw new Error('Not support Infinity!');\n    }\n    if (v < 1) {\n        var count = 0;\n        while (v < 1) {\n            factor = factor / 10;\n            v = v * 10;\n            count++;\n        }\n        if (factor.toString().length > DECIMAL_LENGTH) {\n            factor = parseFloat(factor.toFixed(count));\n        }\n    }\n    else {\n        while (v > 10) {\n            factor = factor * 10;\n            v = v / 10;\n        }\n    }\n    return factor;\n}\nfunction arrayFloor(values, value) {\n    var length = values.length;\n    if (length === 0) {\n        return NaN;\n    }\n    var pre = values[0];\n    if (value < values[0]) {\n        return NaN;\n    }\n    if (value >= values[length - 1]) {\n        return values[length - 1];\n    }\n    for (var i = 1; i < values.length; i++) {\n        if (value < values[i]) {\n            break;\n        }\n        pre = values[i];\n    }\n    return pre;\n}\nfunction arrayCeiling(values, value) {\n    var length = values.length;\n    if (length === 0) {\n        return NaN;\n    }\n    var rst;\n    if (value > values[length - 1]) {\n        return NaN;\n    }\n    if (value < values[0]) {\n        return values[0];\n    }\n    for (var i = 1; i < values.length; i++) {\n        if (value <= values[i]) {\n            rst = values[i];\n            break;\n        }\n    }\n    return rst;\n}\nvar Util = {\n    snapFactorTo: function snapFactorTo(v, arr, snapType) {\n        if (isNaN(v)) {\n            return NaN;\n        }\n        var factor = 1;\n        if (v !== 0) {\n            if (v < 0) {\n                factor = -1;\n            }\n            v = v * factor;\n            var tmpFactor = getFactor(v);\n            factor = factor * tmpFactor;\n            v = v / tmpFactor;\n        }\n        if (snapType === 'floor') {\n            v = Util.snapFloor(arr, v);\n        }\n        else if (snapType === 'ceil') {\n            v = Util.snapCeiling(arr, v);\n        }\n        else {\n            v = Util.snapTo(arr, v);\n        }\n        var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH));\n        if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n            var decimalVal = parseInt(1 / factor);\n            var symbol = factor > 0 ? 1 : -1;\n            rst = v / decimalVal * symbol;\n        }\n        return rst;\n    },\n    snapMultiple: function snapMultiple(v, base, snapType) {\n        var div;\n        if (snapType === 'ceil') {\n            div = Math.ceil(v / base);\n        }\n        else if (snapType === 'floor') {\n            div = Math.floor(v / base);\n        }\n        else {\n            div = Math.round(v / base);\n        }\n        return div * base;\n    },\n    snapTo: function snapTo(values, value) {\n        var floorVal = arrayFloor(values, value);\n        var ceilingVal = arrayCeiling(values, value);\n        if (isNaN(floorVal) || isNaN(ceilingVal)) {\n            if (values[0] >= value) {\n                return values[0];\n            }\n            var last = values[values.length - 1];\n            if (last <= value) {\n                return last;\n            }\n        }\n        if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n            return floorVal;\n        }\n        return ceilingVal;\n    },\n    snapFloor: function snapFloor(values, value) {\n        return arrayFloor(values, value);\n    },\n    snapCeiling: function snapCeiling(values, value) {\n        return arrayCeiling(values, value);\n    },\n    fixedBase: function fixedBase(v, base) {\n        var str = base.toString();\n        var index = str.indexOf('.');\n        var indexOfExp = str.indexOf('e-');\n        if (index < 0 && indexOfExp < 0) {\n            return Math.round(v);\n        }\n        var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;\n        if (length > 20) {\n            length = 20;\n        }\n        return parseFloat(v.toFixed(length));\n    }\n};\nmodule.exports = Util;\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/scale/lib/auto/util.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/bizcharts/node_modules/@antv/scale/lib/auto/util.js"],"names":[],"mappings":"AAKA,IAAI,cAAc,GAAG,EAAE,CAAC;AAExB,SAAS,SAAS,CAAC,CAAC;IAClB,IAAI,MAAM,GAAG,CAAC,CAAC;IAEf,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;KAC1C;IAED,IAAI,CAAC,GAAG,CAAC,EAAE;QACT,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,OAAO,CAAC,GAAG,CAAC,EAAE;YACZ,MAAM,GAAG,MAAM,GAAG,EAAE,CAAC;YACrB,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;YACX,KAAK,EAAE,CAAC;SACT;QAGD,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,cAAc,EAAE;YAC7C,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;SAC5C;KACF;SAAM;QACL,OAAO,CAAC,GAAG,EAAE,EAAE;YACb,MAAM,GAAG,MAAM,GAAG,EAAE,CAAC;YACrB,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;SACZ;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAGD,SAAS,UAAU,CAAC,MAAM,EAAE,KAAK;IAC/B,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;IAE3B,IAAI,MAAM,KAAK,CAAC,EAAE;QAChB,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IAEpB,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE;QACrB,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;QAC/B,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KAC3B;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE;YACrB,MAAM;SACP;QAED,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;KACjB;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAGD,SAAS,YAAY,CAAC,MAAM,EAAE,KAAK;IACjC,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;IAE3B,IAAI,MAAM,KAAK,CAAC,EAAE;QAChB,OAAO,GAAG,CAAC;KACZ;IAGD,IAAI,GAAG,CAAC;IAER,IAAI,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;QAC9B,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE;QACrB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;KAClB;IAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE;YACtB,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAChB,MAAM;SACP;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED,IAAI,IAAI,GAAG;IAET,YAAY,EAAE,SAAS,YAAY,CAAC,CAAC,EAAE,GAAG,EAAE,QAAQ;QAElD,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;YACZ,OAAO,GAAG,CAAC;SACZ;QAED,IAAI,MAAM,GAAG,CAAC,CAAC;QAEf,IAAI,CAAC,KAAK,CAAC,EAAE;YACX,IAAI,CAAC,GAAG,CAAC,EAAE;gBACT,MAAM,GAAG,CAAC,CAAC,CAAC;aACb;YAED,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;YAEf,IAAI,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;YAE5B,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;SACnB;QAED,IAAI,QAAQ,KAAK,OAAO,EAAE;YACxB,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;SAC5B;aAAM,IAAI,QAAQ,KAAK,MAAM,EAAE;YAC9B,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;SAC9B;aAAM;YACL,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;SACzB;QAED,IAAI,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;QAG/D,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,cAAc,EAAE;YAClE,IAAI,UAAU,GAAG,QAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;YACtC,IAAI,MAAM,GAAG,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACjC,GAAG,GAAG,CAAC,GAAG,UAAU,GAAG,MAAM,CAAC;SAC/B;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IAED,YAAY,EAAE,SAAS,YAAY,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ;QACnD,IAAI,GAAG,CAAC;QAER,IAAI,QAAQ,KAAK,MAAM,EAAE;YACvB,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;SAC3B;aAAM,IAAI,QAAQ,KAAK,OAAO,EAAE;YAC/B,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;SAC5B;aAAM;YACL,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;SAC5B;QAED,OAAO,GAAG,GAAG,IAAI,CAAC;IACpB,CAAC;IAQD,MAAM,EAAE,SAAS,MAAM,CAAC,MAAM,EAAE,KAAK;QAEnC,IAAI,QAAQ,GAAG,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QACzC,IAAI,UAAU,GAAG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAE7C,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;YACxC,IAAI,MAAM,CAAC,CAAC,CAAC,IAAI,KAAK,EAAE;gBACtB,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;aAClB;YAED,IAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAErC,IAAI,IAAI,IAAI,KAAK,EAAE;gBACjB,OAAO,IAAI,CAAC;aACb;SACF;QAED,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,KAAK,CAAC,EAAE;YAC7D,OAAO,QAAQ,CAAC;SACjB;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAQD,SAAS,EAAE,SAAS,SAAS,CAAC,MAAM,EAAE,KAAK;QAEzC,OAAO,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACnC,CAAC;IAQD,WAAW,EAAE,SAAS,WAAW,CAAC,MAAM,EAAE,KAAK;QAE7C,OAAO,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACrC,CAAC;IACD,SAAS,EAAE,SAAS,SAAS,CAAC,CAAC,EAAE,IAAI;QACnC,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC1B,IAAI,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC7B,IAAI,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAEnC,IAAI,KAAK,GAAG,CAAC,IAAI,UAAU,GAAG,CAAC,EAAE;YAE/B,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SACtB;QAED,IAAI,MAAM,GAAG,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;QAEvG,IAAI,MAAM,GAAG,EAAE,EAAE;YACf,MAAM,GAAG,EAAE,CAAC;SACb;QAED,OAAO,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;IACvC,CAAC;CACF,CAAC;AACF,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC","sourcesContent":["/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 如果出现浮点数计算问题，需要处理一下\n    // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n    var indexOfExp = str.indexOf('e-'); // 判断是否带小数点，1.000001 1.23e-9\n\n    if (index < 0 && indexOfExp < 0) {\n      // base为整数\n      return Math.round(v);\n    }\n\n    var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;"]}]}