{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\parent-dummy-chains.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\parent-dummy-chains.js","mtime":1517934108000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var _ = require(\"./lodash\");\r\nmodule.exports = parentDummyChains;\r\nfunction parentDummyChains(g) {\r\n    var postorderNums = postorder(g);\r\n    _.forEach(g.graph().dummyChains, function (v) {\r\n        var node = g.node(v), edgeObj = node.edgeObj, pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending = true;\r\n        while (v !== edgeObj.w) {\r\n            node = g.node(v);\r\n            if (ascending) {\r\n                while ((pathV = path[pathIdx]) !== lca &&\r\n                    g.node(pathV).maxRank < node.rank) {\r\n                    pathIdx++;\r\n                }\r\n                if (pathV === lca) {\r\n                    ascending = false;\r\n                }\r\n            }\r\n            if (!ascending) {\r\n                while (pathIdx < path.length - 1 &&\r\n                    g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\r\n                    pathIdx++;\r\n                }\r\n                pathV = path[pathIdx];\r\n            }\r\n            g.setParent(v, pathV);\r\n            v = g.successors(v)[0];\r\n        }\r\n    });\r\n}\r\nfunction findPath(g, postorderNums, v, w) {\r\n    var vPath = [], wPath = [], low = Math.min(postorderNums[v].low, postorderNums[w].low), lim = Math.max(postorderNums[v].lim, postorderNums[w].lim), parent, lca;\r\n    parent = v;\r\n    do {\r\n        parent = g.parent(parent);\r\n        vPath.push(parent);\r\n    } while (parent &&\r\n        (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\r\n    lca = parent;\r\n    parent = w;\r\n    while ((parent = g.parent(parent)) !== lca) {\r\n        wPath.push(parent);\r\n    }\r\n    return { path: vPath.concat(wPath.reverse()), lca: lca };\r\n}\r\nfunction postorder(g) {\r\n    var result = {}, lim = 0;\r\n    function dfs(v) {\r\n        var low = lim;\r\n        _.forEach(g.children(v), dfs);\r\n        result[v] = { low: low, lim: lim++ };\r\n    }\r\n    _.forEach(g.children(), dfs);\r\n    return result;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\parent-dummy-chains.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\dagre\\lib\\parent-dummy-chains.js"],"names":[],"mappings":"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","sourcesContent":["var _ = require(\"./lodash\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v),\n        edgeObj = node.edgeObj,\n        pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w),\n        path = pathData.path,\n        lca = pathData.lca,\n        pathIdx = 0,\n        pathV = path[pathIdx],\n        ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [],\n      wPath = [],\n      low = Math.min(postorderNums[v].low, postorderNums[w].low),\n      lim = Math.max(postorderNums[v].lim, postorderNums[w].lim),\n      parent,\n      lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {},\n      lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n"]}]}