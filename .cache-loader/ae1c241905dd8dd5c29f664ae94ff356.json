{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\circle.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\circle.js","mtime":1467246014000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["import { cartesian, cartesianNormalizeInPlace, spherical } from \"./cartesian\";\r\nimport constant from \"./constant\";\r\nimport { acos, cos, degrees, epsilon, radians, sin, tau } from \"./math\";\r\nimport { rotateRadians } from \"./rotation\";\r\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\r\n    if (!delta)\r\n        return;\r\n    var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;\r\n    if (t0 == null) {\r\n        t0 = radius + direction * tau;\r\n        t1 = radius - step / 2;\r\n    }\r\n    else {\r\n        t0 = circleRadius(cosRadius, t0);\r\n        t1 = circleRadius(cosRadius, t1);\r\n        if (direction > 0 ? t0 < t1 : t0 > t1)\r\n            t0 += direction * tau;\r\n    }\r\n    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\r\n        point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\r\n        stream.point(point[0], point[1]);\r\n    }\r\n}\r\nfunction circleRadius(cosRadius, point) {\r\n    point = cartesian(point), point[0] -= cosRadius;\r\n    cartesianNormalizeInPlace(point);\r\n    var radius = acos(-point[1]);\r\n    return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\r\n}\r\nexport default function () {\r\n    var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point };\r\n    function point(x, y) {\r\n        ring.push(x = rotate(x, y));\r\n        x[0] *= degrees, x[1] *= degrees;\r\n    }\r\n    function circle() {\r\n        var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;\r\n        ring = [];\r\n        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\r\n        circleStream(stream, r, p, 1);\r\n        c = { type: \"Polygon\", coordinates: [ring] };\r\n        ring = rotate = null;\r\n        return c;\r\n    }\r\n    circle.center = function (_) {\r\n        return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\r\n    };\r\n    circle.radius = function (_) {\r\n        return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\r\n    };\r\n    circle.precision = function (_) {\r\n        return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\r\n    };\r\n    return circle;\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\circle.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo\\src\\circle.js"],"names":[],"mappings":"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","sourcesContent":["import {cartesian, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport constant from \"./constant\";\nimport {acos, cos, degrees, epsilon, radians, sin, tau} from \"./math\";\nimport {rotateRadians} from \"./rotation\";\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nexport default function() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n"]}]}