{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-hierarchy/src/treemap/squarify.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-hierarchy/src/treemap/squarify.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\nexport var phi = (1 + Math.sqrt(5)) / 2;\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n    var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n    while (i0 < n) {\n        dx = x1 - x0, dy = y1 - y0;\n        do\n            sumValue = nodes[i1++].value;\n        while (!sumValue && i1 < n);\n        minValue = maxValue = sumValue;\n        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n        beta = sumValue * sumValue * alpha;\n        minRatio = Math.max(maxValue / beta, beta / minValue);\n        for (; i1 < n; ++i1) {\n            sumValue += nodeValue = nodes[i1].value;\n            if (nodeValue < minValue)\n                minValue = nodeValue;\n            if (nodeValue > maxValue)\n                maxValue = nodeValue;\n            beta = sumValue * sumValue * alpha;\n            newRatio = Math.max(maxValue / beta, beta / minValue);\n            if (newRatio > minRatio) {\n                sumValue -= nodeValue;\n                break;\n            }\n            minRatio = newRatio;\n        }\n        rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n        if (row.dice)\n            treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n        else\n            treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n        value -= sumValue, i0 = i1;\n    }\n    return rows;\n}\nexport default (function custom(ratio) {\n    function squarify(parent, x0, y0, x1, y1) {\n        squarifyRatio(ratio, parent, x0, y0, x1, y1);\n    }\n    squarify.ratio = function (x) {\n        return custom((x = +x) > 1 ? x : 1);\n    };\n    return squarify;\n})(phi);\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-hierarchy/src/treemap/squarify.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/d3-hierarchy/src/treemap/squarify.js"],"names":[],"mappings":"AAAA,OAAO,WAAW,MAAM,WAAW,CAAC;AACpC,OAAO,YAAY,MAAM,YAAY,CAAC;AAEtC,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAExC,MAAM,UAAU,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACzD,IAAI,IAAI,GAAG,EAAE,EACT,KAAK,GAAG,MAAM,CAAC,QAAQ,EACvB,GAAG,EACH,SAAS,EACT,EAAE,GAAG,CAAC,EACN,EAAE,GAAG,CAAC,EACN,CAAC,GAAG,KAAK,CAAC,MAAM,EAChB,EAAE,EAAE,EAAE,EACN,KAAK,GAAG,MAAM,CAAC,KAAK,EACpB,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,KAAK,EACL,IAAI,CAAC;IAET,OAAO,EAAE,GAAG,CAAC,EAAE;QACb,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;QAG3B;YAAG,QAAQ,GAAG,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;eAAQ,CAAC,QAAQ,IAAI,EAAE,GAAG,CAAC,EAAE;QAC7D,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC;QAC/B,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;QACrD,IAAI,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;QACnC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,CAAC;QAGtD,OAAO,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE;YACnB,QAAQ,IAAI,SAAS,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;YACxC,IAAI,SAAS,GAAG,QAAQ;gBAAE,QAAQ,GAAG,SAAS,CAAC;YAC/C,IAAI,SAAS,GAAG,QAAQ;gBAAE,QAAQ,GAAG,SAAS,CAAC;YAC/C,IAAI,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAK,CAAC;YACnC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,EAAE,IAAI,GAAG,QAAQ,CAAC,CAAC;YACtD,IAAI,QAAQ,GAAG,QAAQ,EAAE;gBAAE,QAAQ,IAAI,SAAS,CAAC;gBAAC,MAAM;aAAE;YAC1D,QAAQ,GAAG,QAAQ,CAAC;SACrB;QAGD,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,EAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,EAAC,CAAC,CAAC;QACjF,IAAI,GAAG,CAAC,IAAI;YAAE,WAAW,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;;YAChF,YAAY,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC7E,KAAK,IAAI,QAAQ,EAAE,EAAE,GAAG,EAAE,CAAC;KAC5B;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,eAAe,CAAC,SAAS,MAAM,CAAC,KAAK;IAEnC,SAAS,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACtC,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAC/C,CAAC;IAED,QAAQ,CAAC,KAAK,GAAG,UAAS,CAAC;QACzB,OAAO,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,CAAC,CAAC;IAEF,OAAO,QAAQ,CAAC;AAClB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC","sourcesContent":["import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n"]}]}