{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kde.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kde.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (this && this.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nvar assign = require('@antv/util/lib/mix');\r\nvar each = require('@antv/util/lib/each');\r\nvar forIn = require('@antv/util/lib/each');\r\nvar isArray = require('@antv/util/lib/type/is-array');\r\nvar isFunction = require('@antv/util/lib/type/is-function');\r\nvar isNumber = require('@antv/util/lib/type/is-number');\r\nvar isString = require('@antv/util/lib/type/is-string');\r\nvar keys = require('@antv/util/lib/object/keys');\r\nvar pick = require('@antv/util/lib/pick');\r\nvar getSeriesValues = require('../util/get-series-values');\r\nvar kernel = require('../util/kernel');\r\nvar bandwidth = require('../util/bandwidth');\r\nvar partition = require('../util/partition');\r\nvar registerTransform = require('../data-set').registerTransform;\r\nvar getFields = require('../util/option-parser').getFields;\r\nvar kernelDensityEstimation = require('simple-statistics').kernelDensityEstimation;\r\nvar DEFAULT_OPTIONS = {\r\n    minSize: 0.01,\r\n    as: ['key', 'y', 'size'],\r\n    extent: [],\r\n    method: 'gaussian',\r\n    bandwidth: 'nrd',\r\n    step: 0,\r\n    groupBy: []\r\n};\r\nvar KERNEL_METHODS = keys(kernel);\r\nvar BANDWIDTH_METHODS = keys(bandwidth);\r\nfunction transform(dv, options) {\r\n    options = assign({}, DEFAULT_OPTIONS, options);\r\n    var fields = getFields(options);\r\n    if (!isArray(fields) || fields.length < 1) {\r\n        throw new TypeError('invalid fields: must be an array of at least 1 strings!');\r\n    }\r\n    var as = options.as;\r\n    if (!isArray(as) || as.length !== 3) {\r\n        throw new TypeError('invalid as: must be an array of 3 strings!');\r\n    }\r\n    var method = options.method;\r\n    if (isString(method)) {\r\n        if (KERNEL_METHODS.indexOf(method) === -1) {\r\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\r\n        }\r\n        method = kernel[method];\r\n    }\r\n    if (!isFunction(method)) {\r\n        throw new TypeError('invalid method: kernel method must be a function!');\r\n    }\r\n    var extent = options.extent;\r\n    if (!isArray(extent) || extent.length === 0) {\r\n        var rangeArr_1 = [];\r\n        each(fields, function (field) {\r\n            var range = dv.range(field);\r\n            rangeArr_1 = rangeArr_1.concat(range);\r\n        });\r\n        extent = [Math.min.apply(Math, __spread(rangeArr_1)), Math.max.apply(Math, __spread(rangeArr_1))];\r\n    }\r\n    var bw = options.bandwidth;\r\n    if (isString(bw) && bandwidth[bw]) {\r\n        bw = bandwidth[bw](dv.getColumn(fields[0]));\r\n    }\r\n    else if (isFunction(bw)) {\r\n        bw = bw(dv.getColumn(fields[0]));\r\n    }\r\n    else if (!isNumber(bw) || bw <= 0) {\r\n        bw = bandwidth.nrd(dv.getColumn(fields[0]));\r\n    }\r\n    var seriesValues = getSeriesValues(extent, options.step ? options.step : bw);\r\n    var result = [];\r\n    var groupBy = options.groupBy;\r\n    var groups = partition(dv.rows, groupBy);\r\n    forIn(groups, function (group) {\r\n        var probalityDensityFunctionByField = {};\r\n        each(fields, function (field) {\r\n            var row = pick(group[0], groupBy);\r\n            probalityDensityFunctionByField[field] = kernelDensityEstimation(group.map(function (item) { return item[field]; }), method, bw);\r\n            var _a = __read(as, 3), key = _a[0], y = _a[1], size = _a[2];\r\n            row[key] = field;\r\n            row[y] = [];\r\n            row[size] = [];\r\n            each(seriesValues, function (yValue) {\r\n                var sizeValue = probalityDensityFunctionByField[field](yValue);\r\n                if (sizeValue >= options.minSize) {\r\n                    row[y].push(yValue);\r\n                    row[size].push(sizeValue);\r\n                }\r\n            });\r\n            result.push(row);\r\n        });\r\n    });\r\n    dv.rows = result;\r\n}\r\nregisterTransform('kernel-density-estimation', transform);\r\nregisterTransform('kde', transform);\r\nregisterTransform('KDE', transform);\r\nmodule.exports = {\r\n    KERNEL_METHODS: KERNEL_METHODS,\r\n    BANDWIDTH_METHODS: BANDWIDTH_METHODS\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kde.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\data-set\\src\\transform\\kde.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAGA,IAAM,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAC7C,IAAM,IAAI,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAC5C,IAAM,KAAK,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAC7C,IAAM,OAAO,GAAG,OAAO,CAAC,8BAA8B,CAAC,CAAC;AACxD,IAAM,UAAU,GAAG,OAAO,CAAC,iCAAiC,CAAC,CAAC;AAC9D,IAAM,QAAQ,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC1D,IAAM,QAAQ,GAAG,OAAO,CAAC,+BAA+B,CAAC,CAAC;AAC1D,IAAM,IAAI,GAAG,OAAO,CAAC,4BAA4B,CAAC,CAAC;AACnD,IAAM,IAAI,GAAG,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAC5C,IAAM,eAAe,GAAG,OAAO,CAAC,2BAA2B,CAAC,CAAC;AAC7D,IAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;AACzC,IAAM,SAAS,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAC/C,IAAM,SAAS,GAAG,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAE7C,IAAA,4DAAiB,CACQ;AAEzB,IAAA,sDAAS,CAC0B;AAEnC,IAAA,8EAAuB,CACQ;AAEjC,IAAM,eAAe,GAAG;IACtB,OAAO,EAAE,IAAI;IACb,EAAE,EAAE,CAAE,KAAK,EAAE,GAAG,EAAE,MAAM,CAAE;IAE1B,MAAM,EAAE,EAAE;IACV,MAAM,EAAE,UAAU;IAClB,SAAS,EAAE,KAAK;IAChB,IAAI,EAAE,CAAC;IACP,OAAO,EAAE,EAAE;CACZ,CAAC;AAEF,IAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;AACpC,IAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;AAE1C,SAAS,SAAS,CAAC,EAAE,EAAE,OAAO;IAC5B,OAAO,GAAG,MAAM,CAAC,EAAE,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;IAC/C,IAAM,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;IAClC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACzC,MAAM,IAAI,SAAS,CAAC,yDAAyD,CAAC,CAAC;KAChF;IACD,IAAM,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC;IACtB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;QACnC,MAAM,IAAI,SAAS,CAAC,4CAA4C,CAAC,CAAC;KACnE;IACD,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5B,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;QACpB,IAAI,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;YACzC,MAAM,IAAI,SAAS,CAAC,qBAAmB,MAAM,yBAAoB,cAAc,CAAC,IAAI,CAAC,IAAI,CAAG,CAAC,CAAC;SAC/F;QACD,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;KACzB;IACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;QACvB,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC,CAAC;KAC1E;IAED,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3C,IAAI,UAAQ,GAAG,EAAE,CAAC;QAClB,IAAI,CAAC,MAAM,EAAE,UAAA,KAAK;YAChB,IAAM,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YAC9B,UAAQ,GAAG,UAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QACH,MAAM,GAAG,CAAE,IAAI,CAAC,GAAG,OAAR,IAAI,WAAQ,UAAQ,IAAG,IAAI,CAAC,GAAG,OAAR,IAAI,WAAQ,UAAQ,GAAG,CAAC;KAC3D;IACD,IAAI,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC;IAC3B,IAAI,QAAQ,CAAC,EAAE,CAAC,IAAI,SAAS,CAAC,EAAE,CAAC,EAAE;QACjC,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC7C;SAAM,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE;QACzB,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAClC;SAAM,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;QACnC,EAAE,GAAG,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC7C;IACD,IAAM,YAAY,GAAG,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/E,IAAM,MAAM,GAAG,EAAE,CAAC;IAElB,IAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,IAAM,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC3C,KAAK,CAAC,MAAM,EAAE,UAAA,KAAK;QACjB,IAAM,+BAA+B,GAAG,EAAE,CAAC;QAC3C,IAAI,CAAC,MAAM,EAAE,UAAA,KAAK;YAChB,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACpC,+BAA+B,CAAC,KAAK,CAAC,GAAG,uBAAuB,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,EAAX,CAAW,CAAC,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;YACvG,IAAA,kBAAqB,EAAnB,WAAG,EAAE,SAAC,EAAE,YAAW,CAAC;YAC5B,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YACjB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;YACZ,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,EAAE,UAAA,MAAM;gBACvB,IAAM,SAAS,GAAG,+BAA+B,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;gBACjE,IAAI,SAAS,IAAI,OAAO,CAAC,OAAO,EAAE;oBAChC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACpB,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAC3B;YACH,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACnB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,IAAI,GAAG,MAAM,CAAC;AACnB,CAAC;AAED,iBAAiB,CAAC,2BAA2B,EAAE,SAAS,CAAC,CAAC;AAC1D,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AACpC,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AAEpC,MAAM,CAAC,OAAO,GAAG;IACf,cAAc,gBAAA;IACd,iBAAiB,mBAAA;CAClB,CAAC","sourcesContent":["/*\n * kernel density estimation\n */\nconst assign = require('@antv/util/lib/mix');\nconst each = require('@antv/util/lib/each');\nconst forIn = require('@antv/util/lib/each');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\nconst pick = require('@antv/util/lib/pick');\nconst getSeriesValues = require('../util/get-series-values');\nconst kernel = require('../util/kernel');\nconst bandwidth = require('../util/bandwidth');\nconst partition = require('../util/partition');\nconst {\n  registerTransform\n} = require('../data-set');\nconst {\n  getFields\n} = require('../util/option-parser');\nconst {\n  kernelDensityEstimation\n} = require('simple-statistics');\n\nconst DEFAULT_OPTIONS = {\n  minSize: 0.01,\n  as: [ 'key', 'y', 'size' ],\n  // fields: [ 'y1', 'y2' ], // required, one or more fields\n  extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]\n  method: 'gaussian', // kernel method: should be one of keys(kernel)\n  bandwidth: 'nrd', // bandwidth method to execute kernel function // nrd, silverman or a fixed bandwidth value\n  step: 0,\n  groupBy: []\n};\n\nconst KERNEL_METHODS = keys(kernel);\nconst BANDWIDTH_METHODS = keys(bandwidth);\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length < 1) {\n    throw new TypeError('invalid fields: must be an array of at least 1 strings!');\n  }\n  const as = options.as;\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('invalid as: must be an array of 3 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  let extent = options.extent;\n  if (!isArray(extent) || extent.length === 0) {\n    let rangeArr = [];\n    each(fields, field => {\n      const range = dv.range(field);\n      rangeArr = rangeArr.concat(range);\n    });\n    extent = [ Math.min(...rangeArr), Math.max(...rangeArr) ];\n  }\n  let bw = options.bandwidth;\n  if (isString(bw) && bandwidth[bw]) {\n    bw = bandwidth[bw](dv.getColumn(fields[0]));\n  } else if (isFunction(bw)) {\n    bw = bw(dv.getColumn(fields[0]));\n  } else if (!isNumber(bw) || bw <= 0) {\n    bw = bandwidth.nrd(dv.getColumn(fields[0]));\n  }\n  const seriesValues = getSeriesValues(extent, options.step ? options.step : bw);\n  const result = [];\n\n  const groupBy = options.groupBy;\n  const groups = partition(dv.rows, groupBy);\n  forIn(groups, group => {\n    const probalityDensityFunctionByField = {};\n    each(fields, field => {\n      const row = pick(group[0], groupBy);\n      probalityDensityFunctionByField[field] = kernelDensityEstimation(group.map(item => item[field]), method, bw);\n      const [ key, y, size ] = as;\n      row[key] = field;\n      row[y] = [];\n      row[size] = [];\n      each(seriesValues, yValue => {\n        const sizeValue = probalityDensityFunctionByField[field](yValue);\n        if (sizeValue >= options.minSize) {\n          row[y].push(yValue);\n          row[size].push(sizeValue);\n        }\n      });\n      result.push(row);\n    });\n  });\n\n  dv.rows = result;\n}\n\nregisterTransform('kernel-density-estimation', transform);\nregisterTransform('kde', transform);\nregisterTransform('KDE', transform);\n\nmodule.exports = {\n  KERNEL_METHODS,\n  BANDWIDTH_METHODS\n};\n"]}]}