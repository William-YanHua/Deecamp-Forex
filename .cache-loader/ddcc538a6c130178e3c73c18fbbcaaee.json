{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/density.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/density.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar assign = require('@antv/util/lib/mix');\nvar isArray = require('@antv/util/lib/type/is-array');\nvar isFunction = require('@antv/util/lib/type/is-function');\nvar isNumber = require('@antv/util/lib/type/is-number');\nvar isString = require('@antv/util/lib/type/is-string');\nvar keys = require('@antv/util/lib/object/keys');\nvar getSeriesValues = require('../../util/get-series-values');\nvar kernel = require('../../util/kernel');\nvar registerTransform = require('../../data-set').registerTransform;\nvar getFields = require('../../util/option-parser').getFields;\nvar silverman = require('../../util/bandwidth').silverman;\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'z'],\n    method: 'gaussian',\n    extent: [],\n    bandwidth: []\n};\nvar KERNEL_METHODS = keys(kernel);\nfunction transform(dv, options) {\n    options = assign({}, DEFAULT_OPTIONS, options);\n    var fields = getFields(options);\n    if (!isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings!');\n    }\n    var _a = __read(options.as, 3), asX = _a[0], asY = _a[1], asZ = _a[2];\n    if (!isString(asX) || !isString(asY) || !isString(asZ)) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method = options.method;\n    if (isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel[method];\n    }\n    if (!isFunction(method)) {\n        throw new TypeError('invalid method: kernel method must be a function!');\n    }\n    var _b = __read(fields, 2), xField = _b[0], yField = _b[1];\n    var _c = __read(options.extent, 2), extentX = _c[0], extentY = _c[1];\n    if (!isArray(extentX) || !isArray(extentY)) {\n        extentX = dv.range(xField);\n        extentY = dv.range(yField);\n    }\n    var _d = __read(options.bandwidth, 2), bwX = _d[0], bwY = _d[1];\n    if (!isNumber(bwX) || bwX <= 0 || !isNumber(bwY) || bwY <= 0) {\n        bwX = silverman(dv.getColumn(xField));\n        bwY = silverman(dv.getColumn(yField));\n    }\n    var seriesValuesX = getSeriesValues(extentX, bwX);\n    var seriesValuesY = getSeriesValues(extentY, bwY);\n    var count = dv.rows.length;\n    var result = [];\n    for (var i = 0; i < seriesValuesX.length; i++) {\n        for (var j = 0; j < seriesValuesY.length; j++) {\n            var sum = 0;\n            var x = seriesValuesX[i];\n            var y = seriesValuesY[j];\n            for (var k = 0; k < count; k++) {\n                sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\n            }\n            var z = (1 / (count * bwX * bwY)) * sum;\n            var row = {};\n            row[asX] = x;\n            row[asY] = y;\n            row[asZ] = z;\n            result.push(row);\n        }\n    }\n    dv.rows = result;\n}\nregisterTransform('kernel-smooth.density', transform);\nregisterTransform('kernel.density', transform);\nmodule.exports = {\n    KERNEL_METHODS: KERNEL_METHODS\n};\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/density.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/@antv/data-set/src/transform/kernel-smooth/density.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nconst assign = require('@antv/util/lib/mix');\nconst isArray = require('@antv/util/lib/type/is-array');\nconst isFunction = require('@antv/util/lib/type/is-function');\nconst isNumber = require('@antv/util/lib/type/is-number');\nconst isString = require('@antv/util/lib/type/is-string');\nconst keys = require('@antv/util/lib/object/keys');\n// const regression = require('regression');\nconst getSeriesValues = require('../../util/get-series-values');\n// const enclideanDistance = require('../../util/euclidean-distance');\nconst kernel = require('../../util/kernel');\nconst {\n  registerTransform\n} = require('../../data-set');\nconst {\n  getFields\n} = require('../../util/option-parser');\nconst {\n  silverman\n} = require('../../util/bandwidth');\n\nconst DEFAULT_OPTIONS = {\n  as: [ 'x', 'y', 'z' ],\n  // fields: [ 'x', 'y' ], // required, one or two fields\n  method: 'gaussian', // kernel method: should be one of keys(kernel)\n  extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]\n  bandwidth: [] // bandWidth to execute kernel function\n};\n\nconst KERNEL_METHODS = keys(kernel);\n\nfunction transform(dv, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const fields = getFields(options);\n  if (!isArray(fields) || fields.length !== 2) {\n    throw new TypeError('invalid fields: must be an array of 2 strings!');\n  }\n  const [ asX, asY, asZ ] = options.as;\n  if (!isString(asX) || !isString(asY) || !isString(asZ)) {\n    throw new TypeError('invalid as: must be an array of 3 strings!');\n  }\n  let method = options.method;\n  if (isString(method)) {\n    if (KERNEL_METHODS.indexOf(method) === -1) {\n      throw new TypeError(`invalid method: ${method}. Must be one of ${KERNEL_METHODS.join(', ')}`);\n    }\n    method = kernel[method];\n  }\n  if (!isFunction(method)) {\n    throw new TypeError('invalid method: kernel method must be a function!');\n  }\n\n  const [ xField, yField ] = fields;\n  let [ extentX, extentY ] = options.extent;\n  if (!isArray(extentX) || !isArray(extentY)) {\n    extentX = dv.range(xField);\n    extentY = dv.range(yField);\n  }\n  let [ bwX, bwY ] = options.bandwidth;\n  if (!isNumber(bwX) || bwX <= 0 || !isNumber(bwY) || bwY <= 0) {\n    bwX = silverman(dv.getColumn(xField));\n    bwY = silverman(dv.getColumn(yField));\n  }\n  const seriesValuesX = getSeriesValues(extentX, bwX);\n  const seriesValuesY = getSeriesValues(extentY, bwY);\n  const count = dv.rows.length;\n  const result = [];\n\n  for (let i = 0; i < seriesValuesX.length; i++) {\n    for (let j = 0; j < seriesValuesY.length; j++) {\n      let sum = 0;\n      const x = seriesValuesX[i];\n      const y = seriesValuesY[j];\n      for (let k = 0; k < count; k++) {\n        sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\n      }\n      const z = (1 / (count * bwX * bwY)) * sum;\n      const row = {};\n      row[asX] = x;\n      row[asY] = y;\n      row[asZ] = z;\n      result.push(row);\n    }\n  }\n\n  dv.rows = result;\n}\n\nregisterTransform('kernel-smooth.density', transform);\nregisterTransform('kernel.density', transform);\n\nmodule.exports = {\n  KERNEL_METHODS\n};\n"]}]}