{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenizer.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenizer.js","mtime":1516191690000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["'use strict';\nmodule.exports = factory;\nvar MERGEABLE_NODES = {\n    text: mergeText,\n    blockquote: mergeBlockquote\n};\nfunction mergeable(node) {\n    var start;\n    var end;\n    if (node.type !== 'text' || !node.position) {\n        return true;\n    }\n    start = node.position.start;\n    end = node.position.end;\n    return start.line !== end.line ||\n        end.column - start.column === node.value.length;\n}\nfunction mergeText(prev, node) {\n    prev.value += node.value;\n    return prev;\n}\nfunction mergeBlockquote(prev, node) {\n    if (this.options.commonmark) {\n        return node;\n    }\n    prev.children = prev.children.concat(node.children);\n    return prev;\n}\nfunction factory(type) {\n    return tokenize;\n    function tokenize(value, location) {\n        var self = this;\n        var offset = self.offset;\n        var tokens = [];\n        var methods = self[type + 'Methods'];\n        var tokenizers = self[type + 'Tokenizers'];\n        var line = location.line;\n        var column = location.column;\n        var index;\n        var length;\n        var method;\n        var name;\n        var matched;\n        var valueLength;\n        if (!value) {\n            return tokens;\n        }\n        eat.now = now;\n        eat.file = self.file;\n        updatePosition('');\n        while (value) {\n            index = -1;\n            length = methods.length;\n            matched = false;\n            while (++index < length) {\n                name = methods[index];\n                method = tokenizers[name];\n                if (method &&\n                    (!method.onlyAtStart || self.atStart) &&\n                    (!method.notInList || !self.inList) &&\n                    (!method.notInBlock || !self.inBlock) &&\n                    (!method.notInLink || !self.inLink)) {\n                    valueLength = value.length;\n                    method.apply(self, [eat, value]);\n                    matched = valueLength !== value.length;\n                    if (matched) {\n                        break;\n                    }\n                }\n            }\n            if (!matched) {\n                self.file.fail(new Error('Infinite loop'), eat.now());\n            }\n        }\n        self.eof = now();\n        return tokens;\n        function updatePosition(subvalue) {\n            var lastIndex = -1;\n            var index = subvalue.indexOf('\\n');\n            while (index !== -1) {\n                line++;\n                lastIndex = index;\n                index = subvalue.indexOf('\\n', index + 1);\n            }\n            if (lastIndex === -1) {\n                column += subvalue.length;\n            }\n            else {\n                column = subvalue.length - lastIndex;\n            }\n            if (line in offset) {\n                if (lastIndex !== -1) {\n                    column += offset[line];\n                }\n                else if (column <= offset[line]) {\n                    column = offset[line] + 1;\n                }\n            }\n        }\n        function getOffset() {\n            var indentation = [];\n            var pos = line + 1;\n            return function () {\n                var last = line + 1;\n                while (pos < last) {\n                    indentation.push((offset[pos] || 0) + 1);\n                    pos++;\n                }\n                return indentation;\n            };\n        }\n        function now() {\n            var pos = { line: line, column: column };\n            pos.offset = self.toOffset(pos);\n            return pos;\n        }\n        function Position(start) {\n            this.start = start;\n            this.end = now();\n        }\n        function validateEat(subvalue) {\n            if (value.substring(0, subvalue.length) !== subvalue) {\n                self.file.fail(new Error('Incorrectly eaten value: please report this ' +\n                    'warning on http://git.io/vg5Ft'), now());\n            }\n        }\n        function position() {\n            var before = now();\n            return update;\n            function update(node, indent) {\n                var prev = node.position;\n                var start = prev ? prev.start : before;\n                var combined = [];\n                var n = prev && prev.end.line;\n                var l = before.line;\n                node.position = new Position(start);\n                if (prev && indent && prev.indent) {\n                    combined = prev.indent;\n                    if (n < l) {\n                        while (++n < l) {\n                            combined.push((offset[n] || 0) + 1);\n                        }\n                        combined.push(before.column);\n                    }\n                    indent = combined.concat(indent);\n                }\n                node.position.indent = indent || [];\n                return node;\n            }\n        }\n        function add(node, parent) {\n            var children = parent ? parent.children : tokens;\n            var prev = children[children.length - 1];\n            if (prev &&\n                node.type === prev.type &&\n                node.type in MERGEABLE_NODES &&\n                mergeable(prev) &&\n                mergeable(node)) {\n                node = MERGEABLE_NODES[node.type].call(self, prev, node);\n            }\n            if (node !== prev) {\n                children.push(node);\n            }\n            if (self.atStart && tokens.length !== 0) {\n                self.exitStart();\n            }\n            return node;\n        }\n        function eat(subvalue) {\n            var indent = getOffset();\n            var pos = position();\n            var current = now();\n            validateEat(subvalue);\n            apply.reset = reset;\n            reset.test = test;\n            apply.test = test;\n            value = value.substring(subvalue.length);\n            updatePosition(subvalue);\n            indent = indent();\n            return apply;\n            function apply(node, parent) {\n                return pos(add(pos(node), parent), indent);\n            }\n            function reset() {\n                var node = apply.apply(null, arguments);\n                line = current.line;\n                column = current.column;\n                value = subvalue + value;\n                return node;\n            }\n            function test() {\n                var result = pos({});\n                line = current.line;\n                column = current.column;\n                value = subvalue + value;\n                return result.position;\n            }\n        }\n    }\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenizer.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenizer.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = factory;\n\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line ||\n      end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length;\n\n          method.apply(self, [eat, value]);\n\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {line: line, column: column};\n\n      pos.offset = self.toOffset(pos);\n\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this ' +\n            'warning on http://git.io/vg5Ft'\n          ),\n          now()\n        );\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        node.type in MERGEABLE_NODES &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n\n      validateEat(subvalue);\n\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n\n      value = value.substring(subvalue.length);\n\n      updatePosition(subvalue);\n\n      indent = indent();\n\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return result.position;\n      }\n    }\n  }\n}\n"]}]}