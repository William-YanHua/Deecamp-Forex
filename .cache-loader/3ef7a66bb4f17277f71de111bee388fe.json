{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\trough\\wrap.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\trough\\wrap.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["'use strict';\r\nvar slice = [].slice;\r\nmodule.exports = wrap;\r\nfunction wrap(fn, callback) {\r\n    var invoked;\r\n    return wrapped;\r\n    function wrapped() {\r\n        var params = slice.call(arguments, 0);\r\n        var callback = fn.length > params.length;\r\n        var result;\r\n        if (callback) {\r\n            params.push(done);\r\n        }\r\n        try {\r\n            result = fn.apply(null, params);\r\n        }\r\n        catch (err) {\r\n            if (callback && invoked) {\r\n                throw err;\r\n            }\r\n            return done(err);\r\n        }\r\n        if (!callback) {\r\n            if (result && typeof result.then === 'function') {\r\n                result.then(then, done);\r\n            }\r\n            else if (result instanceof Error) {\r\n                done(result);\r\n            }\r\n            else {\r\n                then(result);\r\n            }\r\n        }\r\n    }\r\n    function done() {\r\n        if (!invoked) {\r\n            invoked = true;\r\n            callback.apply(null, arguments);\r\n        }\r\n    }\r\n    function then(value) {\r\n        done(null, value);\r\n    }\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\trough\\wrap.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\trough\\wrap.js"],"names":[],"mappings":"AAAA,YAAY,CAAA;AAEZ,IAAI,KAAK,GAAG,EAAE,CAAC,KAAK,CAAA;AAEpB,MAAM,CAAC,OAAO,GAAG,IAAI,CAAA;AAKrB,SAAS,IAAI,CAAC,EAAE,EAAE,QAAQ;IACxB,IAAI,OAAO,CAAA;IAEX,OAAO,OAAO,CAAA;IAEd,SAAS,OAAO;QACd,IAAI,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;QACrC,IAAI,QAAQ,GAAG,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAA;QACxC,IAAI,MAAM,CAAA;QAEV,IAAI,QAAQ,EAAE;YACZ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SAClB;QAED,IAAI;YACF,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;SAChC;QAAC,OAAO,GAAG,EAAE;YAOZ,IAAI,QAAQ,IAAI,OAAO,EAAE;gBACvB,MAAM,GAAG,CAAA;aACV;YAED,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;SACjB;QAED,IAAI,CAAC,QAAQ,EAAE;YACb,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC/C,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;aACxB;iBAAM,IAAI,MAAM,YAAY,KAAK,EAAE;gBAClC,IAAI,CAAC,MAAM,CAAC,CAAA;aACb;iBAAM;gBACL,IAAI,CAAC,MAAM,CAAC,CAAA;aACb;SACF;IACH,CAAC;IAGD,SAAS,IAAI;QACX,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG,IAAI,CAAA;YAEd,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;SAChC;IACH,CAAC;IAID,SAAS,IAAI,CAAC,KAAK;QACjB,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;IACnB,CAAC;AACH,CAAC","sourcesContent":["'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n/* Wrap `fn`.  Can be sync or async; return a promise,\n * receive a completion handler, return new values and\n * errors. */\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (err) {\n      /* Well, this is quite the pickle.  `fn` received\n       * a callback and invoked it (thus continuing the\n       * pipeline), but later also threw an error.\n       * Weâ€™re not about to restart the pipeline again,\n       * so the only thing left to do is to throw the\n       * thing instea. */\n      if (callback && invoked) {\n        throw err\n      }\n\n      return done(err)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /* Invoke `next`, only once. */\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  /* Invoke `done` with one value.\n   * Tracks if an error is passed, too. */\n  function then(value) {\n    done(null, value)\n  }\n}\n"]}]}