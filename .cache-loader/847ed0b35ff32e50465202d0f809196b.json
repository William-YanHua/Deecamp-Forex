{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\dendrogram.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\dendrogram.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var util = require('../util');\r\nfunction WrappedTree(height, children) {\r\n    if (height === void 0) {\r\n        height = 0;\r\n    }\r\n    if (children === void 0) {\r\n        children = [];\r\n    }\r\n    var me = this;\r\n    me.x = me.y = 0;\r\n    me.leftChild = me.rightChild = null;\r\n    me.height = 0;\r\n    me.children = children;\r\n}\r\nvar DEFAULT_OPTIONS = {\r\n    isHorizontal: true,\r\n    nodeSep: 20,\r\n    nodeSize: 20,\r\n    rankSep: 200,\r\n    subTreeSep: 10\r\n};\r\nfunction convertBack(converted, root, isHorizontal) {\r\n    if (isHorizontal) {\r\n        root.x = converted.x;\r\n        root.y = converted.y;\r\n    }\r\n    else {\r\n        root.x = converted.y;\r\n        root.y = converted.x;\r\n    }\r\n    converted.children.forEach(function (child, i) {\r\n        convertBack(child, root.children[i], isHorizontal);\r\n    });\r\n}\r\nmodule.exports = function (root, options) {\r\n    if (options === void 0) {\r\n        options = {};\r\n    }\r\n    options = util.assign({}, DEFAULT_OPTIONS, options);\r\n    var maxDepth = 0;\r\n    function wrappedTreeFromNode(n) {\r\n        if (!n)\r\n            return null;\r\n        n.width = 0;\r\n        if (n.depth && n.depth > maxDepth) {\r\n            maxDepth = n.depth;\r\n        }\r\n        var children = n.children;\r\n        var childrenCount = children.length;\r\n        var t = new WrappedTree(n.height, []);\r\n        children.forEach(function (child, i) {\r\n            var childWT = wrappedTreeFromNode(child);\r\n            t.children.push(childWT);\r\n            if (i === 0) {\r\n                t.leftChild = childWT;\r\n            }\r\n            if (i === childrenCount - 1) {\r\n                t.rightChild = childWT;\r\n            }\r\n        });\r\n        t.originNode = n;\r\n        t.isLeaf = n.isLeaf();\r\n        return t;\r\n    }\r\n    function getDrawingDepth(t) {\r\n        if (t.isLeaf || t.children.length === 0) {\r\n            t.drawingDepth = maxDepth;\r\n        }\r\n        else {\r\n            var depths = t.children.map(function (child) {\r\n                return getDrawingDepth(child);\r\n            });\r\n            var minChildDepth = Math.min.apply(null, depths);\r\n            t.drawingDepth = minChildDepth - 1;\r\n        }\r\n        return t.drawingDepth;\r\n    }\r\n    var prevLeaf;\r\n    function position(t) {\r\n        t.x = t.drawingDepth * options.rankSep;\r\n        if (t.isLeaf) {\r\n            t.y = 0;\r\n            if (prevLeaf) {\r\n                t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\r\n                if (t.originNode.parent !== prevLeaf.originNode.parent) {\r\n                    t.y += options.subTreeSep;\r\n                }\r\n            }\r\n            prevLeaf = t;\r\n        }\r\n        else {\r\n            t.children.forEach(function (child) {\r\n                position(child);\r\n            });\r\n            t.y = (t.leftChild.y + t.rightChild.y) / 2;\r\n        }\r\n    }\r\n    var wt = wrappedTreeFromNode(root);\r\n    getDrawingDepth(wt);\r\n    position(wt);\r\n    convertBack(wt, root, options.isHorizontal);\r\n    return root;\r\n};\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\dendrogram.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\hierarchy\\lib\\layout\\dendrogram.js"],"names":[],"mappings":"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","sourcesContent":["// wrap tree node\n// TODO considering size\nvar util = require('../util');\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};"]}]}