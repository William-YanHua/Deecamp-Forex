{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/parent-dummy-chains.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/parent-dummy-chains.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["var _ = require(\"./lodash\");\nmodule.exports = parentDummyChains;\nfunction parentDummyChains(g) {\n    var postorderNums = postorder(g);\n    _.forEach(g.graph().dummyChains, function (v) {\n        var node = g.node(v);\n        var edgeObj = node.edgeObj;\n        var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n        var path = pathData.path;\n        var lca = pathData.lca;\n        var pathIdx = 0;\n        var pathV = path[pathIdx];\n        var ascending = true;\n        while (v !== edgeObj.w) {\n            node = g.node(v);\n            if (ascending) {\n                while ((pathV = path[pathIdx]) !== lca &&\n                    g.node(pathV).maxRank < node.rank) {\n                    pathIdx++;\n                }\n                if (pathV === lca) {\n                    ascending = false;\n                }\n            }\n            if (!ascending) {\n                while (pathIdx < path.length - 1 &&\n                    g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n                    pathIdx++;\n                }\n                pathV = path[pathIdx];\n            }\n            g.setParent(v, pathV);\n            v = g.successors(v)[0];\n        }\n    });\n}\nfunction findPath(g, postorderNums, v, w) {\n    var vPath = [];\n    var wPath = [];\n    var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n    var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n    var parent;\n    var lca;\n    parent = v;\n    do {\n        parent = g.parent(parent);\n        vPath.push(parent);\n    } while (parent &&\n        (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n    lca = parent;\n    parent = w;\n    while ((parent = g.parent(parent)) !== lca) {\n        wPath.push(parent);\n    }\n    return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\nfunction postorder(g) {\n    var result = {};\n    var lim = 0;\n    function dfs(v) {\n        var low = lim;\n        _.forEach(g.children(v), dfs);\n        result[v] = { low: low, lim: lim++ };\n    }\n    _.forEach(g.children(), dfs);\n    return result;\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/parent-dummy-chains.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/dagre/lib/parent-dummy-chains.js"],"names":[],"mappings":"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","sourcesContent":["var _ = require(\"./lodash\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n"]}]}