{"remainingRequest":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js??ref--4-1!/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/code-fenced.js","dependencies":[{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/code-fenced.js","mtime":1516191690000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["'use strict';\nvar trim = require('trim-trailing-lines');\nmodule.exports = fencedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\nfunction fencedCode(eat, value, silent) {\n    var self = this;\n    var settings = self.options;\n    var length = value.length + 1;\n    var index = 0;\n    var subvalue = '';\n    var fenceCount;\n    var marker;\n    var character;\n    var flag;\n    var queue;\n    var content;\n    var exdentedContent;\n    var closing;\n    var exdentedClosing;\n    var indent;\n    var now;\n    if (!settings.gfm) {\n        return;\n    }\n    while (index < length) {\n        character = value.charAt(index);\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n        subvalue += character;\n        index++;\n    }\n    indent = index;\n    character = value.charAt(index);\n    if (character !== C_TILDE && character !== C_TICK) {\n        return;\n    }\n    index++;\n    marker = character;\n    fenceCount = 1;\n    subvalue += character;\n    while (index < length) {\n        character = value.charAt(index);\n        if (character !== marker) {\n            break;\n        }\n        subvalue += character;\n        fenceCount++;\n        index++;\n    }\n    if (fenceCount < MIN_FENCE_COUNT) {\n        return;\n    }\n    while (index < length) {\n        character = value.charAt(index);\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n        subvalue += character;\n        index++;\n    }\n    flag = '';\n    queue = '';\n    while (index < length) {\n        character = value.charAt(index);\n        if (character === C_NEWLINE ||\n            character === C_TILDE ||\n            character === C_TICK) {\n            break;\n        }\n        if (character === C_SPACE || character === C_TAB) {\n            queue += character;\n        }\n        else {\n            flag += queue + character;\n            queue = '';\n        }\n        index++;\n    }\n    character = value.charAt(index);\n    if (character && character !== C_NEWLINE) {\n        return;\n    }\n    if (silent) {\n        return true;\n    }\n    now = eat.now();\n    now.column += subvalue.length;\n    now.offset += subvalue.length;\n    subvalue += flag;\n    flag = self.decode.raw(self.unescape(flag), now);\n    if (queue) {\n        subvalue += queue;\n    }\n    queue = '';\n    closing = '';\n    exdentedClosing = '';\n    content = '';\n    exdentedContent = '';\n    while (index < length) {\n        character = value.charAt(index);\n        content += closing;\n        exdentedContent += exdentedClosing;\n        closing = '';\n        exdentedClosing = '';\n        if (character !== C_NEWLINE) {\n            content += character;\n            exdentedClosing += character;\n            index++;\n            continue;\n        }\n        if (content) {\n            closing += character;\n            exdentedClosing += character;\n        }\n        else {\n            subvalue += character;\n        }\n        queue = '';\n        index++;\n        while (index < length) {\n            character = value.charAt(index);\n            if (character !== C_SPACE) {\n                break;\n            }\n            queue += character;\n            index++;\n        }\n        closing += queue;\n        exdentedClosing += queue.slice(indent);\n        if (queue.length >= CODE_INDENT_COUNT) {\n            continue;\n        }\n        queue = '';\n        while (index < length) {\n            character = value.charAt(index);\n            if (character !== marker) {\n                break;\n            }\n            queue += character;\n            index++;\n        }\n        closing += queue;\n        exdentedClosing += queue;\n        if (queue.length < fenceCount) {\n            continue;\n        }\n        queue = '';\n        while (index < length) {\n            character = value.charAt(index);\n            if (character !== C_SPACE && character !== C_TAB) {\n                break;\n            }\n            closing += character;\n            exdentedClosing += character;\n            index++;\n        }\n        if (!character || character === C_NEWLINE) {\n            break;\n        }\n    }\n    subvalue += content + closing;\n    return eat(subvalue)({\n        type: 'code',\n        lang: flag || null,\n        value: trim(exdentedContent)\n    });\n}\n",{"version":3,"file":"/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/code-fenced.js","sourceRoot":"","sources":["/run/media/williamyh/新加卷/project/Deecamp-project/system/Web/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\n\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}\n"]}]}