{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\venn.js\\build\\venn.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\venn.js\\build\\venn.js","mtime":1519150772000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-transition')) :\r\n        typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) :\r\n            (factory((global.venn = {}), global.d3, global.d3));\r\n}(this, (function (exports, d3Selection, d3Transition) {\r\n    'use strict';\r\n    var SMALL = 1e-10;\r\n    function intersectionArea(circles, stats) {\r\n        var intersectionPoints = getIntersectionPoints(circles);\r\n        var innerPoints = intersectionPoints.filter(function (p) {\r\n            return containedInCircles(p, circles);\r\n        });\r\n        var arcArea = 0, polygonArea = 0, arcs = [], i;\r\n        if (innerPoints.length > 1) {\r\n            var center = getCenter(innerPoints);\r\n            for (i = 0; i < innerPoints.length; ++i) {\r\n                var p = innerPoints[i];\r\n                p.angle = Math.atan2(p.x - center.x, p.y - center.y);\r\n            }\r\n            innerPoints.sort(function (a, b) { return b.angle - a.angle; });\r\n            var p2 = innerPoints[innerPoints.length - 1];\r\n            for (i = 0; i < innerPoints.length; ++i) {\r\n                var p1 = innerPoints[i];\r\n                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\r\n                var midPoint = { x: (p1.x + p2.x) / 2,\r\n                    y: (p1.y + p2.y) / 2 }, arc = null;\r\n                for (var j = 0; j < p1.parentIndex.length; ++j) {\r\n                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\r\n                        var circle = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y), a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\r\n                        var angleDiff = (a2 - a1);\r\n                        if (angleDiff < 0) {\r\n                            angleDiff += 2 * Math.PI;\r\n                        }\r\n                        var a = a2 - angleDiff / 2, width = distance(midPoint, {\r\n                            x: circle.x + circle.radius * Math.sin(a),\r\n                            y: circle.y + circle.radius * Math.cos(a)\r\n                        });\r\n                        if (width > circle.radius * 2) {\r\n                            width = circle.radius * 2;\r\n                        }\r\n                        if ((arc === null) || (arc.width > width)) {\r\n                            arc = { circle: circle,\r\n                                width: width,\r\n                                p1: p1,\r\n                                p2: p2 };\r\n                        }\r\n                    }\r\n                }\r\n                if (arc !== null) {\r\n                    arcs.push(arc);\r\n                    arcArea += circleArea(arc.circle.radius, arc.width);\r\n                    p2 = p1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var smallest = circles[0];\r\n            for (i = 1; i < circles.length; ++i) {\r\n                if (circles[i].radius < smallest.radius) {\r\n                    smallest = circles[i];\r\n                }\r\n            }\r\n            var disjoint = false;\r\n            for (i = 0; i < circles.length; ++i) {\r\n                if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\r\n                    disjoint = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (disjoint) {\r\n                arcArea = polygonArea = 0;\r\n            }\r\n            else {\r\n                arcArea = smallest.radius * smallest.radius * Math.PI;\r\n                arcs.push({ circle: smallest,\r\n                    p1: { x: smallest.x, y: smallest.y + smallest.radius },\r\n                    p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\r\n                    width: smallest.radius * 2 });\r\n            }\r\n        }\r\n        polygonArea /= 2;\r\n        if (stats) {\r\n            stats.area = arcArea + polygonArea;\r\n            stats.arcArea = arcArea;\r\n            stats.polygonArea = polygonArea;\r\n            stats.arcs = arcs;\r\n            stats.innerPoints = innerPoints;\r\n            stats.intersectionPoints = intersectionPoints;\r\n        }\r\n        return arcArea + polygonArea;\r\n    }\r\n    function containedInCircles(point, circles) {\r\n        for (var i = 0; i < circles.length; ++i) {\r\n            if (distance(point, circles[i]) > circles[i].radius + SMALL) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    function getIntersectionPoints(circles) {\r\n        var ret = [];\r\n        for (var i = 0; i < circles.length; ++i) {\r\n            for (var j = i + 1; j < circles.length; ++j) {\r\n                var intersect = circleCircleIntersection(circles[i], circles[j]);\r\n                for (var k = 0; k < intersect.length; ++k) {\r\n                    var p = intersect[k];\r\n                    p.parentIndex = [i, j];\r\n                    ret.push(p);\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function circleArea(r, width) {\r\n        return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\r\n    }\r\n    function distance(p1, p2) {\r\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\r\n            (p1.y - p2.y) * (p1.y - p2.y));\r\n    }\r\n    function circleOverlap(r1, r2, d) {\r\n        if (d >= r1 + r2) {\r\n            return 0;\r\n        }\r\n        if (d <= Math.abs(r1 - r2)) {\r\n            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\r\n        }\r\n        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\r\n        return circleArea(r1, w1) + circleArea(r2, w2);\r\n    }\r\n    function circleCircleIntersection(p1, p2) {\r\n        var d = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;\r\n        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\r\n            return [];\r\n        }\r\n        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);\r\n        return [{ x: x0 + rx, y: y0 - ry },\r\n            { x: x0 - rx, y: y0 + ry }];\r\n    }\r\n    function getCenter(points) {\r\n        var center = { x: 0, y: 0 };\r\n        for (var i = 0; i < points.length; ++i) {\r\n            center.x += points[i].x;\r\n            center.y += points[i].y;\r\n        }\r\n        center.x /= points.length;\r\n        center.y /= points.length;\r\n        return center;\r\n    }\r\n    function bisect(f, a, b, parameters) {\r\n        parameters = parameters || {};\r\n        var maxIterations = parameters.maxIterations || 100, tolerance = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;\r\n        if (fA * fB > 0) {\r\n            throw \"Initial bisect points must have opposite signs\";\r\n        }\r\n        if (fA === 0)\r\n            return a;\r\n        if (fB === 0)\r\n            return b;\r\n        for (var i = 0; i < maxIterations; ++i) {\r\n            delta /= 2;\r\n            var mid = a + delta, fMid = f(mid);\r\n            if (fMid * fA >= 0) {\r\n                a = mid;\r\n            }\r\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\r\n                return mid;\r\n            }\r\n        }\r\n        return a + delta;\r\n    }\r\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) {\r\n        r[i] = 0;\r\n    } return r; }\r\n    function zerosM(x, y) { return zeros(x).map(function () { return zeros(y); }); }\r\n    function dot(a, b) {\r\n        var ret = 0;\r\n        for (var i = 0; i < a.length; ++i) {\r\n            ret += a[i] * b[i];\r\n        }\r\n        return ret;\r\n    }\r\n    function norm2(a) {\r\n        return Math.sqrt(dot(a, a));\r\n    }\r\n    function scale(ret, value, c) {\r\n        for (var i = 0; i < value.length; ++i) {\r\n            ret[i] = value[i] * c;\r\n        }\r\n    }\r\n    function weightedSum(ret, w1, v1, w2, v2) {\r\n        for (var j = 0; j < ret.length; ++j) {\r\n            ret[j] = w1 * v1[j] + w2 * v2[j];\r\n        }\r\n    }\r\n    function nelderMead(f, x0, parameters) {\r\n        parameters = parameters || {};\r\n        var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 0.001, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = (parameters.rho !== undefined) ? parameters.rho : 1, chi = (parameters.chi !== undefined) ? parameters.chi : 2, psi = (parameters.psi !== undefined) ? parameters.psi : -0.5, sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5, maxDiff;\r\n        var N = x0.length, simplex = new Array(N + 1);\r\n        simplex[0] = x0;\r\n        simplex[0].fx = f(x0);\r\n        simplex[0].id = 0;\r\n        for (var i = 0; i < N; ++i) {\r\n            var point = x0.slice();\r\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\r\n            simplex[i + 1] = point;\r\n            simplex[i + 1].fx = f(point);\r\n            simplex[i + 1].id = i + 1;\r\n        }\r\n        function updateSimplex(value) {\r\n            for (var i = 0; i < value.length; i++) {\r\n                simplex[N][i] = value[i];\r\n            }\r\n            simplex[N].fx = value.fx;\r\n        }\r\n        var sortOrder = function (a, b) { return a.fx - b.fx; };\r\n        var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();\r\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\r\n            simplex.sort(sortOrder);\r\n            if (parameters.history) {\r\n                var sortedSimplex = simplex.map(function (x) {\r\n                    var state = x.slice();\r\n                    state.fx = x.fx;\r\n                    state.id = x.id;\r\n                    return state;\r\n                });\r\n                sortedSimplex.sort(function (a, b) { return a.id - b.id; });\r\n                parameters.history.push({ x: simplex[0].slice(),\r\n                    fx: simplex[0].fx,\r\n                    simplex: sortedSimplex });\r\n            }\r\n            maxDiff = 0;\r\n            for (i = 0; i < N; ++i) {\r\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\r\n            }\r\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\r\n                (maxDiff < minTolerance)) {\r\n                break;\r\n            }\r\n            for (i = 0; i < N; ++i) {\r\n                centroid[i] = 0;\r\n                for (var j = 0; j < N; ++j) {\r\n                    centroid[i] += simplex[j][i];\r\n                }\r\n                centroid[i] /= N;\r\n            }\r\n            var worst = simplex[N];\r\n            weightedSum(reflected, 1 + rho, centroid, -rho, worst);\r\n            reflected.fx = f(reflected);\r\n            if (reflected.fx < simplex[0].fx) {\r\n                weightedSum(expanded, 1 + chi, centroid, -chi, worst);\r\n                expanded.fx = f(expanded);\r\n                if (expanded.fx < reflected.fx) {\r\n                    updateSimplex(expanded);\r\n                }\r\n                else {\r\n                    updateSimplex(reflected);\r\n                }\r\n            }\r\n            else if (reflected.fx >= simplex[N - 1].fx) {\r\n                var shouldReduce = false;\r\n                if (reflected.fx > worst.fx) {\r\n                    weightedSum(contracted, 1 + psi, centroid, -psi, worst);\r\n                    contracted.fx = f(contracted);\r\n                    if (contracted.fx < worst.fx) {\r\n                        updateSimplex(contracted);\r\n                    }\r\n                    else {\r\n                        shouldReduce = true;\r\n                    }\r\n                }\r\n                else {\r\n                    weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\r\n                    contracted.fx = f(contracted);\r\n                    if (contracted.fx < reflected.fx) {\r\n                        updateSimplex(contracted);\r\n                    }\r\n                    else {\r\n                        shouldReduce = true;\r\n                    }\r\n                }\r\n                if (shouldReduce) {\r\n                    if (sigma >= 1)\r\n                        break;\r\n                    for (i = 1; i < simplex.length; ++i) {\r\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\r\n                        simplex[i].fx = f(simplex[i]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                updateSimplex(reflected);\r\n            }\r\n        }\r\n        simplex.sort(sortOrder);\r\n        return { fx: simplex[0].fx,\r\n            x: simplex[0] };\r\n    }\r\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\r\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk), phi = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;\r\n        a = a || 1;\r\n        c1 = c1 || 1e-6;\r\n        c2 = c2 || 0.1;\r\n        function zoom(a_lo, a_high, phi_lo) {\r\n            for (var iteration = 0; iteration < 16; ++iteration) {\r\n                a = (a_lo + a_high) / 2;\r\n                weightedSum(next.x, 1.0, current.x, a, pk);\r\n                phi = next.fx = f(next.x, next.fxprime);\r\n                phiPrime = dot(next.fxprime, pk);\r\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\r\n                    (phi >= phi_lo)) {\r\n                    a_high = a;\r\n                }\r\n                else {\r\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\r\n                        return a;\r\n                    }\r\n                    if (phiPrime * (a_high - a_lo) >= 0) {\r\n                        a_high = a_lo;\r\n                    }\r\n                    a_lo = a;\r\n                    phi_lo = phi;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n        for (var iteration = 0; iteration < 10; ++iteration) {\r\n            weightedSum(next.x, 1.0, current.x, a, pk);\r\n            phi = next.fx = f(next.x, next.fxprime);\r\n            phiPrime = dot(next.fxprime, pk);\r\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\r\n                (iteration && (phi >= phi_old))) {\r\n                return zoom(a0, a, phi_old);\r\n            }\r\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\r\n                return a;\r\n            }\r\n            if (phiPrime >= 0) {\r\n                return zoom(a, a0, phi);\r\n            }\r\n            phi_old = phi;\r\n            a0 = a;\r\n            a *= 2;\r\n        }\r\n        return a;\r\n    }\r\n    function conjugateGradient(f, initial, params) {\r\n        var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a = 1, maxIterations;\r\n        params = params || {};\r\n        maxIterations = params.maxIterations || initial.length * 20;\r\n        current.fx = f(current.x, current.fxprime);\r\n        pk = current.fxprime.slice();\r\n        scale(pk, current.fxprime, -1);\r\n        for (var i = 0; i < maxIterations; ++i) {\r\n            a = wolfeLineSearch(f, pk, current, next, a);\r\n            if (params.history) {\r\n                params.history.push({ x: current.x.slice(),\r\n                    fx: current.fx,\r\n                    fxprime: current.fxprime.slice(),\r\n                    alpha: a });\r\n            }\r\n            if (!a) {\r\n                scale(pk, current.fxprime, -1);\r\n            }\r\n            else {\r\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\r\n                var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\r\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\r\n                temp = current;\r\n                current = next;\r\n                next = temp;\r\n            }\r\n            if (norm2(current.fxprime) <= 1e-5) {\r\n                break;\r\n            }\r\n        }\r\n        if (params.history) {\r\n            params.history.push({ x: current.x.slice(),\r\n                fx: current.fx,\r\n                fxprime: current.fxprime.slice(),\r\n                alpha: a });\r\n        }\r\n        return current;\r\n    }\r\n    function venn(areas, parameters) {\r\n        parameters = parameters || {};\r\n        parameters.maxIterations = parameters.maxIterations || 500;\r\n        var initialLayout = parameters.initialLayout || bestInitialLayout;\r\n        var loss = parameters.lossFunction || lossFunction;\r\n        areas = addMissingAreas(areas);\r\n        var circles = initialLayout(areas, parameters);\r\n        var initial = [], setids = [], setid;\r\n        for (setid in circles) {\r\n            if (circles.hasOwnProperty(setid)) {\r\n                initial.push(circles[setid].x);\r\n                initial.push(circles[setid].y);\r\n                setids.push(setid);\r\n            }\r\n        }\r\n        var solution = nelderMead(function (values) {\r\n            var current = {};\r\n            for (var i = 0; i < setids.length; ++i) {\r\n                var setid = setids[i];\r\n                current[setid] = { x: values[2 * i],\r\n                    y: values[2 * i + 1],\r\n                    radius: circles[setid].radius,\r\n                };\r\n            }\r\n            return loss(current, areas);\r\n        }, initial, parameters);\r\n        var positions = solution.x;\r\n        for (var i = 0; i < setids.length; ++i) {\r\n            setid = setids[i];\r\n            circles[setid].x = positions[2 * i];\r\n            circles[setid].y = positions[2 * i + 1];\r\n        }\r\n        return circles;\r\n    }\r\n    var SMALL$1 = 1e-10;\r\n    function distanceFromIntersectArea(r1, r2, overlap) {\r\n        if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\r\n            return Math.abs(r1 - r2);\r\n        }\r\n        return bisect(function (distance$$1) {\r\n            return circleOverlap(r1, r2, distance$$1) - overlap;\r\n        }, 0, r1 + r2);\r\n    }\r\n    function addMissingAreas(areas) {\r\n        areas = areas.slice();\r\n        var ids = [], pairs = {}, i, j, a, b;\r\n        for (i = 0; i < areas.length; ++i) {\r\n            var area = areas[i];\r\n            if (area.sets.length == 1) {\r\n                ids.push(area.sets[0]);\r\n            }\r\n            else if (area.sets.length == 2) {\r\n                a = area.sets[0];\r\n                b = area.sets[1];\r\n                pairs[[a, b]] = true;\r\n                pairs[[b, a]] = true;\r\n            }\r\n        }\r\n        ids.sort(function (a, b) { return a > b; });\r\n        for (i = 0; i < ids.length; ++i) {\r\n            a = ids[i];\r\n            for (j = i + 1; j < ids.length; ++j) {\r\n                b = ids[j];\r\n                if (!([a, b] in pairs)) {\r\n                    areas.push({ 'sets': [a, b],\r\n                        'size': 0 });\r\n                }\r\n            }\r\n        }\r\n        return areas;\r\n    }\r\n    function getDistanceMatrices(areas, sets, setids) {\r\n        var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);\r\n        areas.filter(function (x) { return x.sets.length == 2; })\r\n            .map(function (current) {\r\n            var left = setids[current.sets[0]], right = setids[current.sets[1]], r1 = Math.sqrt(sets[left].size / Math.PI), r2 = Math.sqrt(sets[right].size / Math.PI), distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\r\n            distances[left][right] = distances[right][left] = distance$$1;\r\n            var c = 0;\r\n            if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\r\n                c = 1;\r\n            }\r\n            else if (current.size <= 1e-10) {\r\n                c = -1;\r\n            }\r\n            constraints[left][right] = constraints[right][left] = c;\r\n        });\r\n        return { distances: distances, constraints: constraints };\r\n    }\r\n    function constrainedMDSGradient(x, fxprime, distances, constraints) {\r\n        var loss = 0, i;\r\n        for (i = 0; i < fxprime.length; ++i) {\r\n            fxprime[i] = 0;\r\n        }\r\n        for (i = 0; i < distances.length; ++i) {\r\n            var xi = x[2 * i], yi = x[2 * i + 1];\r\n            for (var j = i + 1; j < distances.length; ++j) {\r\n                var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];\r\n                var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance$$1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;\r\n                if (((constraint > 0) && (distance$$1 <= dij)) ||\r\n                    ((constraint < 0) && (distance$$1 >= dij))) {\r\n                    continue;\r\n                }\r\n                loss += 2 * delta * delta;\r\n                fxprime[2 * i] += 4 * delta * (xi - xj);\r\n                fxprime[2 * i + 1] += 4 * delta * (yi - yj);\r\n                fxprime[2 * j] += 4 * delta * (xj - xi);\r\n                fxprime[2 * j + 1] += 4 * delta * (yj - yi);\r\n            }\r\n        }\r\n        return loss;\r\n    }\r\n    function bestInitialLayout(areas, params) {\r\n        var initial = greedyLayout(areas, params);\r\n        var loss = params.lossFunction || lossFunction;\r\n        if (areas.length >= 8) {\r\n            var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);\r\n            if (constrainedLoss + 1e-8 < greedyLoss) {\r\n                initial = constrained;\r\n            }\r\n        }\r\n        return initial;\r\n    }\r\n    function constrainedMDSLayout(areas, params) {\r\n        params = params || {};\r\n        var restarts = params.restarts || 10;\r\n        var sets = [], setids = {}, i;\r\n        for (i = 0; i < areas.length; ++i) {\r\n            var area = areas[i];\r\n            if (area.sets.length == 1) {\r\n                setids[area.sets[0]] = sets.length;\r\n                sets.push(area);\r\n            }\r\n        }\r\n        var matrices = getDistanceMatrices(areas, sets, setids), distances = matrices.distances, constraints = matrices.constraints;\r\n        var norm = norm2(distances.map(norm2)) / (distances.length);\r\n        distances = distances.map(function (row) {\r\n            return row.map(function (value) { return value / norm; });\r\n        });\r\n        var obj = function (x, fxprime) {\r\n            return constrainedMDSGradient(x, fxprime, distances, constraints);\r\n        };\r\n        var best, current;\r\n        for (i = 0; i < restarts; ++i) {\r\n            var initial = zeros(distances.length * 2).map(Math.random);\r\n            current = conjugateGradient(obj, initial, params);\r\n            if (!best || (current.fx < best.fx)) {\r\n                best = current;\r\n            }\r\n        }\r\n        var positions = best.x;\r\n        var circles = {};\r\n        for (i = 0; i < sets.length; ++i) {\r\n            var set = sets[i];\r\n            circles[set.sets[0]] = {\r\n                x: positions[2 * i] * norm,\r\n                y: positions[2 * i + 1] * norm,\r\n                radius: Math.sqrt(set.size / Math.PI)\r\n            };\r\n        }\r\n        if (params.history) {\r\n            for (i = 0; i < params.history.length; ++i) {\r\n                scale(params.history[i].x, norm);\r\n            }\r\n        }\r\n        return circles;\r\n    }\r\n    function greedyLayout(areas, params) {\r\n        var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\r\n        var circles = {}, setOverlaps = {}, set;\r\n        for (var i = 0; i < areas.length; ++i) {\r\n            var area = areas[i];\r\n            if (area.sets.length == 1) {\r\n                set = area.sets[0];\r\n                circles[set] = { x: 1e10, y: 1e10,\r\n                    rowid: circles.length,\r\n                    size: area.size,\r\n                    radius: Math.sqrt(area.size / Math.PI) };\r\n                setOverlaps[set] = [];\r\n            }\r\n        }\r\n        areas = areas.filter(function (a) { return a.sets.length == 2; });\r\n        for (i = 0; i < areas.length; ++i) {\r\n            var current = areas[i];\r\n            var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\r\n            var left = current.sets[0], right = current.sets[1];\r\n            if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\r\n                weight = 0;\r\n            }\r\n            setOverlaps[left].push({ set: right, size: current.size, weight: weight });\r\n            setOverlaps[right].push({ set: left, size: current.size, weight: weight });\r\n        }\r\n        var mostOverlapped = [];\r\n        for (set in setOverlaps) {\r\n            if (setOverlaps.hasOwnProperty(set)) {\r\n                var size = 0;\r\n                for (i = 0; i < setOverlaps[set].length; ++i) {\r\n                    size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\r\n                }\r\n                mostOverlapped.push({ set: set, size: size });\r\n            }\r\n        }\r\n        function sortOrder(a, b) {\r\n            return b.size - a.size;\r\n        }\r\n        mostOverlapped.sort(sortOrder);\r\n        var positioned = {};\r\n        function isPositioned(element) {\r\n            return element.set in positioned;\r\n        }\r\n        function positionSet(point, index) {\r\n            circles[index].x = point.x;\r\n            circles[index].y = point.y;\r\n            positioned[index] = true;\r\n        }\r\n        positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\r\n        for (i = 1; i < mostOverlapped.length; ++i) {\r\n            var setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);\r\n            set = circles[setIndex];\r\n            overlap.sort(sortOrder);\r\n            if (overlap.length === 0) {\r\n                throw \"ERROR: missing pairwise overlap information\";\r\n            }\r\n            var points = [];\r\n            for (var j = 0; j < overlap.length; ++j) {\r\n                var p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\r\n                points.push({ x: p1.x + d1, y: p1.y });\r\n                points.push({ x: p1.x - d1, y: p1.y });\r\n                points.push({ y: p1.y + d1, x: p1.x });\r\n                points.push({ y: p1.y - d1, x: p1.x });\r\n                for (var k = j + 1; k < overlap.length; ++k) {\r\n                    var p2 = circles[overlap[k].set], d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\r\n                    var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });\r\n                    for (var l = 0; l < extraPoints.length; ++l) {\r\n                        points.push(extraPoints[l]);\r\n                    }\r\n                }\r\n            }\r\n            var bestLoss = 1e50, bestPoint = points[0];\r\n            for (j = 0; j < points.length; ++j) {\r\n                circles[setIndex].x = points[j].x;\r\n                circles[setIndex].y = points[j].y;\r\n                var localLoss = loss(circles, areas);\r\n                if (localLoss < bestLoss) {\r\n                    bestLoss = localLoss;\r\n                    bestPoint = points[j];\r\n                }\r\n            }\r\n            positionSet(bestPoint, setIndex);\r\n        }\r\n        return circles;\r\n    }\r\n    function lossFunction(sets, overlaps) {\r\n        var output = 0;\r\n        function getCircles(indices) {\r\n            return indices.map(function (i) { return sets[i]; });\r\n        }\r\n        for (var i = 0; i < overlaps.length; ++i) {\r\n            var area = overlaps[i], overlap;\r\n            if (area.sets.length == 1) {\r\n                continue;\r\n            }\r\n            else if (area.sets.length == 2) {\r\n                var left = sets[area.sets[0]], right = sets[area.sets[1]];\r\n                overlap = circleOverlap(left.radius, right.radius, distance(left, right));\r\n            }\r\n            else {\r\n                overlap = intersectionArea(getCircles(area.sets));\r\n            }\r\n            var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\r\n            output += weight * (overlap - area.size) * (overlap - area.size);\r\n        }\r\n        return output;\r\n    }\r\n    function orientateCircles(circles, orientation, orientationOrder) {\r\n        if (orientationOrder === null) {\r\n            circles.sort(function (a, b) { return b.radius - a.radius; });\r\n        }\r\n        else {\r\n            circles.sort(orientationOrder);\r\n        }\r\n        var i;\r\n        if (circles.length > 0) {\r\n            var largestX = circles[0].x, largestY = circles[0].y;\r\n            for (i = 0; i < circles.length; ++i) {\r\n                circles[i].x -= largestX;\r\n                circles[i].y -= largestY;\r\n            }\r\n        }\r\n        if (circles.length == 2) {\r\n            var dist = distance(circles[0], circles[1]);\r\n            if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\r\n                circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\r\n                circles[1].y = circles[0].y;\r\n            }\r\n        }\r\n        if (circles.length > 1) {\r\n            var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation, c = Math.cos(rotation), s = Math.sin(rotation), x, y;\r\n            for (i = 0; i < circles.length; ++i) {\r\n                x = circles[i].x;\r\n                y = circles[i].y;\r\n                circles[i].x = c * x - s * y;\r\n                circles[i].y = s * x + c * y;\r\n            }\r\n        }\r\n        if (circles.length > 2) {\r\n            var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\r\n            while (angle < 0) {\r\n                angle += 2 * Math.PI;\r\n            }\r\n            while (angle > 2 * Math.PI) {\r\n                angle -= 2 * Math.PI;\r\n            }\r\n            if (angle > Math.PI) {\r\n                var slope = circles[1].y / (1e-10 + circles[1].x);\r\n                for (i = 0; i < circles.length; ++i) {\r\n                    var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\r\n                    circles[i].x = 2 * d - circles[i].x;\r\n                    circles[i].y = 2 * d * slope - circles[i].y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function disjointCluster(circles) {\r\n        circles.map(function (circle) { circle.parent = circle; });\r\n        function find(circle) {\r\n            if (circle.parent !== circle) {\r\n                circle.parent = find(circle.parent);\r\n            }\r\n            return circle.parent;\r\n        }\r\n        function union(x, y) {\r\n            var xRoot = find(x), yRoot = find(y);\r\n            xRoot.parent = yRoot;\r\n        }\r\n        for (var i = 0; i < circles.length; ++i) {\r\n            for (var j = i + 1; j < circles.length; ++j) {\r\n                var maxDistance = circles[i].radius + circles[j].radius;\r\n                if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\r\n                    union(circles[j], circles[i]);\r\n                }\r\n            }\r\n        }\r\n        var disjointClusters = {}, setid;\r\n        for (i = 0; i < circles.length; ++i) {\r\n            setid = find(circles[i]).parent.setid;\r\n            if (!(setid in disjointClusters)) {\r\n                disjointClusters[setid] = [];\r\n            }\r\n            disjointClusters[setid].push(circles[i]);\r\n        }\r\n        circles.map(function (circle) { delete circle.parent; });\r\n        var ret = [];\r\n        for (setid in disjointClusters) {\r\n            if (disjointClusters.hasOwnProperty(setid)) {\r\n                ret.push(disjointClusters[setid]);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function getBoundingBox(circles) {\r\n        var minMax = function (d) {\r\n            var hi = Math.max.apply(null, circles.map(function (c) { return c[d] + c.radius; })), lo = Math.min.apply(null, circles.map(function (c) { return c[d] - c.radius; }));\r\n            return { max: hi, min: lo };\r\n        };\r\n        return { xRange: minMax('x'), yRange: minMax('y') };\r\n    }\r\n    function normalizeSolution(solution, orientation, orientationOrder) {\r\n        if (orientation === null) {\r\n            orientation = Math.PI / 2;\r\n        }\r\n        var circles = [], i, setid;\r\n        for (setid in solution) {\r\n            if (solution.hasOwnProperty(setid)) {\r\n                var previous = solution[setid];\r\n                circles.push({ x: previous.x,\r\n                    y: previous.y,\r\n                    radius: previous.radius,\r\n                    setid: setid });\r\n            }\r\n        }\r\n        var clusters = disjointCluster(circles);\r\n        for (i = 0; i < clusters.length; ++i) {\r\n            orientateCircles(clusters[i], orientation, orientationOrder);\r\n            var bounds = getBoundingBox(clusters[i]);\r\n            clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\r\n            clusters[i].bounds = bounds;\r\n        }\r\n        clusters.sort(function (a, b) { return b.size - a.size; });\r\n        circles = clusters[0];\r\n        var returnBounds = circles.bounds;\r\n        var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\r\n        function addCluster(cluster, right, bottom) {\r\n            if (!cluster)\r\n                return;\r\n            var bounds = cluster.bounds, xOffset, yOffset, centreing;\r\n            if (right) {\r\n                xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\r\n            }\r\n            else {\r\n                xOffset = returnBounds.xRange.max - bounds.xRange.max;\r\n                centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\r\n                    (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\r\n                if (centreing < 0)\r\n                    xOffset += centreing;\r\n            }\r\n            if (bottom) {\r\n                yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\r\n            }\r\n            else {\r\n                yOffset = returnBounds.yRange.max - bounds.yRange.max;\r\n                centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\r\n                    (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\r\n                if (centreing < 0)\r\n                    yOffset += centreing;\r\n            }\r\n            for (var j = 0; j < cluster.length; ++j) {\r\n                cluster[j].x += xOffset;\r\n                cluster[j].y += yOffset;\r\n                circles.push(cluster[j]);\r\n            }\r\n        }\r\n        var index = 1;\r\n        while (index < clusters.length) {\r\n            addCluster(clusters[index], true, false);\r\n            addCluster(clusters[index + 1], false, true);\r\n            addCluster(clusters[index + 2], true, true);\r\n            index += 3;\r\n            returnBounds = getBoundingBox(circles);\r\n        }\r\n        var ret = {};\r\n        for (i = 0; i < circles.length; ++i) {\r\n            ret[circles[i].setid] = circles[i];\r\n        }\r\n        return ret;\r\n    }\r\n    function scaleSolution(solution, width, height, padding) {\r\n        var circles = [], setids = [];\r\n        for (var setid in solution) {\r\n            if (solution.hasOwnProperty(setid)) {\r\n                setids.push(setid);\r\n                circles.push(solution[setid]);\r\n            }\r\n        }\r\n        width -= 2 * padding;\r\n        height -= 2 * padding;\r\n        var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;\r\n        if ((xRange.max == xRange.min) ||\r\n            (yRange.max == yRange.min)) {\r\n            console.log(\"not scaling solution: zero size detected\");\r\n            return solution;\r\n        }\r\n        var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\r\n        var scaled = {};\r\n        for (var i = 0; i < circles.length; ++i) {\r\n            var circle = circles[i];\r\n            scaled[setids[i]] = {\r\n                radius: scaling * circle.radius,\r\n                x: padding + xOffset + (circle.x - xRange.min) * scaling,\r\n                y: padding + yOffset + (circle.y - yRange.min) * scaling,\r\n            };\r\n        }\r\n        return scaled;\r\n    }\r\n    function VennDiagram() {\r\n        var width = 600, height = 350, padding = 15, duration = 1000, orientation = Math.PI / 2, normalize = true, wrap = true, styled = true, fontSize = null, orientationOrder = null, colourMap = {}, colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"], colourIndex = 0, colours = function (key) {\r\n            if (key in colourMap) {\r\n                return colourMap[key];\r\n            }\r\n            var ret = colourMap[key] = colourScheme[colourIndex];\r\n            colourIndex += 1;\r\n            if (colourIndex >= colourScheme.length) {\r\n                colourIndex = 0;\r\n            }\r\n            return ret;\r\n        }, layoutFunction = venn, loss = lossFunction;\r\n        function chart(selection) {\r\n            var data = selection.datum();\r\n            var toremove = {};\r\n            data.forEach(function (datum) {\r\n                if ((datum.size == 0) && datum.sets.length == 1) {\r\n                    toremove[datum.sets[0]] = 1;\r\n                }\r\n            });\r\n            data = data.filter(function (datum) {\r\n                return !datum.sets.some(function (set) { return set in toremove; });\r\n            });\r\n            var circles = {};\r\n            var textCentres = {};\r\n            if (data.length > 0) {\r\n                var solution = layoutFunction(data, { lossFunction: loss });\r\n                if (normalize) {\r\n                    solution = normalizeSolution(solution, orientation, orientationOrder);\r\n                }\r\n                circles = scaleSolution(solution, width, height, padding);\r\n                textCentres = computeTextCentres(circles, data);\r\n            }\r\n            var labels = {};\r\n            data.forEach(function (datum) {\r\n                if (datum.label) {\r\n                    labels[datum.sets] = datum.label;\r\n                }\r\n            });\r\n            function label(d) {\r\n                if (d.sets in labels) {\r\n                    return labels[d.sets];\r\n                }\r\n                if (d.sets.length == 1) {\r\n                    return '' + d.sets[0];\r\n                }\r\n            }\r\n            selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\r\n            var svg = selection.select(\"svg\")\r\n                .attr(\"width\", width)\r\n                .attr(\"height\", height);\r\n            var previous = {}, hasPrevious = false;\r\n            svg.selectAll(\".venn-area path\").each(function (d) {\r\n                var path = d3Selection.select(this).attr(\"d\");\r\n                if ((d.sets.length == 1) && path) {\r\n                    hasPrevious = true;\r\n                    previous[d.sets[0]] = circleFromPath(path);\r\n                }\r\n            });\r\n            var pathTween = function (d) {\r\n                return function (t) {\r\n                    var c = d.sets.map(function (set) {\r\n                        var start = previous[set], end = circles[set];\r\n                        if (!start) {\r\n                            start = { x: width / 2, y: height / 2, radius: 1 };\r\n                        }\r\n                        if (!end) {\r\n                            end = { x: width / 2, y: height / 2, radius: 1 };\r\n                        }\r\n                        return { 'x': start.x * (1 - t) + end.x * t,\r\n                            'y': start.y * (1 - t) + end.y * t,\r\n                            'radius': start.radius * (1 - t) + end.radius * t };\r\n                    });\r\n                    return intersectionAreaPath(c);\r\n                };\r\n            };\r\n            var nodes = svg.selectAll(\".venn-area\")\r\n                .data(data, function (d) { return d.sets; });\r\n            var enter = nodes.enter()\r\n                .append('g')\r\n                .attr(\"class\", function (d) {\r\n                return \"venn-area venn-\" +\r\n                    (d.sets.length == 1 ? \"circle\" : \"intersection\");\r\n            })\r\n                .attr(\"data-venn-sets\", function (d) {\r\n                return d.sets.join(\"_\");\r\n            });\r\n            var enterPath = enter.append(\"path\"), enterText = enter.append(\"text\")\r\n                .attr(\"class\", \"label\")\r\n                .text(function (d) { return label(d); })\r\n                .attr(\"text-anchor\", \"middle\")\r\n                .attr(\"dy\", \".35em\")\r\n                .attr(\"x\", width / 2)\r\n                .attr(\"y\", height / 2);\r\n            if (styled) {\r\n                enterPath.style(\"fill-opacity\", \"0\")\r\n                    .filter(function (d) { return d.sets.length == 1; })\r\n                    .style(\"fill\", function (d) { return colours(d.sets); })\r\n                    .style(\"fill-opacity\", \".25\");\r\n                enterText\r\n                    .style(\"fill\", function (d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\r\n            }\r\n            var update = selection;\r\n            if (hasPrevious) {\r\n                update = selection.transition(\"venn\").duration(duration);\r\n                update.selectAll(\"path\")\r\n                    .attrTween(\"d\", pathTween);\r\n            }\r\n            else {\r\n                update.selectAll(\"path\")\r\n                    .attr(\"d\", function (d) {\r\n                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\r\n                });\r\n            }\r\n            var updateText = update.selectAll(\"text\")\r\n                .filter(function (d) { return d.sets in textCentres; })\r\n                .text(function (d) { return label(d); })\r\n                .attr(\"x\", function (d) { return Math.floor(textCentres[d.sets].x); })\r\n                .attr(\"y\", function (d) { return Math.floor(textCentres[d.sets].y); });\r\n            if (wrap) {\r\n                if (hasPrevious) {\r\n                    if ('on' in updateText) {\r\n                        updateText.on(\"end\", wrapText(circles, label));\r\n                    }\r\n                    else {\r\n                        updateText.each(\"end\", wrapText(circles, label));\r\n                    }\r\n                }\r\n                else {\r\n                    updateText.each(wrapText(circles, label));\r\n                }\r\n            }\r\n            var exit = nodes.exit().transition('venn').duration(duration).remove();\r\n            exit.selectAll(\"path\")\r\n                .attrTween(\"d\", pathTween);\r\n            var exitText = exit.selectAll(\"text\")\r\n                .attr(\"x\", width / 2)\r\n                .attr(\"y\", height / 2);\r\n            if (fontSize !== null) {\r\n                enterText.style(\"font-size\", \"0px\");\r\n                updateText.style(\"font-size\", fontSize);\r\n                exitText.style(\"font-size\", \"0px\");\r\n            }\r\n            return { 'circles': circles,\r\n                'textCentres': textCentres,\r\n                'nodes': nodes,\r\n                'enter': enter,\r\n                'update': update,\r\n                'exit': exit };\r\n        }\r\n        chart.wrap = function (_) {\r\n            if (!arguments.length)\r\n                return wrap;\r\n            wrap = _;\r\n            return chart;\r\n        };\r\n        chart.width = function (_) {\r\n            if (!arguments.length)\r\n                return width;\r\n            width = _;\r\n            return chart;\r\n        };\r\n        chart.height = function (_) {\r\n            if (!arguments.length)\r\n                return height;\r\n            height = _;\r\n            return chart;\r\n        };\r\n        chart.padding = function (_) {\r\n            if (!arguments.length)\r\n                return padding;\r\n            padding = _;\r\n            return chart;\r\n        };\r\n        chart.colours = function (_) {\r\n            if (!arguments.length)\r\n                return colours;\r\n            colours = _;\r\n            return chart;\r\n        };\r\n        chart.fontSize = function (_) {\r\n            if (!arguments.length)\r\n                return fontSize;\r\n            fontSize = _;\r\n            return chart;\r\n        };\r\n        chart.duration = function (_) {\r\n            if (!arguments.length)\r\n                return duration;\r\n            duration = _;\r\n            return chart;\r\n        };\r\n        chart.layoutFunction = function (_) {\r\n            if (!arguments.length)\r\n                return layoutFunction;\r\n            layoutFunction = _;\r\n            return chart;\r\n        };\r\n        chart.normalize = function (_) {\r\n            if (!arguments.length)\r\n                return normalize;\r\n            normalize = _;\r\n            return chart;\r\n        };\r\n        chart.styled = function (_) {\r\n            if (!arguments.length)\r\n                return styled;\r\n            styled = _;\r\n            return chart;\r\n        };\r\n        chart.orientation = function (_) {\r\n            if (!arguments.length)\r\n                return orientation;\r\n            orientation = _;\r\n            return chart;\r\n        };\r\n        chart.orientationOrder = function (_) {\r\n            if (!arguments.length)\r\n                return orientationOrder;\r\n            orientationOrder = _;\r\n            return chart;\r\n        };\r\n        chart.lossFunction = function (_) {\r\n            if (!arguments.length)\r\n                return loss;\r\n            loss = _;\r\n            return chart;\r\n        };\r\n        return chart;\r\n    }\r\n    function wrapText(circles, labeller) {\r\n        return function () {\r\n            var text = d3Selection.select(this), data = text.datum(), width = circles[data.sets[0]].radius || 50, label = labeller(data) || '';\r\n            var words = label.split(/\\s+/).reverse(), maxLines = 3, minChars = (label.length + words.length) / maxLines, word = words.pop(), line = [word], joined, lineNumber = 0, lineHeight = 1.1, tspan = text.text(null).append(\"tspan\").text(word);\r\n            while (true) {\r\n                word = words.pop();\r\n                if (!word)\r\n                    break;\r\n                line.push(word);\r\n                joined = line.join(\" \");\r\n                tspan.text(joined);\r\n                if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\r\n                    line.pop();\r\n                    tspan.text(line.join(\" \"));\r\n                    line = [word];\r\n                    tspan = text.append(\"tspan\").text(word);\r\n                    lineNumber++;\r\n                }\r\n            }\r\n            var initial = 0.35 - lineNumber * lineHeight / 2, x = text.attr(\"x\"), y = text.attr(\"y\");\r\n            text.selectAll(\"tspan\")\r\n                .attr(\"x\", x)\r\n                .attr(\"y\", y)\r\n                .attr(\"dy\", function (d, i) {\r\n                return (initial + i * lineHeight) + \"em\";\r\n            });\r\n        };\r\n    }\r\n    function circleMargin(current, interior, exterior) {\r\n        var margin = interior[0].radius - distance(interior[0], current), i, m;\r\n        for (i = 1; i < interior.length; ++i) {\r\n            m = interior[i].radius - distance(interior[i], current);\r\n            if (m <= margin) {\r\n                margin = m;\r\n            }\r\n        }\r\n        for (i = 0; i < exterior.length; ++i) {\r\n            m = distance(exterior[i], current) - exterior[i].radius;\r\n            if (m <= margin) {\r\n                margin = m;\r\n            }\r\n        }\r\n        return margin;\r\n    }\r\n    function computeTextCentre(interior, exterior) {\r\n        var points = [], i;\r\n        for (i = 0; i < interior.length; ++i) {\r\n            var c = interior[i];\r\n            points.push({ x: c.x, y: c.y });\r\n            points.push({ x: c.x + c.radius / 2, y: c.y });\r\n            points.push({ x: c.x - c.radius / 2, y: c.y });\r\n            points.push({ x: c.x, y: c.y + c.radius / 2 });\r\n            points.push({ x: c.x, y: c.y - c.radius / 2 });\r\n        }\r\n        var initial = points[0], margin = circleMargin(points[0], interior, exterior);\r\n        for (i = 1; i < points.length; ++i) {\r\n            var m = circleMargin(points[i], interior, exterior);\r\n            if (m >= margin) {\r\n                initial = points[i];\r\n                margin = m;\r\n            }\r\n        }\r\n        var solution = nelderMead(function (p) { return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior); }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;\r\n        var ret = { x: solution[0], y: solution[1] };\r\n        var valid = true;\r\n        for (i = 0; i < interior.length; ++i) {\r\n            if (distance(ret, interior[i]) > interior[i].radius) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        for (i = 0; i < exterior.length; ++i) {\r\n            if (distance(ret, exterior[i]) < exterior[i].radius) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        if (!valid) {\r\n            if (interior.length == 1) {\r\n                ret = { x: interior[0].x, y: interior[0].y };\r\n            }\r\n            else {\r\n                var areaStats = {};\r\n                intersectionArea(interior, areaStats);\r\n                if (areaStats.arcs.length === 0) {\r\n                    ret = { 'x': 0, 'y': -1000, disjoint: true };\r\n                }\r\n                else if (areaStats.arcs.length == 1) {\r\n                    ret = { 'x': areaStats.arcs[0].circle.x,\r\n                        'y': areaStats.arcs[0].circle.y };\r\n                }\r\n                else if (exterior.length) {\r\n                    ret = computeTextCentre(interior, []);\r\n                }\r\n                else {\r\n                    ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function getOverlappingCircles(circles) {\r\n        var ret = {}, circleids = [];\r\n        for (var circleid in circles) {\r\n            circleids.push(circleid);\r\n            ret[circleid] = [];\r\n        }\r\n        for (var i = 0; i < circleids.length; i++) {\r\n            var a = circles[circleids[i]];\r\n            for (var j = i + 1; j < circleids.length; ++j) {\r\n                var b = circles[circleids[j]], d = distance(a, b);\r\n                if (d + b.radius <= a.radius + 1e-10) {\r\n                    ret[circleids[j]].push(circleids[i]);\r\n                }\r\n                else if (d + a.radius <= b.radius + 1e-10) {\r\n                    ret[circleids[i]].push(circleids[j]);\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function computeTextCentres(circles, areas) {\r\n        var ret = {}, overlapped = getOverlappingCircles(circles);\r\n        for (var i = 0; i < areas.length; ++i) {\r\n            var area = areas[i].sets, areaids = {}, exclude = {};\r\n            for (var j = 0; j < area.length; ++j) {\r\n                areaids[area[j]] = true;\r\n                var overlaps = overlapped[area[j]];\r\n                for (var k = 0; k < overlaps.length; ++k) {\r\n                    exclude[overlaps[k]] = true;\r\n                }\r\n            }\r\n            var interior = [], exterior = [];\r\n            for (var setid in circles) {\r\n                if (setid in areaids) {\r\n                    interior.push(circles[setid]);\r\n                }\r\n                else if (!(setid in exclude)) {\r\n                    exterior.push(circles[setid]);\r\n                }\r\n            }\r\n            var centre = computeTextCentre(interior, exterior);\r\n            ret[area] = centre;\r\n            if (centre.disjoint && (areas[i].size > 0)) {\r\n                console.log(\"WARNING: area \" + area + \" not represented on screen\");\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function sortAreas(div, relativeTo) {\r\n        var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\r\n        var exclude = {};\r\n        for (var i = 0; i < relativeTo.sets.length; ++i) {\r\n            var check = relativeTo.sets[i];\r\n            for (var setid in overlaps) {\r\n                var overlap = overlaps[setid];\r\n                for (var j = 0; j < overlap.length; ++j) {\r\n                    if (overlap[j] == check) {\r\n                        exclude[setid] = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function shouldExclude(sets) {\r\n            for (var i = 0; i < sets.length; ++i) {\r\n                if (!(sets[i] in exclude)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        div.selectAll(\"g\").sort(function (a, b) {\r\n            if (a.sets.length != b.sets.length) {\r\n                return a.sets.length - b.sets.length;\r\n            }\r\n            if (a == relativeTo) {\r\n                return shouldExclude(b.sets) ? -1 : 1;\r\n            }\r\n            if (b == relativeTo) {\r\n                return shouldExclude(a.sets) ? 1 : -1;\r\n            }\r\n            return b.size - a.size;\r\n        });\r\n    }\r\n    function circlePath(x, y, r) {\r\n        var ret = [];\r\n        ret.push(\"\\nM\", x, y);\r\n        ret.push(\"\\nm\", -r, 0);\r\n        ret.push(\"\\na\", r, r, 0, 1, 0, r * 2, 0);\r\n        ret.push(\"\\na\", r, r, 0, 1, 0, -r * 2, 0);\r\n        return ret.join(\" \");\r\n    }\r\n    function circleFromPath(path) {\r\n        var tokens = path.split(' ');\r\n        return { 'x': parseFloat(tokens[1]),\r\n            'y': parseFloat(tokens[2]),\r\n            'radius': -parseFloat(tokens[4])\r\n        };\r\n    }\r\n    function intersectionAreaPath(circles) {\r\n        var stats = {};\r\n        intersectionArea(circles, stats);\r\n        var arcs = stats.arcs;\r\n        if (arcs.length === 0) {\r\n            return \"M 0 0\";\r\n        }\r\n        else if (arcs.length == 1) {\r\n            var circle = arcs[0].circle;\r\n            return circlePath(circle.x, circle.y, circle.radius);\r\n        }\r\n        else {\r\n            var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\r\n            for (var i = 0; i < arcs.length; ++i) {\r\n                var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\r\n                ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\r\n            }\r\n            return ret.join(\" \");\r\n        }\r\n    }\r\n    exports.intersectionArea = intersectionArea;\r\n    exports.circleCircleIntersection = circleCircleIntersection;\r\n    exports.circleOverlap = circleOverlap;\r\n    exports.circleArea = circleArea;\r\n    exports.distance = distance;\r\n    exports.venn = venn;\r\n    exports.greedyLayout = greedyLayout;\r\n    exports.scaleSolution = scaleSolution;\r\n    exports.normalizeSolution = normalizeSolution;\r\n    exports.bestInitialLayout = bestInitialLayout;\r\n    exports.lossFunction = lossFunction;\r\n    exports.disjointCluster = disjointCluster;\r\n    exports.distanceFromIntersectArea = distanceFromIntersectArea;\r\n    exports.VennDiagram = VennDiagram;\r\n    exports.wrapText = wrapText;\r\n    exports.computeTextCentres = computeTextCentres;\r\n    exports.computeTextCentre = computeTextCentre;\r\n    exports.sortAreas = sortAreas;\r\n    exports.circlePath = circlePath;\r\n    exports.circleFromPath = circleFromPath;\r\n    exports.intersectionAreaPath = intersectionAreaPath;\r\n    Object.defineProperty(exports, '__esModule', { value: true });\r\n})));\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\venn.js\\build\\venn.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\venn.js\\build\\venn.js"],"names":[],"mappings":"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","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-transition')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) :\n\t(factory((global.venn = {}),global.d3,global.d3));\n}(this, (function (exports,d3Selection,d3Transition) { 'use strict';\n\nvar SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nfunction intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles);\n\n    // filter out points that aren't included in all the circles\n    var innerPoints = intersectionPoints.filter(function (p) {\n        return containedInCircles(p, circles);\n    });\n\n    var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n    // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n    if (innerPoints.length > 1) {\n        // sort the points by angle from the center of the polygon, which lets\n        // us just iterate over points to get the edges\n        var center = getCenter(innerPoints);\n        for (i = 0; i < innerPoints.length; ++i ) {\n            var p = innerPoints[i];\n            p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n        }\n        innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n        // iterate over all points, get arc between the points\n        // and update the areas\n        var p2 = innerPoints[innerPoints.length - 1];\n        for (i = 0; i < innerPoints.length; ++i) {\n            var p1 = innerPoints[i];\n\n            // polygon area updates easily ...\n            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n            // updating the arc area is a little more involved\n            var midPoint = {x : (p1.x + p2.x) / 2,\n                            y : (p1.y + p2.y) / 2},\n                arc = null;\n\n            for (var j = 0; j < p1.parentIndex.length; ++j) {\n                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                    // figure out the angle halfway between the two points\n                    // on the current circle\n                    var circle = circles[p1.parentIndex[j]],\n                        a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                        a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                    var angleDiff = (a2 - a1);\n                    if (angleDiff < 0) {\n                        angleDiff += 2*Math.PI;\n                    }\n\n                    // and use that angle to figure out the width of the\n                    // arc\n                    var a = a2 - angleDiff/2,\n                        width = distance(midPoint, {\n                            x : circle.x + circle.radius * Math.sin(a),\n                            y : circle.y + circle.radius * Math.cos(a)\n                        });\n\n                    // clamp the width to the largest is can actually be\n                    // (sometimes slightly overflows because of FP errors)\n                    if (width > circle.radius * 2) {\n                        width = circle.radius * 2;\n                    }\n\n                    // pick the circle whose arc has the smallest width\n                    if ((arc === null) || (arc.width > width)) {\n                        arc = { circle : circle,\n                                width : width,\n                                p1 : p1,\n                                p2 : p2};\n                    }\n                }\n            }\n\n            if (arc !== null) {\n                arcs.push(arc);\n                arcArea += circleArea(arc.circle.radius, arc.width);\n                p2 = p1;\n            }\n        }\n    } else {\n        // no intersection points, is either disjoint - or is completely\n        // overlapped. figure out which by examining the smallest circle\n        var smallest = circles[0];\n        for (i = 1; i < circles.length; ++i) {\n            if (circles[i].radius < smallest.radius) {\n                smallest = circles[i];\n            }\n        }\n\n        // make sure the smallest circle is completely contained in all\n        // the other circles\n        var disjoint = false;\n        for (i = 0; i < circles.length; ++i) {\n            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                disjoint = true;\n                break;\n            }\n        }\n\n        if (disjoint) {\n            arcArea = polygonArea = 0;\n\n        } else {\n            arcArea = smallest.radius * smallest.radius * Math.PI;\n            arcs.push({circle : smallest,\n                       p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                       p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                       width : smallest.radius * 2 });\n        }\n    }\n\n    polygonArea /= 2;\n    if (stats) {\n        stats.area = arcArea + polygonArea;\n        stats.arcArea = arcArea;\n        stats.polygonArea = polygonArea;\n        stats.arcs = arcs;\n        stats.innerPoints = innerPoints;\n        stats.intersectionPoints = intersectionPoints;\n    }\n\n    return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nfunction containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n        if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n    var ret = [];\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var intersect = circleCircleIntersection(circles[i],\n                                                          circles[j]);\n            for (var k = 0; k < intersect.length; ++k) {\n                var p = intersect[k];\n                p.parentIndex = [i,j];\n                ret.push(p);\n            }\n        }\n    }\n    return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nfunction circleArea(r, width) {\n    return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nfunction distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                     (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nfunction circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n        return 0;\n    }\n\n    // completely overlapped\n    if (d <= Math.abs(r1 - r2)) {\n        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nfunction circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n        r1 = p1.radius,\n        r2 = p2.radius;\n\n    // if to far away, or self contained - can't be done\n    if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n        return [];\n    }\n\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n        h = Math.sqrt(r1 * r1 - a * a),\n        x0 = p1.x + a * (p2.x - p1.x) / d,\n        y0 = p1.y + a * (p2.y - p1.y) / d,\n        rx = -(p2.y - p1.y) * (h / d),\n        ry = -(p2.x - p1.x) * (h / d);\n\n    return [{x: x0 + rx, y : y0 - ry },\n            {x: x0 - rx, y : y0 + ry }];\n}\n\n/** Returns the center of a bunch of points */\nfunction getCenter(points) {\n    var center = {x: 0, y: 0};\n    for (var i =0; i < points.length; ++i ) {\n        center.x += points[i].x;\n        center.y += points[i].y;\n    }\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n}\n\n/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nfunction bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n        throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n        delta /= 2;\n        var mid = a + delta,\n            fMid = f(mid);\n\n        if (fMid * fA >= 0) {\n            a = mid;\n        }\n\n        if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n            return mid;\n        }\n    }\n    return a + delta;\n}\n\n// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nfunction zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\nfunction zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\nfunction dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n        ret += a[i] * b[i];\n    }\n    return ret;\n}\n\nfunction norm2(a)  {\n    return Math.sqrt(dot(a, a));\n}\n\nfunction scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n        ret[i] = value[i] * c;\n    }\n}\n\nfunction weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n}\n\n/** minimizes a function using the downhill simplex method */\nfunction nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n        chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n        psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n        sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n        maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n        var point = x0.slice();\n        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n        simplex[i+1] = point;\n        simplex[i+1].fx = f(point);\n        simplex[i+1].id = i+1;\n    }\n\n    function updateSimplex(value) {\n        for (var i = 0; i < value.length; i++) {\n            simplex[N][i] = value[i];\n        }\n        simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n        simplex.sort(sortOrder);\n\n        if (parameters.history) {\n            // copy the simplex (since later iterations will mutate) and\n            // sort it to have a consistent order between iterations\n            var sortedSimplex = simplex.map(function (x) {\n                var state = x.slice();\n                state.fx = x.fx;\n                state.id = x.id;\n                return state;\n            });\n            sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n            parameters.history.push({x: simplex[0].slice(),\n                                     fx: simplex[0].fx,\n                                     simplex: sortedSimplex});\n        }\n\n        maxDiff = 0;\n        for (i = 0; i < N; ++i) {\n            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n        }\n\n        if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n            (maxDiff < minTolerance)) {\n            break;\n        }\n\n        // compute the centroid of all but the worst point in the simplex\n        for (i = 0; i < N; ++i) {\n            centroid[i] = 0;\n            for (var j = 0; j < N; ++j) {\n                centroid[i] += simplex[j][i];\n            }\n            centroid[i] /= N;\n        }\n\n        // reflect the worst point past the centroid  and compute loss at reflected\n        // point\n        var worst = simplex[N];\n        weightedSum(reflected, 1+rho, centroid, -rho, worst);\n        reflected.fx = f(reflected);\n\n        // if the reflected point is the best seen, then possibly expand\n        if (reflected.fx < simplex[0].fx) {\n            weightedSum(expanded, 1+chi, centroid, -chi, worst);\n            expanded.fx = f(expanded);\n            if (expanded.fx < reflected.fx) {\n                updateSimplex(expanded);\n            }  else {\n                updateSimplex(reflected);\n            }\n        }\n\n        // if the reflected point is worse than the second worst, we need to\n        // contract\n        else if (reflected.fx >= simplex[N-1].fx) {\n            var shouldReduce = false;\n\n            if (reflected.fx > worst.fx) {\n                // do an inside contraction\n                weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < worst.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            } else {\n                // do an outside contraction\n                weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < reflected.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            }\n\n            if (shouldReduce) {\n                // if we don't contract here, we're done\n                if (sigma >= 1) break;\n\n                // do a reduction\n                for (i = 1; i < simplex.length; ++i) {\n                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                    simplex[i].fx = f(simplex[i]);\n                }\n            }\n        } else {\n            updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return {fx : simplex[0].fx,\n            x : simplex[0]};\n}\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nfunction wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0, phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n        for (var iteration = 0; iteration < 16; ++iteration) {\n            a = (a_lo + a_high)/2;\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (phi >= phi_lo)) {\n                a_high = a;\n\n            } else  {\n                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                    return a;\n                }\n\n                if (phiPrime * (a_high - a_lo) >=0) {\n                    a_high = a_lo;\n                }\n\n                a_lo = a;\n                phi_lo = phi;\n            }\n        }\n\n        return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n            (iteration && (phi >= phi_old))) {\n            return zoom(a0, a, phi_old);\n        }\n\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n        }\n\n        if (phiPrime >= 0 ) {\n            return zoom(a, a0, phi);\n        }\n\n        phi_old = phi;\n        a0 = a;\n        a *= 2;\n    }\n\n    return a;\n}\n\nfunction conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        yk = initial.slice(),\n        pk, temp,\n        a = 1,\n        maxIterations;\n\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime,-1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n        a = wolfeLineSearch(f, pk, current, next, a);\n\n        // todo: history in wrong spot?\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        if (!a) {\n            // faiiled to find point that satifies wolfe conditions.\n            // reset direction for next iteration\n            scale(pk, current.fxprime, -1);\n\n        } else {\n            // update direction using PolakRibiere CG method\n            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n            var delta_k = dot(current.fxprime, current.fxprime),\n                beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n            weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n            temp = current;\n            current = next;\n            next = temp;\n        }\n\n        if (norm2(current.fxprime) <= 1e-5) {\n            break;\n        }\n    }\n\n    if (params.history) {\n        params.history.push({x: current.x.slice(),\n                             fx: current.fx,\n                             fxprime: current.fxprime.slice(),\n                             alpha: a});\n    }\n\n    return current;\n}\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nfunction venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction;\n\n    // add in missing pairwise areas as having 0 size\n    areas = addMissingAreas(areas);\n\n    // initial layout is done greedily\n    var circles = initialLayout(areas, parameters);\n\n    // transform x/y coordinates to a vector to optimize\n    var initial = [], setids = [], setid;\n    for (setid in circles) {\n        if (circles.hasOwnProperty(setid)) {\n            initial.push(circles[setid].x);\n            initial.push(circles[setid].y);\n            setids.push(setid);\n        }\n    }\n\n    // optimize initial layout from our loss function\n    var solution = nelderMead(\n        function(values) {\n            var current = {};\n            for (var i = 0; i < setids.length; ++i) {\n                var setid = setids[i];\n                current[setid] = {x: values[2 * i],\n                                  y: values[2 * i + 1],\n                                  radius : circles[setid].radius,\n                                 // size : circles[setid].size\n                                 };\n            }\n            return loss(current, areas);\n        },\n        initial,\n        parameters);\n\n    // transform solution vector back to x/y points\n    var positions = solution.x;\n    for (var i = 0; i < setids.length; ++i) {\n        setid = setids[i];\n        circles[setid].x = positions[2 * i];\n        circles[setid].y = positions[2 * i + 1];\n    }\n\n    return circles;\n}\n\nvar SMALL$1 = 1e-10;\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {\n        return Math.abs(r1 - r2);\n    }\n\n    return bisect(function(distance$$1) {\n        return circleOverlap(r1, r2, distance$$1) - overlap;\n    }, 0, r1 + r2);\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n    areas = areas.slice();\n\n    // two circle intersections that aren't defined\n    var ids = [], pairs = {}, i, j, a, b;\n    for (i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            ids.push(area.sets[0]);\n        } else if (area.sets.length == 2) {\n            a = area.sets[0];\n            b = area.sets[1];\n            pairs[[a, b]] = true;\n            pairs[[b, a]] = true;\n        }\n    }\n    ids.sort(function(a, b) { return a > b; });\n\n    for (i = 0; i < ids.length; ++i) {\n        a = ids[i];\n        for (j = i + 1; j < ids.length; ++j) {\n            b = ids[j];\n            if (!([a, b] in pairs)) {\n                areas.push({'sets': [a, b],\n                            'size': 0});\n            }\n        }\n    }\n    return areas;\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nfunction getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n        constraints = zerosM(sets.length, sets.length);\n\n    // compute required distances between all the sets such that\n    // the areas match\n    areas.filter(function(x) { return x.sets.length == 2; })\n        .map(function(current) {\n        var left = setids[current.sets[0]],\n            right = setids[current.sets[1]],\n            r1 = Math.sqrt(sets[left].size / Math.PI),\n            r2 = Math.sqrt(sets[right].size / Math.PI),\n            distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\n\n        distances[left][right] = distances[right][left] = distance$$1;\n\n        // also update constraints to indicate if its a subset or disjoint\n        // relationship\n        var c = 0;\n        if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                             sets[right].size)) {\n            c = 1;\n        } else if (current.size <= 1e-10) {\n            c = -1;\n        }\n        constraints[left][right] = constraints[right][left] = c;\n    });\n\n    return {distances: distances, constraints: constraints};\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0, i;\n    for (i = 0; i < fxprime.length; ++i) {\n        fxprime[i] = 0;\n    }\n\n    for (i = 0; i < distances.length; ++i) {\n        var xi = x[2 * i], yi = x[2 * i + 1];\n        for (var j = i + 1; j < distances.length; ++j) {\n            var xj = x[2 * j], yj = x[2 * j + 1],\n                dij = distances[i][j],\n                constraint = constraints[i][j];\n\n            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                distance$$1 = Math.sqrt(squaredDistance),\n                delta = squaredDistance - dij * dij;\n\n            if (((constraint > 0) && (distance$$1 <= dij)) ||\n                ((constraint < 0) && (distance$$1 >= dij))) {\n                continue;\n            }\n\n            loss += 2 * delta * delta;\n\n            fxprime[2*i]     += 4 * delta * (xi - xj);\n            fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n            fxprime[2*j]     += 4 * delta * (xj - xi);\n            fxprime[2*j + 1] += 4 * delta * (yj - yi);\n        }\n    }\n    return loss;\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nfunction bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction;\n\n    // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n    if (areas.length >= 8) {\n        var constrained  = constrainedMDSLayout(areas, params),\n            constrainedLoss = loss(constrained, areas),\n            greedyLoss = loss(initial, areas);\n\n        if (constrainedLoss + 1e-8 < greedyLoss) {\n            initial = constrained;\n        }\n    }\n    return initial;\n}\n\n/// use the constrained MDS variant to generate an initial layout\nfunction constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10;\n\n    // bidirectionally map sets to a rowid  (so we can create a matrix)\n    var sets = [], setids = {}, i;\n    for (i = 0; i < areas.length; ++i ) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            setids[area.sets[0]] = sets.length;\n            sets.push(area);\n        }\n    }\n\n    var matrices = getDistanceMatrices(areas, sets, setids),\n        distances = matrices.distances,\n        constraints = matrices.constraints;\n\n    // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n    var norm = norm2(distances.map(norm2))/(distances.length);\n    distances = distances.map(function (row) {\n        return row.map(function (value) { return value / norm; });});\n\n    var obj = function(x, fxprime) {\n        return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n\n    var best, current;\n    for (i = 0; i < restarts; ++i) {\n        var initial = zeros(distances.length*2).map(Math.random);\n\n        current = conjugateGradient(obj, initial, params);\n        if (!best || (current.fx < best.fx)) {\n            best = current;\n        }\n    }\n    var positions = best.x;\n\n    // translate rows back to (x,y,radius) coordinates\n    var circles = {};\n    for (i = 0; i < sets.length; ++i) {\n        var set = sets[i];\n        circles[set.sets[0]] = {\n            x: positions[2*i] * norm,\n            y: positions[2*i + 1] * norm,\n            radius:  Math.sqrt(set.size / Math.PI)\n        };\n    }\n\n    if (params.history) {\n        for (i = 0; i < params.history.length; ++i) {\n            scale(params.history[i].x, norm);\n        }\n    }\n    return circles;\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nfunction greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n    // define a circle for each set\n    var circles = {}, setOverlaps = {}, set;\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            set = area.sets[0];\n            circles[set] = {x: 1e10, y: 1e10,\n                            rowid: circles.length,\n                            size: area.size,\n                            radius: Math.sqrt(area.size / Math.PI)};\n            setOverlaps[set] = [];\n        }\n    }\n    areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n    // map each set to a list of all the other sets that overlap it\n    for (i = 0; i < areas.length; ++i) {\n        var current = areas[i];\n        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n        var left = current.sets[0], right = current.sets[1];\n\n        // completely overlapped circles shouldn't be positioned early here\n        if (current.size + SMALL$1 >= Math.min(circles[left].size,\n                                             circles[right].size)) {\n            weight = 0;\n        }\n\n        setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n        setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n    }\n\n    // get list of most overlapped sets\n    var mostOverlapped = [];\n    for (set in setOverlaps) {\n        if (setOverlaps.hasOwnProperty(set)) {\n            var size = 0;\n            for (i = 0; i < setOverlaps[set].length; ++i) {\n                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n            }\n\n            mostOverlapped.push({set: set, size:size});\n        }\n    }\n\n    // sort by size desc\n    function sortOrder(a,b) {\n        return b.size - a.size;\n    }\n    mostOverlapped.sort(sortOrder);\n\n    // keep track of what sets have been laid out\n    var positioned = {};\n    function isPositioned(element) {\n        return element.set in positioned;\n    }\n\n    // adds a point to the output\n    function positionSet(point, index) {\n        circles[index].x = point.x;\n        circles[index].y = point.y;\n        positioned[index] = true;\n    }\n\n    // add most overlapped set at (0,0)\n    positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n    // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n    for (i = 1; i < mostOverlapped.length; ++i) {\n        var setIndex = mostOverlapped[i].set,\n            overlap = setOverlaps[setIndex].filter(isPositioned);\n        set = circles[setIndex];\n        overlap.sort(sortOrder);\n\n        if (overlap.length === 0) {\n            // this shouldn't happen anymore with addMissingAreas\n            throw \"ERROR: missing pairwise overlap information\";\n        }\n\n        var points = [];\n        for (var j = 0; j < overlap.length; ++j) {\n            // get appropriate distance from most overlapped already added set\n            var p1 = circles[overlap[j].set],\n                d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                               overlap[j].size);\n\n            // sample positions at 90 degrees for maximum aesthetics\n            points.push({x : p1.x + d1, y : p1.y});\n            points.push({x : p1.x - d1, y : p1.y});\n            points.push({y : p1.y + d1, x : p1.x});\n            points.push({y : p1.y - d1, x : p1.x});\n\n            // if we have at least 2 overlaps, then figure out where the\n            // set should be positioned analytically and try those too\n            for (var k = j + 1; k < overlap.length; ++k) {\n                var p2 = circles[overlap[k].set],\n                    d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                   overlap[k].size);\n\n                var extraPoints = circleCircleIntersection(\n                    { x: p1.x, y: p1.y, radius: d1},\n                    { x: p2.x, y: p2.y, radius: d2});\n\n                for (var l = 0; l < extraPoints.length; ++l) {\n                    points.push(extraPoints[l]);\n                }\n            }\n        }\n\n        // we have some candidate positions for the set, examine loss\n        // at each position to figure out where to put it at\n        var bestLoss = 1e50, bestPoint = points[0];\n        for (j = 0; j < points.length; ++j) {\n            circles[setIndex].x = points[j].x;\n            circles[setIndex].y = points[j].y;\n            var localLoss = loss(circles, areas);\n            if (localLoss < bestLoss) {\n                bestLoss = localLoss;\n                bestPoint = points[j];\n            }\n        }\n\n        positionSet(bestPoint, setIndex);\n    }\n\n    return circles;\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nfunction lossFunction(sets, overlaps) {\n    var output = 0;\n\n    function getCircles(indices) {\n        return indices.map(function(i) { return sets[i]; });\n    }\n\n    for (var i = 0; i < overlaps.length; ++i) {\n        var area = overlaps[i], overlap;\n        if (area.sets.length == 1) {\n            continue;\n        } else if (area.sets.length == 2) {\n            var left = sets[area.sets[0]],\n                right = sets[area.sets[1]];\n            overlap = circleOverlap(left.radius, right.radius,\n                                    distance(left, right));\n        } else {\n            overlap = intersectionArea(getCircles(area.sets));\n        }\n\n        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n        output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n\n    return output;\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n        circles.sort(function (a, b) { return b.radius - a.radius; });\n    } else {\n        circles.sort(orientationOrder);\n    }\n\n    var i;\n    // shift circles so largest circle is at (0, 0)\n    if (circles.length > 0) {\n        var largestX = circles[0].x,\n            largestY = circles[0].y;\n\n        for (i = 0; i < circles.length; ++i) {\n            circles[i].x -= largestX;\n            circles[i].y -= largestY;\n        }\n    }\n\n    if (circles.length == 2) {\n        // if the second circle is a subset of the first, arrange so that\n        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n        var dist = distance(circles[0], circles[1]);\n        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n            circles[1].y = circles[0].y;\n        }\n    }\n\n    // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n    if (circles.length > 1) {\n        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n            c = Math.cos(rotation),\n            s = Math.sin(rotation), x, y;\n\n        for (i = 0; i < circles.length; ++i) {\n            x = circles[i].x;\n            y = circles[i].y;\n            circles[i].x = c * x - s * y;\n            circles[i].y = s * x + c * y;\n        }\n    }\n\n    // mirror solution if third solution is above plane specified by\n    // first two circles\n    if (circles.length > 2) {\n        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n        while (angle < 0) { angle += 2* Math.PI; }\n        while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n        if (angle > Math.PI) {\n            var slope = circles[1].y / (1e-10 + circles[1].x);\n            for (i = 0; i < circles.length; ++i) {\n                var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                circles[i].x = 2 * d - circles[i].x;\n                circles[i].y = 2 * d * slope - circles[i].y;\n            }\n        }\n    }\n}\n\nfunction disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function(circle) { circle.parent = circle; });\n\n    // path compression step in union find\n    function find(circle) {\n        if (circle.parent !== circle) {\n            circle.parent = find(circle.parent);\n        }\n        return circle.parent;\n    }\n\n    function union(x, y) {\n        var xRoot = find(x), yRoot = find(y);\n        xRoot.parent = yRoot;\n    }\n\n    // get the union of all overlapping sets\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var maxDistance = circles[i].radius + circles[j].radius;\n            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                union(circles[j], circles[i]);\n            }\n        }\n    }\n\n    // find all the disjoint clusters and group them together\n    var disjointClusters = {}, setid;\n    for (i = 0; i < circles.length; ++i) {\n        setid = find(circles[i]).parent.setid;\n        if (!(setid in disjointClusters)) {\n            disjointClusters[setid] = [];\n        }\n        disjointClusters[setid].push(circles[i]);\n    }\n\n    // cleanup bookkeeping\n    circles.map(function(circle) { delete circle.parent; });\n\n    // return in more usable form\n    var ret = [];\n    for (setid in disjointClusters) {\n        if (disjointClusters.hasOwnProperty(setid)) {\n            ret.push(disjointClusters[setid]);\n        }\n    }\n    return ret;\n}\n\nfunction getBoundingBox(circles) {\n    var minMax = function(d) {\n        var hi = Math.max.apply(null, circles.map(\n                                function(c) { return c[d] + c.radius; } )),\n            lo = Math.min.apply(null, circles.map(\n                                function(c) { return c[d] - c.radius;} ));\n        return {max:hi, min:lo};\n    };\n\n    return {xRange: minMax('x'), yRange: minMax('y')};\n}\n\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null){\n        orientation = Math.PI/2;\n    }\n\n    // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n    var circles = [], i, setid;\n    for (setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            var previous = solution[setid];\n            circles.push({x: previous.x,\n                          y: previous.y,\n                          radius: previous.radius,\n                          setid: setid});\n        }\n    }\n\n    // get all the disjoint clusters\n    var clusters = disjointCluster(circles);\n\n    // orientate all disjoint sets, get sizes\n    for (i = 0; i < clusters.length; ++i) {\n        orientateCircles(clusters[i], orientation, orientationOrder);\n        var bounds = getBoundingBox(clusters[i]);\n        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n        clusters[i].bounds = bounds;\n    }\n    clusters.sort(function(a, b) { return b.size - a.size; });\n\n    // orientate the largest at 0,0, and get the bounds\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n    function addCluster(cluster, right, bottom) {\n        if (!cluster) return;\n\n        var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n        if (right) {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n        } else {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                        (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n            if (centreing < 0) xOffset += centreing;\n        }\n\n        if (bottom) {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n        } else {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                        (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n            if (centreing < 0) yOffset += centreing;\n        }\n\n        for (var j = 0; j < cluster.length; ++j) {\n            cluster[j].x += xOffset;\n            cluster[j].y += yOffset;\n            circles.push(cluster[j]);\n        }\n    }\n\n    var index = 1;\n    while (index < clusters.length) {\n        addCluster(clusters[index], true, false);\n        addCluster(clusters[index+1], false, true);\n        addCluster(clusters[index+2], true, true);\n        index += 3;\n\n        // have one cluster (in top left). lay out next three relative\n        // to it in a grid\n        returnBounds = getBoundingBox(circles);\n    }\n\n    // convert back to solution form\n    var ret = {};\n    for (i = 0; i < circles.length; ++i) {\n        ret[circles[i].setid] = circles[i];\n    }\n    return ret;\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nfunction scaleSolution(solution, width, height, padding) {\n    var circles = [], setids = [];\n    for (var setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            setids.push(setid);\n            circles.push(solution[setid]);\n        }\n    }\n\n    width -= 2*padding;\n    height -= 2*padding;\n\n    var bounds = getBoundingBox(circles),\n        xRange = bounds.xRange,\n        yRange = bounds.yRange;\n\n    if ((xRange.max == xRange.min) ||\n        (yRange.max == yRange.min)) {\n        console.log(\"not scaling solution: zero size detected\");\n        return solution;\n    }\n\n    var xScaling = width  / (xRange.max - xRange.min),\n        yScaling = height / (yRange.max - yRange.min),\n        scaling = Math.min(yScaling, xScaling),\n\n        // while we're at it, center the diagram too\n        xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n    var scaled = {};\n    for (var i = 0; i < circles.length; ++i) {\n        var circle = circles[i];\n        scaled[setids[i]] = {\n            radius: scaling * circle.radius,\n            x: padding + xOffset + (circle.x - xRange.min) * scaling,\n            y: padding + yOffset + (circle.y - yRange.min) * scaling,\n        };\n    }\n\n    return scaled;\n}\n\n/*global console:true*/\n\nfunction VennDiagram() {\n    var width = 600,\n        height = 350,\n        padding = 15,\n        duration = 1000,\n        orientation = Math.PI / 2,\n        normalize = true,\n        wrap = true,\n        styled = true,\n        fontSize = null,\n        orientationOrder = null,\n\n        // mimic the behaviour of d3.scale.category10 from the previous\n        // version of d3\n        colourMap = {},\n\n        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n        // since we can support older versions of d3 as long as we don't force this,\n        // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n        colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n        colourIndex = 0,\n        colours = function(key) {\n            if (key in colourMap) {\n                return colourMap[key];\n            }\n            var ret = colourMap[key] = colourScheme[colourIndex];\n            colourIndex += 1;\n            if (colourIndex >= colourScheme.length) {\n                colourIndex = 0;\n            }\n            return ret;\n        },\n        layoutFunction = venn,\n        loss = lossFunction;\n\n\n    function chart(selection) {\n        var data = selection.datum();\n\n        // handle 0-sized sets by removing from input\n        var toremove = {};\n        data.forEach(function(datum) {\n            if ((datum.size == 0) && datum.sets.length == 1) {\n                toremove[datum.sets[0]] = 1;\n            }\n        });\n        data = data.filter(function(datum) {\n            return !datum.sets.some(function(set) { return set in toremove; });\n        });\n\n        var circles = {};\n        var textCentres = {};\n\n        if (data.length > 0) {\n            var solution = layoutFunction(data, {lossFunction: loss});\n\n            if (normalize) {\n                solution = normalizeSolution(solution,\n                                            orientation,\n                                            orientationOrder);\n            }\n\n            circles = scaleSolution(solution, width, height, padding);\n            textCentres = computeTextCentres(circles, data);\n        }\n\n        // Figure out the current label for each set. These can change\n        // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n        var labels = {};\n        data.forEach(function(datum) {\n            if (datum.label) {\n                labels[datum.sets] = datum.label;\n            }\n        });\n\n        function label(d) {\n            if (d.sets in labels) {\n                return labels[d.sets];\n            }\n            if (d.sets.length == 1) {\n                return '' + d.sets[0];\n            }\n        }\n\n        // create svg if not already existing\n        selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n        var svg = selection.select(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        // to properly transition intersection areas, we need the\n        // previous circles locations. load from elements\n        var previous = {}, hasPrevious = false;\n        svg.selectAll(\".venn-area path\").each(function (d) {\n            var path = d3Selection.select(this).attr(\"d\");\n            if ((d.sets.length == 1) && path) {\n                hasPrevious = true;\n                previous[d.sets[0]] = circleFromPath(path);\n            }\n        });\n\n        // interpolate intersection area paths between previous and\n        // current paths\n        var pathTween = function(d) {\n            return function(t) {\n                var c = d.sets.map(function(set) {\n                    var start = previous[set], end = circles[set];\n                    if (!start) {\n                        start = {x : width/2, y : height/2, radius : 1};\n                    }\n                    if (!end) {\n                        end = {x : width/2, y : height/2, radius : 1};\n                    }\n                    return {'x' : start.x * (1 - t) + end.x * t,\n                            'y' : start.y * (1 - t) + end.y * t,\n                            'radius' : start.radius * (1 - t) + end.radius * t};\n                });\n                return intersectionAreaPath(c);\n            };\n        };\n\n        // update data, joining on the set ids\n        var nodes = svg.selectAll(\".venn-area\")\n            .data(data, function(d) { return d.sets; });\n\n        // create new nodes\n        var enter = nodes.enter()\n            .append('g')\n            .attr(\"class\", function(d) {\n                return \"venn-area venn-\" +\n                    (d.sets.length == 1 ? \"circle\" : \"intersection\");\n            })\n            .attr(\"data-venn-sets\", function(d) {\n                return d.sets.join(\"_\");\n            });\n\n        var enterPath = enter.append(\"path\"),\n            enterText = enter.append(\"text\")\n            .attr(\"class\", \"label\")\n            .text(function (d) { return label(d); } )\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"dy\", \".35em\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n\n        // apply minimal style if wanted\n        if (styled) {\n            enterPath.style(\"fill-opacity\", \"0\")\n                .filter(function (d) { return d.sets.length == 1; } )\n                .style(\"fill\", function(d) { return colours(d.sets); })\n                .style(\"fill-opacity\", \".25\");\n\n            enterText\n                .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\n        }\n\n        // update existing, using pathTween if necessary\n        var update = selection;\n        if (hasPrevious) {\n            update = selection.transition(\"venn\").duration(duration);\n            update.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n        } else {\n            update.selectAll(\"path\")\n                .attr(\"d\", function(d) {\n                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                });\n        }\n\n        var updateText = update.selectAll(\"text\")\n            .filter(function (d) { return d.sets in textCentres; })\n            .text(function (d) { return label(d); } )\n            .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n            .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n        if (wrap) {\n            if (hasPrevious) {\n                // d3 4.0 uses 'on' for events on transitions,\n                // but d3 3.0 used 'each' instead. switch appropiately\n                if ('on' in updateText) {\n                    updateText.on(\"end\", wrapText(circles, label));\n                } else {\n                    updateText.each(\"end\", wrapText(circles, label));\n                }\n            } else {\n                updateText.each(wrapText(circles, label));\n            }\n        }\n\n        // remove old\n        var exit = nodes.exit().transition('venn').duration(duration).remove();\n        exit.selectAll(\"path\")\n            .attrTween(\"d\", pathTween);\n\n        var exitText = exit.selectAll(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n        // if we've been passed a fontSize explicitly, use it to\n        // transition\n        if (fontSize !== null) {\n            enterText.style(\"font-size\", \"0px\");\n            updateText.style(\"font-size\", fontSize);\n            exitText.style(\"font-size\", \"0px\");\n        }\n\n\n        return {'circles': circles,\n                'textCentres': textCentres,\n                'nodes': nodes,\n                'enter': enter,\n                'update': update,\n                'exit': exit};\n    }\n\n    chart.wrap = function(_) {\n        if (!arguments.length) return wrap;\n        wrap = _;\n        return chart;\n    };\n\n    chart.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return chart;\n    };\n\n    chart.height = function(_) {\n        if (!arguments.length) return height;\n        height = _;\n        return chart;\n    };\n\n    chart.padding = function(_) {\n        if (!arguments.length) return padding;\n        padding = _;\n        return chart;\n    };\n\n    chart.colours = function(_) {\n        if (!arguments.length) return colours;\n        colours = _;\n        return chart;\n    };\n\n    chart.fontSize = function(_) {\n        if (!arguments.length) return fontSize;\n        fontSize = _;\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        return chart;\n    };\n\n    chart.layoutFunction = function(_) {\n        if (!arguments.length) return layoutFunction;\n        layoutFunction = _;\n        return chart;\n    };\n\n    chart.normalize = function(_) {\n        if (!arguments.length) return normalize;\n        normalize = _;\n        return chart;\n    };\n\n    chart.styled = function(_) {\n        if (!arguments.length) return styled;\n        styled = _;\n        return chart;\n    };\n\n    chart.orientation = function(_) {\n        if (!arguments.length) return orientation;\n        orientation = _;\n        return chart;\n    };\n\n    chart.orientationOrder = function(_) {\n        if (!arguments.length) return orientationOrder;\n        orientationOrder = _;\n        return chart;\n    };\n\n    chart.lossFunction = function(_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n\n    return chart;\n}\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n    return function() {\n        var text = d3Selection.select(this),\n            data = text.datum(),\n            width = circles[data.sets[0]].radius || 50,\n            label = labeller(data) || '';\n\n            var words = label.split(/\\s+/).reverse(),\n            maxLines = 3,\n            minChars = (label.length + words.length) / maxLines,\n            word = words.pop(),\n            line = [word],\n            joined,\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            tspan = text.text(null).append(\"tspan\").text(word);\n\n        while (true) {\n            word = words.pop();\n            if (!word) break;\n            line.push(word);\n            joined = line.join(\" \");\n            tspan.text(joined);\n            if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                line.pop();\n                tspan.text(line.join(\" \"));\n                line = [word];\n                tspan = text.append(\"tspan\").text(word);\n                lineNumber++;\n            }\n        }\n\n        var initial = 0.35 - lineNumber * lineHeight / 2,\n            x = text.attr(\"x\"),\n            y = text.attr(\"y\");\n\n        text.selectAll(\"tspan\")\n            .attr(\"x\", x)\n            .attr(\"y\", y)\n            .attr(\"dy\", function(d, i) {\n                 return (initial + i * lineHeight) + \"em\";\n            });\n    };\n}\n\nfunction circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current), i, m;\n    for (i = 1; i < interior.length; ++i) {\n        m = interior[i].radius - distance(interior[i], current);\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        m = distance(exterior[i], current) - exterior[i].radius;\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n    return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nfunction computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [], i;\n    for (i = 0; i < interior.length; ++i) {\n        var c = interior[i];\n        points.push({x: c.x, y: c.y});\n        points.push({x: c.x + c.radius/2, y: c.y});\n        points.push({x: c.x - c.radius/2, y: c.y});\n        points.push({x: c.x, y: c.y + c.radius/2});\n        points.push({x: c.x, y: c.y - c.radius/2});\n    }\n    var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n    for (i = 1; i < points.length; ++i) {\n        var m = circleMargin(points[i], interior, exterior);\n        if (m >= margin) {\n            initial = points[i];\n            margin = m;\n        }\n    }\n\n    // maximize the margin numerically\n    var solution = nelderMead(\n                function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                [initial.x, initial.y],\n                {maxIterations:500, minErrorDelta:1e-10}).x;\n    var ret = {x: solution[0], y: solution[1]};\n\n    // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n    var valid = true;\n    for (i = 0; i < interior.length; ++i) {\n        if (distance(ret, interior[i]) > interior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        if (distance(ret, exterior[i]) < exterior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    if (!valid) {\n        if (interior.length == 1) {\n            ret = {x: interior[0].x, y: interior[0].y};\n        } else {\n            var areaStats = {};\n            intersectionArea(interior, areaStats);\n\n            if (areaStats.arcs.length === 0) {\n                ret = {'x': 0, 'y': -1000, disjoint:true};\n\n            } else if (areaStats.arcs.length == 1) {\n                ret = {'x': areaStats.arcs[0].circle.x,\n                       'y': areaStats.arcs[0].circle.y};\n\n            } else if (exterior.length) {\n                // try again without other circles\n                ret = computeTextCentre(interior, []);\n\n            } else {\n                // take average of all the points in the intersection\n                // polygon. this should basically never happen\n                // and has some issues:\n                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n            }\n        }\n    }\n\n    return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n    var ret = {}, circleids = [];\n    for (var circleid in circles) {\n        circleids.push(circleid);\n        ret[circleid] = [];\n    }\n    for (var i  = 0; i < circleids.length; i++) {\n        var a = circles[circleids[i]];\n        for (var j = i + 1; j < circleids.length; ++j) {\n            var b = circles[circleids[j]],\n                d = distance(a, b);\n\n            if (d + b.radius <= a.radius + 1e-10) {\n                ret[circleids[j]].push(circleids[i]);\n\n            } else if (d + a.radius <= b.radius + 1e-10) {\n                ret[circleids[i]].push(circleids[j]);\n            }\n        }\n    }\n    return ret;\n}\n\nfunction computeTextCentres(circles, areas) {\n    var ret = {}, overlapped = getOverlappingCircles(circles);\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i].sets, areaids = {}, exclude = {};\n        for (var j = 0; j < area.length; ++j) {\n            areaids[area[j]] = true;\n            var overlaps = overlapped[area[j]];\n            // keep track of any circles that overlap this area,\n            // and don't consider for purposes of computing the text\n            // centre\n            for (var k = 0; k < overlaps.length; ++k) {\n                exclude[overlaps[k]] = true;\n            }\n        }\n\n        var interior = [], exterior = [];\n        for (var setid in circles) {\n            if (setid in areaids) {\n                interior.push(circles[setid]);\n            } else if (!(setid in exclude)) {\n                exterior.push(circles[setid]);\n            }\n        }\n        var centre = computeTextCentre(interior, exterior);\n        ret[area] = centre;\n        if (centre.disjoint && (areas[i].size > 0)) {\n            console.log(\"WARNING: area \" + area + \" not represented on screen\");\n        }\n    }\n    return  ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n        var check = relativeTo.sets[i];\n        for (var setid in overlaps) {\n            var overlap = overlaps[setid];\n            for (var j = 0; j < overlap.length; ++j) {\n                if (overlap[j] == check) {\n                    exclude[setid] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // checks that all sets are in exclude;\n    function shouldExclude(sets) {\n        for (var i = 0; i < sets.length; ++i) {\n            if (!(sets[i] in exclude)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // need to sort div's so that Z order is correct\n    div.selectAll(\"g\").sort(function (a, b) {\n        // highest order set intersections first\n        if (a.sets.length != b.sets.length) {\n            return a.sets.length - b.sets.length;\n        }\n\n        if (a == relativeTo) {\n            return shouldExclude(b.sets) ? -1 : 1;\n        }\n        if (b == relativeTo) {\n            return shouldExclude(a.sets) ? 1 : -1;\n        }\n\n        // finally by size\n        return b.size - a.size;\n    });\n}\n\nfunction circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n    return ret.join(\" \");\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nfunction circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {'x' : parseFloat(tokens[1]),\n            'y' : parseFloat(tokens[2]),\n            'radius' : -parseFloat(tokens[4])\n            };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nfunction intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n\n    if (arcs.length === 0) {\n        return \"M 0 0\";\n\n    } else if (arcs.length == 1) {\n        var circle = arcs[0].circle;\n        return circlePath(circle.x, circle.y, circle.radius);\n\n    } else {\n        // draw path around arcs\n        var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n        for (var i = 0; i < arcs.length; ++i) {\n            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n            ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                     arc.p1.x, arc.p1.y);\n        }\n        return ret.join(\" \");\n    }\n}\n\nexports.intersectionArea = intersectionArea;\nexports.circleCircleIntersection = circleCircleIntersection;\nexports.circleOverlap = circleOverlap;\nexports.circleArea = circleArea;\nexports.distance = distance;\nexports.venn = venn;\nexports.greedyLayout = greedyLayout;\nexports.scaleSolution = scaleSolution;\nexports.normalizeSolution = normalizeSolution;\nexports.bestInitialLayout = bestInitialLayout;\nexports.lossFunction = lossFunction;\nexports.disjointCluster = disjointCluster;\nexports.distanceFromIntersectArea = distanceFromIntersectArea;\nexports.VennDiagram = VennDiagram;\nexports.wrapText = wrapText;\nexports.computeTextCentres = computeTextCentres;\nexports.computeTextCentre = computeTextCentre;\nexports.sortAreas = sortAreas;\nexports.circlePath = circlePath;\nexports.circleFromPath = circleFromPath;\nexports.intersectionAreaPath = intersectionAreaPath;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}]}