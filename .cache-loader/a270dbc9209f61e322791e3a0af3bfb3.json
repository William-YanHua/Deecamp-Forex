{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\stitch.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\stitch.js","mtime":1491687944000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var epsilon = 1e-4, epsilonInverse = 1e4, x0 = -180, x0e = x0 + epsilon, x1 = 180, x1e = x1 - epsilon, y0 = -90, y0e = y0 + epsilon, y1 = 90, y1e = y1 - epsilon;\r\nfunction nonempty(coordinates) {\r\n    return coordinates.length > 0;\r\n}\r\nfunction quantize(x) {\r\n    return Math.floor(x * epsilonInverse) / epsilonInverse;\r\n}\r\nfunction normalizePoint(y) {\r\n    return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)];\r\n}\r\nfunction clampPoint(p) {\r\n    var x = p[0], y = p[1], clamped = false;\r\n    if (x <= x0e)\r\n        x = x0, clamped = true;\r\n    else if (x >= x1e)\r\n        x = x1, clamped = true;\r\n    if (y <= y0e)\r\n        y = y0, clamped = true;\r\n    else if (y >= y1e)\r\n        y = y1, clamped = true;\r\n    return clamped ? [x, y] : p;\r\n}\r\nfunction clampPoints(points) {\r\n    return points.map(clampPoint);\r\n}\r\nfunction extractFragments(rings, polygon, fragments) {\r\n    for (var j = 0, m = rings.length; j < m; ++j) {\r\n        var ring = rings[j].slice();\r\n        fragments.push({ index: -1, polygon: polygon, ring: ring });\r\n        for (var i = 0, n = ring.length; i < n; ++i) {\r\n            var point = ring[i], x = point[0], y = point[1];\r\n            if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\r\n                ring[i] = clampPoint(point);\r\n                for (var k = i + 1; k < n; ++k) {\r\n                    var pointk = ring[k], xk = pointk[0], yk = pointk[1];\r\n                    if (xk > x0e && xk < x1e && yk > y0e && yk < y1e)\r\n                        break;\r\n                }\r\n                if (k === i + 1)\r\n                    continue;\r\n                if (i) {\r\n                    var fragmentBefore = { index: -1, polygon: polygon, ring: ring.slice(0, i + 1) };\r\n                    fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\r\n                    fragments[fragments.length - 1] = fragmentBefore;\r\n                }\r\n                else\r\n                    fragments.pop();\r\n                if (k >= n)\r\n                    break;\r\n                fragments.push({ index: -1, polygon: polygon, ring: ring = ring.slice(k - 1) });\r\n                ring[0] = normalizePoint(ring[0][1]);\r\n                i = -1;\r\n                n = ring.length;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction stitchFragments(fragments) {\r\n    var i, n = fragments.length;\r\n    var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;\r\n    for (i = 0; i < n; ++i) {\r\n        fragment = fragments[i];\r\n        start = fragment.ring[0];\r\n        end = fragment.ring[fragment.ring.length - 1];\r\n        if (start[0] === end[0] && start[1] === end[1]) {\r\n            fragment.polygon.push(fragment.ring);\r\n            fragments[i] = null;\r\n            continue;\r\n        }\r\n        fragment.index = i;\r\n        fragmentByStart[start] = fragmentByEnd[end] = fragment;\r\n    }\r\n    for (i = 0; i < n; ++i) {\r\n        fragment = fragments[i];\r\n        if (fragment) {\r\n            start = fragment.ring[0];\r\n            end = fragment.ring[fragment.ring.length - 1];\r\n            startFragment = fragmentByEnd[start];\r\n            endFragment = fragmentByStart[end];\r\n            delete fragmentByStart[start];\r\n            delete fragmentByEnd[end];\r\n            if (start[0] === end[0] && start[1] === end[1]) {\r\n                fragment.polygon.push(fragment.ring);\r\n                continue;\r\n            }\r\n            if (startFragment) {\r\n                delete fragmentByEnd[start];\r\n                delete fragmentByStart[startFragment.ring[0]];\r\n                startFragment.ring.pop();\r\n                fragments[startFragment.index] = null;\r\n                fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };\r\n                if (startFragment === endFragment) {\r\n                    fragment.polygon.push(fragment.ring);\r\n                }\r\n                else {\r\n                    fragment.index = n++;\r\n                    fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\r\n                }\r\n            }\r\n            else if (endFragment) {\r\n                delete fragmentByStart[end];\r\n                delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\r\n                fragment.ring.pop();\r\n                fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };\r\n                fragments[endFragment.index] = null;\r\n                fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\r\n            }\r\n            else {\r\n                fragment.ring.push(fragment.ring[0]);\r\n                fragment.polygon.push(fragment.ring);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction stitchFeature(input) {\r\n    var output = { type: \"Feature\", geometry: stitchGeometry(input.geometry) };\r\n    if (input.id != null)\r\n        output.id = input.id;\r\n    if (input.bbox != null)\r\n        output.bbox = input.bbox;\r\n    if (input.properties != null)\r\n        output.properties = input.properties;\r\n    return output;\r\n}\r\nfunction stitchGeometry(input) {\r\n    if (input == null)\r\n        return input;\r\n    var output, fragments, i, n;\r\n    switch (input.type) {\r\n        case \"GeometryCollection\":\r\n            output = { type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry) };\r\n            break;\r\n        case \"Point\":\r\n            output = { type: \"Point\", coordinates: clampPoint(input.coordinates) };\r\n            break;\r\n        case \"MultiPoint\":\r\n        case \"LineString\":\r\n            output = { type: input.type, coordinates: clampPoints(input.coordinates) };\r\n            break;\r\n        case \"MultiLineString\":\r\n            output = { type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints) };\r\n            break;\r\n        case \"Polygon\": {\r\n            var polygon = [];\r\n            extractFragments(input.coordinates, polygon, fragments = []);\r\n            stitchFragments(fragments);\r\n            output = { type: \"Polygon\", coordinates: polygon };\r\n            break;\r\n        }\r\n        case \"MultiPolygon\": {\r\n            fragments = [], i = -1, n = input.coordinates.length;\r\n            var polygons = new Array(n);\r\n            while (++i < n)\r\n                extractFragments(input.coordinates[i], polygons[i] = [], fragments);\r\n            stitchFragments(fragments);\r\n            output = { type: \"MultiPolygon\", coordinates: polygons.filter(nonempty) };\r\n            break;\r\n        }\r\n        default: return input;\r\n    }\r\n    if (input.bbox != null)\r\n        output.bbox = input.bbox;\r\n    return output;\r\n}\r\nexport default function (input) {\r\n    if (input == null)\r\n        return input;\r\n    switch (input.type) {\r\n        case \"Feature\": return stitchFeature(input);\r\n        case \"FeatureCollection\": {\r\n            var output = { type: \"FeatureCollection\", features: input.features.map(stitchFeature) };\r\n            if (input.bbox != null)\r\n                output.bbox = input.bbox;\r\n            return output;\r\n        }\r\n        default: return stitchGeometry(input);\r\n    }\r\n}\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\stitch.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\d3-geo-projection\\src\\stitch.js"],"names":[],"mappings":"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","sourcesContent":["var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180, x0e = x0 + epsilon,\n    x1 = 180, x1e = x1 - epsilon,\n    y0 = -90, y0e = y0 + epsilon,\n    y1 = 90, y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0], y = p[1], clamped = false;\n  if (x <= x0e) x = x0, clamped = true;\n  else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;\n  else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice();\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push({index: -1, polygon: polygon, ring: ring});\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = {index: -1, polygon: polygon, ring: ring.slice(0, i + 1)};\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push({index: -1, polygon: polygon, ring: ring = ring.slice(k - 1)});\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n}\n\n// Now stitch the fragments back together into rings.\nfunction stitchFragments(fragments) {\n  var i, n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = {index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring)};\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n        fragment = {index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring)};\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {type: \"Feature\", geometry: stitchGeometry(input.geometry)};\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n  switch (input.type) {\n    case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry)}; break;\n    case \"Point\": output = {type: \"Point\", coordinates: clampPoint(input.coordinates)}; break;\n    case \"MultiPoint\": case \"LineString\": output = {type: input.type, coordinates: clampPoints(input.coordinates)}; break;\n    case \"MultiLineString\": output = {type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints)}; break;\n    case \"Polygon\": {\n      var polygon = [];\n      extractFragments(input.coordinates, polygon, fragments = []);\n      stitchFragments(fragments);\n      output = {type: \"Polygon\", coordinates: polygon};\n      break;\n    }\n    case \"MultiPolygon\": {\n      fragments = [], i = -1, n = input.coordinates.length;\n      var polygons = new Array(n);\n      while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n      stitchFragments(fragments);\n      output = {type: \"MultiPolygon\", coordinates: polygons.filter(nonempty)};\n      break;\n    }\n    default: return input;\n  }\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function(input) {\n  if (input == null) return input;\n  switch (input.type) {\n    case \"Feature\": return stitchFeature(input);\n    case \"FeatureCollection\": {\n      var output = {type: \"FeatureCollection\", features: input.features.map(stitchFeature)};\n      if (input.bbox != null) output.bbox = input.bbox;\n      return output;\n    }\n    default: return stitchGeometry(input);\n  }\n}\n"]}]}