{"remainingRequest":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js??ref--4-1!D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\util\\path.js","dependencies":[{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\util\\path.js","mtime":499162500000},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1595520254649},{"path":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\ts-loader\\index.js","mtime":1537906253000}],"contextDependencies":[],"result":["var Util = require('../../util');\r\nvar Spline = require('./spline');\r\nfunction points2path(points, isInCircle) {\r\n    if (!points.length) {\r\n        return [];\r\n    }\r\n    var path = [];\r\n    for (var i = 0, length = points.length; i < length; i++) {\r\n        var item = points[i];\r\n        if (i === 0) {\r\n            path.push(['M', item.x, item.y]);\r\n        }\r\n        else {\r\n            path.push(['L', item.x, item.y]);\r\n        }\r\n    }\r\n    if (isInCircle) {\r\n        path.push(['Z']);\r\n    }\r\n    return path;\r\n}\r\nfunction _getPointRadius(coord, point) {\r\n    var center = coord.getCenter();\r\n    var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\r\n    return r;\r\n}\r\nfunction convertArr(arr, coord) {\r\n    var len = arr.length;\r\n    var tmp = [arr[0]];\r\n    for (var i = 1; i < len; i = i + 2) {\r\n        var point = coord.convertPoint({\r\n            x: arr[i],\r\n            y: arr[i + 1]\r\n        });\r\n        tmp.push(point.x, point.y);\r\n    }\r\n    return tmp;\r\n}\r\nfunction _convertPolarPath(pre, cur, coord) {\r\n    var transposed = coord.isTransposed;\r\n    var startAngle = coord.startAngle;\r\n    var endAngle = coord.endAngle;\r\n    var prePoint = {\r\n        x: pre[1],\r\n        y: pre[2]\r\n    };\r\n    var curPoint = {\r\n        x: cur[1],\r\n        y: cur[2]\r\n    };\r\n    var rst = [];\r\n    var xDim = transposed ? 'y' : 'x';\r\n    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\r\n    var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;\r\n    var flag = angleRange > Math.PI ? 1 : 0;\r\n    var convertPoint = coord.convertPoint(curPoint);\r\n    var r = _getPointRadius(coord, convertPoint);\r\n    if (r >= 0.5) {\r\n        if (angleRange === Math.PI * 2) {\r\n            var middlePoint = {\r\n                x: (curPoint.x + prePoint.x) / 2,\r\n                y: (curPoint.y + prePoint.y) / 2\r\n            };\r\n            var middleConvertPoint = coord.convertPoint(middlePoint);\r\n            rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\r\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\r\n        }\r\n        else {\r\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\r\n        }\r\n    }\r\n    return rst;\r\n}\r\nfunction filterFullCirleLine(path) {\r\n    Util.each(path, function (subPath, index) {\r\n        var cur = subPath;\r\n        if (cur[0].toLowerCase() === 'a') {\r\n            var pre = path[index - 1];\r\n            var next = path[index + 1];\r\n            if (next && next[0].toLowerCase() === 'a') {\r\n                if (pre && pre[0].toLowerCase() === 'l') {\r\n                    pre[0] = 'M';\r\n                }\r\n            }\r\n            else if (pre && pre[0].toLowerCase() === 'a') {\r\n                if (next && next[0].toLowerCase() === 'l') {\r\n                    next[0] = 'M';\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\nvar PathUtil = {\r\n    getLinePath: function getLinePath(points, isInCircle) {\r\n        return points2path(points, isInCircle);\r\n    },\r\n    getSplinePath: function getSplinePath(points, isInCircle, constaint) {\r\n        var data = [];\r\n        var first = points[0];\r\n        var prePoint = null;\r\n        if (points.length <= 2) {\r\n            return PathUtil.getLinePath(points, isInCircle);\r\n        }\r\n        Util.each(points, function (point) {\r\n            if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\r\n                data.push(point.x);\r\n                data.push(point.y);\r\n                prePoint = point;\r\n            }\r\n        });\r\n        constaint = constaint || [\r\n            [0, 0], [1, 1]\r\n        ];\r\n        var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);\r\n        splinePath.unshift(['M', first.x, first.y]);\r\n        return splinePath;\r\n    },\r\n    getPointRadius: function getPointRadius(coord, point) {\r\n        var result = _getPointRadius(coord, point);\r\n        return result;\r\n    },\r\n    getPointAngle: function getPointAngle(coord, point) {\r\n        var center = coord.getCenter();\r\n        var angle = Math.atan2(point.y - center.y, point.x - center.x);\r\n        return angle;\r\n    },\r\n    convertNormalPath: function convertNormalPath(coord, path) {\r\n        var tmp = [];\r\n        Util.each(path, function (subPath) {\r\n            var action = subPath[0];\r\n            switch (action.toLowerCase()) {\r\n                case 'm':\r\n                case 'l':\r\n                case 'c':\r\n                    tmp.push(convertArr(subPath, coord));\r\n                    break;\r\n                case 'z':\r\n                default:\r\n                    tmp.push(subPath);\r\n                    break;\r\n            }\r\n        });\r\n        return tmp;\r\n    },\r\n    convertPolarPath: function convertPolarPath(coord, path) {\r\n        var tmp = [];\r\n        var pre;\r\n        var cur;\r\n        var transposed;\r\n        var equals;\r\n        Util.each(path, function (subPath, index) {\r\n            var action = subPath[0];\r\n            switch (action.toLowerCase()) {\r\n                case 'm':\r\n                case 'c':\r\n                case 'q':\r\n                    tmp.push(convertArr(subPath, coord));\r\n                    break;\r\n                case 'l':\r\n                    pre = path[index - 1];\r\n                    cur = subPath;\r\n                    transposed = coord.isTransposed;\r\n                    equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\r\n                    if (equals) {\r\n                        tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\r\n                    }\r\n                    else {\r\n                        tmp.push(convertArr(subPath, coord));\r\n                    }\r\n                    break;\r\n                case 'z':\r\n                default:\r\n                    tmp.push(subPath);\r\n                    break;\r\n            }\r\n        });\r\n        filterFullCirleLine(tmp);\r\n        return tmp;\r\n    }\r\n};\r\nmodule.exports = PathUtil;\r\n",{"version":3,"file":"D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\util\\path.js","sourceRoot":"","sources":["D:\\project\\Deecamp-project\\system\\Web\\node_modules\\@antv\\g2\\lib\\geom\\util\\path.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview 计算path 使用的工具方法\n * @author dxq613@gmail.com\n */\nvar Util = require('../../util');\n\nvar Spline = require('./spline');\n\nfunction points2path(points, isInCircle) {\n  if (!points.length) {\n    return [];\n  }\n\n  var path = [];\n\n  for (var i = 0, length = points.length; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      path.push(['M', item.x, item.y]);\n    } else {\n      path.push(['L', item.x, item.y]);\n    }\n  }\n\n  if (isInCircle) {\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\nfunction _getPointRadius(coord, point) {\n  var center = coord.getCenter();\n  var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n  return r;\n}\n\nfunction convertArr(arr, coord) {\n  var len = arr.length;\n  var tmp = [arr[0]];\n\n  for (var i = 1; i < len; i = i + 2) {\n    var point = coord.convertPoint({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  // const radius = coord.getRadius();\n  // const inner = coord.innerRadius || 0;\n  // let innerRadius = inner * radius;\n  var transposed = coord.isTransposed;\n  var startAngle = coord.startAngle;\n  var endAngle = coord.endAngle;\n  var prePoint = {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = []; // innerRadius = innerRadius || 0;\n\n  var xDim = transposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convertPoint(curPoint);\n\n  var r = _getPointRadius(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convertPoint(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction filterFullCirleLine(path) {\n  Util.each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\nvar PathUtil = {\n  // 线的path\n  getLinePath: function getLinePath(points, isInCircle) {\n    return points2path(points, isInCircle);\n  },\n  // get spline： 限定了范围的平滑线\n  getSplinePath: function getSplinePath(points, isInCircle, constaint) {\n    var data = [];\n    var first = points[0];\n    var prePoint = null;\n\n    if (points.length <= 2) {\n      return PathUtil.getLinePath(points, isInCircle);\n    }\n\n    Util.each(points, function (point) {\n      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n        data.push(point.x);\n        data.push(point.y);\n        prePoint = point;\n      }\n    });\n    constaint = constaint || [// 范围\n    [0, 0], [1, 1]];\n    var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);\n    splinePath.unshift(['M', first.x, first.y]);\n    return splinePath;\n  },\n  getPointRadius: function getPointRadius(coord, point) {\n    var result = _getPointRadius(coord, point);\n\n    return result;\n  },\n  getPointAngle: function getPointAngle(coord, point) {\n    var center = coord.getCenter();\n    var angle = Math.atan2(point.y - center.y, point.x - center.x);\n    return angle;\n  },\n  convertNormalPath: function convertNormalPath(coord, path) {\n    var tmp = [];\n    Util.each(path, function (subPath) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'l':\n        case 'c':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    return tmp;\n  },\n  convertPolarPath: function convertPolarPath(coord, path) {\n    var tmp = [];\n    var pre;\n    var cur;\n    var transposed;\n    var equals;\n    Util.each(path, function (subPath, index) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'c':\n        case 'q':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'l':\n          pre = path[index - 1];\n          cur = subPath;\n          transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n          equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n          if (equals) {\n            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n          } else {\n            // y 不相等，所以直接转换\n            tmp.push(convertArr(subPath, coord));\n          }\n\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    filterFullCirleLine(tmp); // 过滤多余的直线\n\n    return tmp;\n  }\n};\nmodule.exports = PathUtil;"]}]}